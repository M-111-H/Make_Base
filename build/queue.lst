ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 1


   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"queue.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "./FreeRTOS/queue.c"
  18              		.section	.text.prvGetDisinheritPriorityAfterTimeout,"ax",%progbits
  19              		.align	1
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  24              	prvGetDisinheritPriorityAfterTimeout:
  25              	.LVL0:
  26              	.LFB51:
   1:./FreeRTOS/queue.c **** /*
   2:./FreeRTOS/queue.c ****  * FreeRTOS Kernel V10.5.1
   3:./FreeRTOS/queue.c ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:./FreeRTOS/queue.c ****  *
   5:./FreeRTOS/queue.c ****  * SPDX-License-Identifier: MIT
   6:./FreeRTOS/queue.c ****  *
   7:./FreeRTOS/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:./FreeRTOS/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   9:./FreeRTOS/queue.c ****  * the Software without restriction, including without limitation the rights to
  10:./FreeRTOS/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:./FreeRTOS/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:./FreeRTOS/queue.c ****  * subject to the following conditions:
  13:./FreeRTOS/queue.c ****  *
  14:./FreeRTOS/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  15:./FreeRTOS/queue.c ****  * copies or substantial portions of the Software.
  16:./FreeRTOS/queue.c ****  *
  17:./FreeRTOS/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:./FreeRTOS/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:./FreeRTOS/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:./FreeRTOS/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:./FreeRTOS/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:./FreeRTOS/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:./FreeRTOS/queue.c ****  *
  24:./FreeRTOS/queue.c ****  * https://www.FreeRTOS.org
  25:./FreeRTOS/queue.c ****  * https://github.com/FreeRTOS
  26:./FreeRTOS/queue.c ****  *
  27:./FreeRTOS/queue.c ****  */
  28:./FreeRTOS/queue.c **** 
  29:./FreeRTOS/queue.c **** #include <stdlib.h>
  30:./FreeRTOS/queue.c **** #include <string.h>
  31:./FreeRTOS/queue.c **** 
  32:./FreeRTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 2


  33:./FreeRTOS/queue.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  34:./FreeRTOS/queue.c ****  * task.h is included from an application file. */
  35:./FreeRTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:./FreeRTOS/queue.c **** 
  37:./FreeRTOS/queue.c **** #include "FreeRTOS.h"
  38:./FreeRTOS/queue.c **** #include "task.h"
  39:./FreeRTOS/queue.c **** #include "queue.h"
  40:./FreeRTOS/queue.c **** 
  41:./FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  42:./FreeRTOS/queue.c ****     #include "croutine.h"
  43:./FreeRTOS/queue.c **** #endif
  44:./FreeRTOS/queue.c **** 
  45:./FreeRTOS/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  46:./FreeRTOS/queue.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  47:./FreeRTOS/queue.c ****  * for the header files above, but not in this file, in order to generate the
  48:./FreeRTOS/queue.c ****  * correct privileged Vs unprivileged linkage and placement. */
  49:./FreeRTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  50:./FreeRTOS/queue.c **** 
  51:./FreeRTOS/queue.c **** 
  52:./FreeRTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  53:./FreeRTOS/queue.c **** #define queueUNLOCKED             ( ( int8_t ) -1 )
  54:./FreeRTOS/queue.c **** #define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )
  55:./FreeRTOS/queue.c **** #define queueINT8_MAX             ( ( int8_t ) 127 )
  56:./FreeRTOS/queue.c **** 
  57:./FreeRTOS/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  58:./FreeRTOS/queue.c ****  * pcTail members are used as pointers into the queue storage area.  When the
  59:./FreeRTOS/queue.c ****  * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  60:./FreeRTOS/queue.c ****  * not necessary, and the pcHead pointer is set to NULL to indicate that the
  61:./FreeRTOS/queue.c ****  * structure instead holds a pointer to the mutex holder (if any).  Map alternative
  62:./FreeRTOS/queue.c ****  * names to the pcHead and structure member to ensure the readability of the code
  63:./FreeRTOS/queue.c ****  * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  64:./FreeRTOS/queue.c ****  * a union as their usage is mutually exclusive dependent on what the queue is
  65:./FreeRTOS/queue.c ****  * being used for. */
  66:./FreeRTOS/queue.c **** #define uxQueueType               pcHead
  67:./FreeRTOS/queue.c **** #define queueQUEUE_IS_MUTEX       NULL
  68:./FreeRTOS/queue.c **** 
  69:./FreeRTOS/queue.c **** typedef struct QueuePointers
  70:./FreeRTOS/queue.c **** {
  71:./FreeRTOS/queue.c ****     int8_t * pcTail;     /*< Points to the byte at the end of the queue storage area.  Once more by
  72:./FreeRTOS/queue.c ****     int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the str
  73:./FreeRTOS/queue.c **** } QueuePointers_t;
  74:./FreeRTOS/queue.c **** 
  75:./FreeRTOS/queue.c **** typedef struct SemaphoreData
  76:./FreeRTOS/queue.c **** {
  77:./FreeRTOS/queue.c ****     TaskHandle_t xMutexHolder;        /*< The handle of the task that holds the mutex. */
  78:./FreeRTOS/queue.c ****     UBaseType_t uxRecursiveCallCount; /*< Maintains a count of the number of times a recursive mute
  79:./FreeRTOS/queue.c **** } SemaphoreData_t;
  80:./FreeRTOS/queue.c **** 
  81:./FreeRTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  82:./FreeRTOS/queue.c ****  * zero. */
  83:./FreeRTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )
  84:./FreeRTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )
  85:./FreeRTOS/queue.c **** 
  86:./FreeRTOS/queue.c **** #if ( configUSE_PREEMPTION == 0 )
  87:./FreeRTOS/queue.c **** 
  88:./FreeRTOS/queue.c **** /* If the cooperative scheduler is being used then a yield should not be
  89:./FreeRTOS/queue.c ****  * performed just because a higher priority task has been woken. */
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 3


  90:./FreeRTOS/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()
  91:./FreeRTOS/queue.c **** #else
  92:./FreeRTOS/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
  93:./FreeRTOS/queue.c **** #endif
  94:./FreeRTOS/queue.c **** 
  95:./FreeRTOS/queue.c **** /*
  96:./FreeRTOS/queue.c ****  * Definition of the queue used by the scheduler.
  97:./FreeRTOS/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  98:./FreeRTOS/queue.c ****  * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
  99:./FreeRTOS/queue.c ****  */
 100:./FreeRTOS/queue.c **** typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel awar
 101:./FreeRTOS/queue.c **** {
 102:./FreeRTOS/queue.c ****     int8_t * pcHead;           /*< Points to the beginning of the queue storage area. */
 103:./FreeRTOS/queue.c ****     int8_t * pcWriteTo;        /*< Points to the free next place in the storage area. */
 104:./FreeRTOS/queue.c **** 
 105:./FreeRTOS/queue.c ****     union
 106:./FreeRTOS/queue.c ****     {
 107:./FreeRTOS/queue.c ****         QueuePointers_t xQueue;     /*< Data required exclusively when this structure is used as a 
 108:./FreeRTOS/queue.c ****         SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a 
 109:./FreeRTOS/queue.c ****     } u;
 110:./FreeRTOS/queue.c **** 
 111:./FreeRTOS/queue.c ****     List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post onto
 112:./FreeRTOS/queue.c ****     List_t xTasksWaitingToReceive;          /*< List of tasks that are blocked waiting to read from
 113:./FreeRTOS/queue.c **** 
 114:./FreeRTOS/queue.c ****     volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. */
 115:./FreeRTOS/queue.c ****     UBaseType_t uxLength;                   /*< The length of the queue defined as the number of it
 116:./FreeRTOS/queue.c ****     UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold. */
 117:./FreeRTOS/queue.c **** 
 118:./FreeRTOS/queue.c ****     volatile int8_t cRxLock;                /*< Stores the number of items received from the queue 
 119:./FreeRTOS/queue.c ****     volatile int8_t cTxLock;                /*< Stores the number of items transmitted to the queue
 120:./FreeRTOS/queue.c **** 
 121:./FreeRTOS/queue.c ****     #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 122:./FreeRTOS/queue.c ****         uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was static
 123:./FreeRTOS/queue.c ****     #endif
 124:./FreeRTOS/queue.c **** 
 125:./FreeRTOS/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 126:./FreeRTOS/queue.c ****         struct QueueDefinition * pxQueueSetContainer;
 127:./FreeRTOS/queue.c ****     #endif
 128:./FreeRTOS/queue.c **** 
 129:./FreeRTOS/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 130:./FreeRTOS/queue.c ****         UBaseType_t uxQueueNumber;
 131:./FreeRTOS/queue.c ****         uint8_t ucQueueType;
 132:./FreeRTOS/queue.c ****     #endif
 133:./FreeRTOS/queue.c **** } xQUEUE;
 134:./FreeRTOS/queue.c **** 
 135:./FreeRTOS/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 136:./FreeRTOS/queue.c ****  * name below to enable the use of older kernel aware debuggers. */
 137:./FreeRTOS/queue.c **** typedef xQUEUE Queue_t;
 138:./FreeRTOS/queue.c **** 
 139:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 140:./FreeRTOS/queue.c **** 
 141:./FreeRTOS/queue.c **** /*
 142:./FreeRTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 143:./FreeRTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 144:./FreeRTOS/queue.c ****  */
 145:./FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 146:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 4


 147:./FreeRTOS/queue.c **** /* The type stored within the queue registry array.  This allows a name
 148:./FreeRTOS/queue.c ****  * to be assigned to each queue making kernel aware debugging a little
 149:./FreeRTOS/queue.c ****  * more user friendly. */
 150:./FreeRTOS/queue.c ****     typedef struct QUEUE_REGISTRY_ITEM
 151:./FreeRTOS/queue.c ****     {
 152:./FreeRTOS/queue.c ****         const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and s
 153:./FreeRTOS/queue.c ****         QueueHandle_t xHandle;
 154:./FreeRTOS/queue.c ****     } xQueueRegistryItem;
 155:./FreeRTOS/queue.c **** 
 156:./FreeRTOS/queue.c **** /* The old xQueueRegistryItem name is maintained above then typedefed to the
 157:./FreeRTOS/queue.c ****  * new xQueueRegistryItem name below to enable the use of older kernel aware
 158:./FreeRTOS/queue.c ****  * debuggers. */
 159:./FreeRTOS/queue.c ****     typedef xQueueRegistryItem QueueRegistryItem_t;
 160:./FreeRTOS/queue.c **** 
 161:./FreeRTOS/queue.c **** /* The queue registry is simply an array of QueueRegistryItem_t structures.
 162:./FreeRTOS/queue.c ****  * The pcQueueName member of a structure being NULL is indicative of the
 163:./FreeRTOS/queue.c ****  * array position being vacant. */
 164:./FreeRTOS/queue.c ****     PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 165:./FreeRTOS/queue.c **** 
 166:./FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 167:./FreeRTOS/queue.c **** 
 168:./FreeRTOS/queue.c **** /*
 169:./FreeRTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 170:./FreeRTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 171:./FreeRTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 172:./FreeRTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 173:./FreeRTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 174:./FreeRTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 175:./FreeRTOS/queue.c ****  */
 176:./FreeRTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 177:./FreeRTOS/queue.c **** 
 178:./FreeRTOS/queue.c **** /*
 179:./FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 180:./FreeRTOS/queue.c ****  *
 181:./FreeRTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 182:./FreeRTOS/queue.c ****  */
 183:./FreeRTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 184:./FreeRTOS/queue.c **** 
 185:./FreeRTOS/queue.c **** /*
 186:./FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 187:./FreeRTOS/queue.c ****  *
 188:./FreeRTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 189:./FreeRTOS/queue.c ****  */
 190:./FreeRTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 191:./FreeRTOS/queue.c **** 
 192:./FreeRTOS/queue.c **** /*
 193:./FreeRTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 194:./FreeRTOS/queue.c ****  * back of the queue.
 195:./FreeRTOS/queue.c ****  */
 196:./FreeRTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
 197:./FreeRTOS/queue.c ****                                       const void * pvItemToQueue,
 198:./FreeRTOS/queue.c ****                                       const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
 199:./FreeRTOS/queue.c **** 
 200:./FreeRTOS/queue.c **** /*
 201:./FreeRTOS/queue.c ****  * Copies an item out of a queue.
 202:./FreeRTOS/queue.c ****  */
 203:./FreeRTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 5


 204:./FreeRTOS/queue.c ****                                   void * const pvBuffer ) PRIVILEGED_FUNCTION;
 205:./FreeRTOS/queue.c **** 
 206:./FreeRTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 207:./FreeRTOS/queue.c **** 
 208:./FreeRTOS/queue.c **** /*
 209:./FreeRTOS/queue.c ****  * Checks to see if a queue is a member of a queue set, and if so, notifies
 210:./FreeRTOS/queue.c ****  * the queue set that the queue contains data.
 211:./FreeRTOS/queue.c ****  */
 212:./FreeRTOS/queue.c ****     static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTI
 213:./FreeRTOS/queue.c **** #endif
 214:./FreeRTOS/queue.c **** 
 215:./FreeRTOS/queue.c **** /*
 216:./FreeRTOS/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 217:./FreeRTOS/queue.c ****  * dynamically to fill in the structure's members.
 218:./FreeRTOS/queue.c ****  */
 219:./FreeRTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 220:./FreeRTOS/queue.c ****                                    const UBaseType_t uxItemSize,
 221:./FreeRTOS/queue.c ****                                    uint8_t * pucQueueStorage,
 222:./FreeRTOS/queue.c ****                                    const uint8_t ucQueueType,
 223:./FreeRTOS/queue.c ****                                    Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 224:./FreeRTOS/queue.c **** 
 225:./FreeRTOS/queue.c **** /*
 226:./FreeRTOS/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 227:./FreeRTOS/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 228:./FreeRTOS/queue.c ****  * as a mutex.
 229:./FreeRTOS/queue.c ****  */
 230:./FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 231:./FreeRTOS/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 232:./FreeRTOS/queue.c **** #endif
 233:./FreeRTOS/queue.c **** 
 234:./FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 235:./FreeRTOS/queue.c **** 
 236:./FreeRTOS/queue.c **** /*
 237:./FreeRTOS/queue.c ****  * If a task waiting for a mutex causes the mutex holder to inherit a
 238:./FreeRTOS/queue.c ****  * priority, but the waiting task times out, then the holder should
 239:./FreeRTOS/queue.c ****  * disinherit the priority - but only down to the highest priority of any
 240:./FreeRTOS/queue.c ****  * other tasks that are waiting for the same mutex.  This function returns
 241:./FreeRTOS/queue.c ****  * that priority.
 242:./FreeRTOS/queue.c ****  */
 243:./FreeRTOS/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVIL
 244:./FreeRTOS/queue.c **** #endif
 245:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 246:./FreeRTOS/queue.c **** 
 247:./FreeRTOS/queue.c **** /*
 248:./FreeRTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 249:./FreeRTOS/queue.c ****  * accessing the queue event lists.
 250:./FreeRTOS/queue.c ****  */
 251:./FreeRTOS/queue.c **** #define prvLockQueue( pxQueue )                            \
 252:./FreeRTOS/queue.c ****     taskENTER_CRITICAL();                                  \
 253:./FreeRTOS/queue.c ****     {                                                      \
 254:./FreeRTOS/queue.c ****         if( ( pxQueue )->cRxLock == queueUNLOCKED )        \
 255:./FreeRTOS/queue.c ****         {                                                  \
 256:./FreeRTOS/queue.c ****             ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \
 257:./FreeRTOS/queue.c ****         }                                                  \
 258:./FreeRTOS/queue.c ****         if( ( pxQueue )->cTxLock == queueUNLOCKED )        \
 259:./FreeRTOS/queue.c ****         {                                                  \
 260:./FreeRTOS/queue.c ****             ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 6


 261:./FreeRTOS/queue.c ****         }                                                  \
 262:./FreeRTOS/queue.c ****     }                                                      \
 263:./FreeRTOS/queue.c ****     taskEXIT_CRITICAL()
 264:./FreeRTOS/queue.c **** 
 265:./FreeRTOS/queue.c **** /*
 266:./FreeRTOS/queue.c ****  * Macro to increment cTxLock member of the queue data structure. It is
 267:./FreeRTOS/queue.c ****  * capped at the number of tasks in the system as we cannot unblock more
 268:./FreeRTOS/queue.c ****  * tasks than the number of tasks in the system.
 269:./FreeRTOS/queue.c ****  */
 270:./FreeRTOS/queue.c **** #define prvIncrementQueueTxLock( pxQueue, cTxLock )                           \
 271:./FreeRTOS/queue.c ****     {                                                                         \
 272:./FreeRTOS/queue.c ****         const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks();         \
 273:./FreeRTOS/queue.c ****         if( ( UBaseType_t ) ( cTxLock ) < uxNumberOfTasks )                   \
 274:./FreeRTOS/queue.c ****         {                                                                     \
 275:./FreeRTOS/queue.c ****             configASSERT( ( cTxLock ) != queueINT8_MAX );                     \
 276:./FreeRTOS/queue.c ****             ( pxQueue )->cTxLock = ( int8_t ) ( ( cTxLock ) + ( int8_t ) 1 ); \
 277:./FreeRTOS/queue.c ****         }                                                                     \
 278:./FreeRTOS/queue.c ****     }
 279:./FreeRTOS/queue.c **** 
 280:./FreeRTOS/queue.c **** /*
 281:./FreeRTOS/queue.c ****  * Macro to increment cRxLock member of the queue data structure. It is
 282:./FreeRTOS/queue.c ****  * capped at the number of tasks in the system as we cannot unblock more
 283:./FreeRTOS/queue.c ****  * tasks than the number of tasks in the system.
 284:./FreeRTOS/queue.c ****  */
 285:./FreeRTOS/queue.c **** #define prvIncrementQueueRxLock( pxQueue, cRxLock )                           \
 286:./FreeRTOS/queue.c ****     {                                                                         \
 287:./FreeRTOS/queue.c ****         const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks();         \
 288:./FreeRTOS/queue.c ****         if( ( UBaseType_t ) ( cRxLock ) < uxNumberOfTasks )                   \
 289:./FreeRTOS/queue.c ****         {                                                                     \
 290:./FreeRTOS/queue.c ****             configASSERT( ( cRxLock ) != queueINT8_MAX );                     \
 291:./FreeRTOS/queue.c ****             ( pxQueue )->cRxLock = ( int8_t ) ( ( cRxLock ) + ( int8_t ) 1 ); \
 292:./FreeRTOS/queue.c ****         }                                                                     \
 293:./FreeRTOS/queue.c ****     }
 294:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 295:./FreeRTOS/queue.c **** 
 296:./FreeRTOS/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
 297:./FreeRTOS/queue.c ****                                BaseType_t xNewQueue )
 298:./FreeRTOS/queue.c **** {
 299:./FreeRTOS/queue.c ****     BaseType_t xReturn = pdPASS;
 300:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 301:./FreeRTOS/queue.c **** 
 302:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
 303:./FreeRTOS/queue.c **** 
 304:./FreeRTOS/queue.c ****     if( ( pxQueue != NULL ) &&
 305:./FreeRTOS/queue.c ****         ( pxQueue->uxLength >= 1U ) &&
 306:./FreeRTOS/queue.c ****         /* Check for multiplication overflow. */
 307:./FreeRTOS/queue.c ****         ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 308:./FreeRTOS/queue.c ****     {
 309:./FreeRTOS/queue.c ****         taskENTER_CRITICAL();
 310:./FreeRTOS/queue.c ****         {
 311:./FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize 
 312:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 313:./FreeRTOS/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
 314:./FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue
 315:./FreeRTOS/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 316:./FreeRTOS/queue.c ****             pxQueue->cTxLock = queueUNLOCKED;
 317:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 7


 318:./FreeRTOS/queue.c ****             if( xNewQueue == pdFALSE )
 319:./FreeRTOS/queue.c ****             {
 320:./FreeRTOS/queue.c ****                 /* If there are tasks blocked waiting to read from the queue, then
 321:./FreeRTOS/queue.c ****                  * the tasks will remain blocked as after this function exits the queue
 322:./FreeRTOS/queue.c ****                  * will still be empty.  If there are tasks blocked waiting to write to
 323:./FreeRTOS/queue.c ****                  * the queue, then one should be unblocked as after this function exits
 324:./FreeRTOS/queue.c ****                  * it will be possible to write to it. */
 325:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 326:./FreeRTOS/queue.c ****                 {
 327:./FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 328:./FreeRTOS/queue.c ****                     {
 329:./FreeRTOS/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
 330:./FreeRTOS/queue.c ****                     }
 331:./FreeRTOS/queue.c ****                     else
 332:./FreeRTOS/queue.c ****                     {
 333:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
 334:./FreeRTOS/queue.c ****                     }
 335:./FreeRTOS/queue.c ****                 }
 336:./FreeRTOS/queue.c ****                 else
 337:./FreeRTOS/queue.c ****                 {
 338:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 339:./FreeRTOS/queue.c ****                 }
 340:./FreeRTOS/queue.c ****             }
 341:./FreeRTOS/queue.c ****             else
 342:./FreeRTOS/queue.c ****             {
 343:./FreeRTOS/queue.c ****                 /* Ensure the event queues start in the correct state. */
 344:./FreeRTOS/queue.c ****                 vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 345:./FreeRTOS/queue.c ****                 vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 346:./FreeRTOS/queue.c ****             }
 347:./FreeRTOS/queue.c ****         }
 348:./FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
 349:./FreeRTOS/queue.c ****     }
 350:./FreeRTOS/queue.c ****     else
 351:./FreeRTOS/queue.c ****     {
 352:./FreeRTOS/queue.c ****         xReturn = pdFAIL;
 353:./FreeRTOS/queue.c ****     }
 354:./FreeRTOS/queue.c **** 
 355:./FreeRTOS/queue.c ****     configASSERT( xReturn != pdFAIL );
 356:./FreeRTOS/queue.c **** 
 357:./FreeRTOS/queue.c ****     /* A value is returned for calling semantic consistency with previous
 358:./FreeRTOS/queue.c ****      * versions. */
 359:./FreeRTOS/queue.c ****     return xReturn;
 360:./FreeRTOS/queue.c **** }
 361:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 362:./FreeRTOS/queue.c **** 
 363:./FreeRTOS/queue.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 364:./FreeRTOS/queue.c **** 
 365:./FreeRTOS/queue.c ****     QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
 366:./FreeRTOS/queue.c ****                                              const UBaseType_t uxItemSize,
 367:./FreeRTOS/queue.c ****                                              uint8_t * pucQueueStorage,
 368:./FreeRTOS/queue.c ****                                              StaticQueue_t * pxStaticQueue,
 369:./FreeRTOS/queue.c ****                                              const uint8_t ucQueueType )
 370:./FreeRTOS/queue.c ****     {
 371:./FreeRTOS/queue.c ****         Queue_t * pxNewQueue = NULL;
 372:./FreeRTOS/queue.c **** 
 373:./FreeRTOS/queue.c ****         /* The StaticQueue_t structure and the queue storage area must be
 374:./FreeRTOS/queue.c ****          * supplied. */
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 8


 375:./FreeRTOS/queue.c ****         configASSERT( pxStaticQueue );
 376:./FreeRTOS/queue.c **** 
 377:./FreeRTOS/queue.c ****         if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 378:./FreeRTOS/queue.c ****             ( pxStaticQueue != NULL ) &&
 379:./FreeRTOS/queue.c **** 
 380:./FreeRTOS/queue.c ****             /* A queue storage area should be provided if the item size is not 0, and
 381:./FreeRTOS/queue.c ****              * should not be provided if the item size is 0. */
 382:./FreeRTOS/queue.c ****             ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
 383:./FreeRTOS/queue.c ****             ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
 384:./FreeRTOS/queue.c ****         {
 385:./FreeRTOS/queue.c ****             #if ( configASSERT_DEFINED == 1 )
 386:./FreeRTOS/queue.c ****             {
 387:./FreeRTOS/queue.c ****                 /* Sanity check that the size of the structure used to declare a
 388:./FreeRTOS/queue.c ****                  * variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 389:./FreeRTOS/queue.c ****                  * the real queue and semaphore structures. */
 390:./FreeRTOS/queue.c ****                 volatile size_t xSize = sizeof( StaticQueue_t );
 391:./FreeRTOS/queue.c **** 
 392:./FreeRTOS/queue.c ****                 /* This assertion cannot be branch covered in unit tests */
 393:./FreeRTOS/queue.c ****                 configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 394:./FreeRTOS/queue.c ****                 ( void ) xSize;                             /* Keeps lint quiet when configASSERT()
 395:./FreeRTOS/queue.c ****             }
 396:./FreeRTOS/queue.c ****             #endif /* configASSERT_DEFINED */
 397:./FreeRTOS/queue.c **** 
 398:./FreeRTOS/queue.c ****             /* The address of a statically allocated queue was passed in, use it.
 399:./FreeRTOS/queue.c ****              * The address of a statically allocated storage area was also passed in
 400:./FreeRTOS/queue.c ****              * but is already set. */
 401:./FreeRTOS/queue.c ****             pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the
 402:./FreeRTOS/queue.c **** 
 403:./FreeRTOS/queue.c ****             #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 404:./FreeRTOS/queue.c ****             {
 405:./FreeRTOS/queue.c ****                 /* Queues can be allocated wither statically or dynamically, so
 406:./FreeRTOS/queue.c ****                  * note this queue was allocated statically in case the queue is
 407:./FreeRTOS/queue.c ****                  * later deleted. */
 408:./FreeRTOS/queue.c ****                 pxNewQueue->ucStaticallyAllocated = pdTRUE;
 409:./FreeRTOS/queue.c ****             }
 410:./FreeRTOS/queue.c ****             #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 411:./FreeRTOS/queue.c **** 
 412:./FreeRTOS/queue.c ****             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQu
 413:./FreeRTOS/queue.c ****         }
 414:./FreeRTOS/queue.c ****         else
 415:./FreeRTOS/queue.c ****         {
 416:./FreeRTOS/queue.c ****             configASSERT( pxNewQueue );
 417:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 418:./FreeRTOS/queue.c ****         }
 419:./FreeRTOS/queue.c **** 
 420:./FreeRTOS/queue.c ****         return pxNewQueue;
 421:./FreeRTOS/queue.c ****     }
 422:./FreeRTOS/queue.c **** 
 423:./FreeRTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 424:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 425:./FreeRTOS/queue.c **** 
 426:./FreeRTOS/queue.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 427:./FreeRTOS/queue.c **** 
 428:./FreeRTOS/queue.c ****     QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
 429:./FreeRTOS/queue.c ****                                        const UBaseType_t uxItemSize,
 430:./FreeRTOS/queue.c ****                                        const uint8_t ucQueueType )
 431:./FreeRTOS/queue.c ****     {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 9


 432:./FreeRTOS/queue.c ****         Queue_t * pxNewQueue = NULL;
 433:./FreeRTOS/queue.c ****         size_t xQueueSizeInBytes;
 434:./FreeRTOS/queue.c ****         uint8_t * pucQueueStorage;
 435:./FreeRTOS/queue.c **** 
 436:./FreeRTOS/queue.c ****         if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 437:./FreeRTOS/queue.c ****             /* Check for multiplication overflow. */
 438:./FreeRTOS/queue.c ****             ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 439:./FreeRTOS/queue.c ****             /* Check for addition overflow. */
 440:./FreeRTOS/queue.c ****             ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 441:./FreeRTOS/queue.c ****         {
 442:./FreeRTOS/queue.c ****             /* Allocate enough space to hold the maximum number of items that
 443:./FreeRTOS/queue.c ****              * can be in the queue at any time.  It is valid for uxItemSize to be
 444:./FreeRTOS/queue.c ****              * zero in the case the queue is used as a semaphore. */
 445:./FreeRTOS/queue.c ****             xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA excep
 446:./FreeRTOS/queue.c **** 
 447:./FreeRTOS/queue.c ****             /* Allocate the queue and storage area.  Justification for MISRA
 448:./FreeRTOS/queue.c ****              * deviation as follows:  pvPortMalloc() always ensures returned memory
 449:./FreeRTOS/queue.c ****              * blocks are aligned per the requirements of the MCU stack.  In this case
 450:./FreeRTOS/queue.c ****              * pvPortMalloc() must return a pointer that is guaranteed to meet the
 451:./FreeRTOS/queue.c ****              * alignment requirements of the Queue_t structure - which in this case
 452:./FreeRTOS/queue.c ****              * is an int8_t *.  Therefore, whenever the stack alignment requirements
 453:./FreeRTOS/queue.c ****              * are greater than or equal to the pointer to char requirements the cast
 454:./FreeRTOS/queue.c ****              * is safe.  In other cases alignment requirements are not strict (one or
 455:./FreeRTOS/queue.c ****              * two bytes). */
 456:./FreeRTOS/queue.c ****             pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lin
 457:./FreeRTOS/queue.c **** 
 458:./FreeRTOS/queue.c ****             if( pxNewQueue != NULL )
 459:./FreeRTOS/queue.c ****             {
 460:./FreeRTOS/queue.c ****                 /* Jump past the queue structure to find the location of the queue
 461:./FreeRTOS/queue.c ****                  * storage area. */
 462:./FreeRTOS/queue.c ****                 pucQueueStorage = ( uint8_t * ) pxNewQueue;
 463:./FreeRTOS/queue.c ****                 pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on c
 464:./FreeRTOS/queue.c **** 
 465:./FreeRTOS/queue.c ****                 #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 466:./FreeRTOS/queue.c ****                 {
 467:./FreeRTOS/queue.c ****                     /* Queues can be created either statically or dynamically, so
 468:./FreeRTOS/queue.c ****                      * note this task was created dynamically in case it is later
 469:./FreeRTOS/queue.c ****                      * deleted. */
 470:./FreeRTOS/queue.c ****                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
 471:./FreeRTOS/queue.c ****                 }
 472:./FreeRTOS/queue.c ****                 #endif /* configSUPPORT_STATIC_ALLOCATION */
 473:./FreeRTOS/queue.c **** 
 474:./FreeRTOS/queue.c ****                 prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxN
 475:./FreeRTOS/queue.c ****             }
 476:./FreeRTOS/queue.c ****             else
 477:./FreeRTOS/queue.c ****             {
 478:./FreeRTOS/queue.c ****                 traceQUEUE_CREATE_FAILED( ucQueueType );
 479:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 480:./FreeRTOS/queue.c ****             }
 481:./FreeRTOS/queue.c ****         }
 482:./FreeRTOS/queue.c ****         else
 483:./FreeRTOS/queue.c ****         {
 484:./FreeRTOS/queue.c ****             configASSERT( pxNewQueue );
 485:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 486:./FreeRTOS/queue.c ****         }
 487:./FreeRTOS/queue.c **** 
 488:./FreeRTOS/queue.c ****         return pxNewQueue;
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 10


 489:./FreeRTOS/queue.c ****     }
 490:./FreeRTOS/queue.c **** 
 491:./FreeRTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 492:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 493:./FreeRTOS/queue.c **** 
 494:./FreeRTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 495:./FreeRTOS/queue.c ****                                    const UBaseType_t uxItemSize,
 496:./FreeRTOS/queue.c ****                                    uint8_t * pucQueueStorage,
 497:./FreeRTOS/queue.c ****                                    const uint8_t ucQueueType,
 498:./FreeRTOS/queue.c ****                                    Queue_t * pxNewQueue )
 499:./FreeRTOS/queue.c **** {
 500:./FreeRTOS/queue.c ****     /* Remove compiler warnings about unused parameters should
 501:./FreeRTOS/queue.c ****      * configUSE_TRACE_FACILITY not be set to 1. */
 502:./FreeRTOS/queue.c ****     ( void ) ucQueueType;
 503:./FreeRTOS/queue.c **** 
 504:./FreeRTOS/queue.c ****     if( uxItemSize == ( UBaseType_t ) 0 )
 505:./FreeRTOS/queue.c ****     {
 506:./FreeRTOS/queue.c ****         /* No RAM was allocated for the queue storage area, but PC head cannot
 507:./FreeRTOS/queue.c ****          * be set to NULL because NULL is used as a key to say the queue is used as
 508:./FreeRTOS/queue.c ****          * a mutex.  Therefore just set pcHead to point to the queue as a benign
 509:./FreeRTOS/queue.c ****          * value that is known to be within the memory map. */
 510:./FreeRTOS/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 511:./FreeRTOS/queue.c ****     }
 512:./FreeRTOS/queue.c ****     else
 513:./FreeRTOS/queue.c ****     {
 514:./FreeRTOS/queue.c ****         /* Set the head to the start of the queue storage area. */
 515:./FreeRTOS/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 516:./FreeRTOS/queue.c ****     }
 517:./FreeRTOS/queue.c **** 
 518:./FreeRTOS/queue.c ****     /* Initialise the queue members as described where the queue type is
 519:./FreeRTOS/queue.c ****      * defined. */
 520:./FreeRTOS/queue.c ****     pxNewQueue->uxLength = uxQueueLength;
 521:./FreeRTOS/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 522:./FreeRTOS/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 523:./FreeRTOS/queue.c **** 
 524:./FreeRTOS/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 525:./FreeRTOS/queue.c ****     {
 526:./FreeRTOS/queue.c ****         pxNewQueue->ucQueueType = ucQueueType;
 527:./FreeRTOS/queue.c ****     }
 528:./FreeRTOS/queue.c ****     #endif /* configUSE_TRACE_FACILITY */
 529:./FreeRTOS/queue.c **** 
 530:./FreeRTOS/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 531:./FreeRTOS/queue.c ****     {
 532:./FreeRTOS/queue.c ****         pxNewQueue->pxQueueSetContainer = NULL;
 533:./FreeRTOS/queue.c ****     }
 534:./FreeRTOS/queue.c ****     #endif /* configUSE_QUEUE_SETS */
 535:./FreeRTOS/queue.c **** 
 536:./FreeRTOS/queue.c ****     traceQUEUE_CREATE( pxNewQueue );
 537:./FreeRTOS/queue.c **** }
 538:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 539:./FreeRTOS/queue.c **** 
 540:./FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 541:./FreeRTOS/queue.c **** 
 542:./FreeRTOS/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue )
 543:./FreeRTOS/queue.c ****     {
 544:./FreeRTOS/queue.c ****         if( pxNewQueue != NULL )
 545:./FreeRTOS/queue.c ****         {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 11


 546:./FreeRTOS/queue.c ****             /* The queue create function will set all the queue structure members
 547:./FreeRTOS/queue.c ****             * correctly for a generic queue, but this function is creating a
 548:./FreeRTOS/queue.c ****             * mutex.  Overwrite those members that need to be set differently -
 549:./FreeRTOS/queue.c ****             * in particular the information required for priority inheritance. */
 550:./FreeRTOS/queue.c ****             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 551:./FreeRTOS/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 552:./FreeRTOS/queue.c **** 
 553:./FreeRTOS/queue.c ****             /* In case this is a recursive mutex. */
 554:./FreeRTOS/queue.c ****             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 555:./FreeRTOS/queue.c **** 
 556:./FreeRTOS/queue.c ****             traceCREATE_MUTEX( pxNewQueue );
 557:./FreeRTOS/queue.c **** 
 558:./FreeRTOS/queue.c ****             /* Start with the semaphore in the expected state. */
 559:./FreeRTOS/queue.c ****             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 560:./FreeRTOS/queue.c ****         }
 561:./FreeRTOS/queue.c ****         else
 562:./FreeRTOS/queue.c ****         {
 563:./FreeRTOS/queue.c ****             traceCREATE_MUTEX_FAILED();
 564:./FreeRTOS/queue.c ****         }
 565:./FreeRTOS/queue.c ****     }
 566:./FreeRTOS/queue.c **** 
 567:./FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 568:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 569:./FreeRTOS/queue.c **** 
 570:./FreeRTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 571:./FreeRTOS/queue.c **** 
 572:./FreeRTOS/queue.c ****     QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 573:./FreeRTOS/queue.c ****     {
 574:./FreeRTOS/queue.c ****         QueueHandle_t xNewQueue;
 575:./FreeRTOS/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 576:./FreeRTOS/queue.c **** 
 577:./FreeRTOS/queue.c ****         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 578:./FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 579:./FreeRTOS/queue.c **** 
 580:./FreeRTOS/queue.c ****         return xNewQueue;
 581:./FreeRTOS/queue.c ****     }
 582:./FreeRTOS/queue.c **** 
 583:./FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 584:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 585:./FreeRTOS/queue.c **** 
 586:./FreeRTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 587:./FreeRTOS/queue.c **** 
 588:./FreeRTOS/queue.c ****     QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
 589:./FreeRTOS/queue.c ****                                            StaticQueue_t * pxStaticQueue )
 590:./FreeRTOS/queue.c ****     {
 591:./FreeRTOS/queue.c ****         QueueHandle_t xNewQueue;
 592:./FreeRTOS/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 593:./FreeRTOS/queue.c **** 
 594:./FreeRTOS/queue.c ****         /* Prevent compiler warnings about unused parameters if
 595:./FreeRTOS/queue.c ****          * configUSE_TRACE_FACILITY does not equal 1. */
 596:./FreeRTOS/queue.c ****         ( void ) ucQueueType;
 597:./FreeRTOS/queue.c **** 
 598:./FreeRTOS/queue.c ****         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQ
 599:./FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 600:./FreeRTOS/queue.c **** 
 601:./FreeRTOS/queue.c ****         return xNewQueue;
 602:./FreeRTOS/queue.c ****     }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 12


 603:./FreeRTOS/queue.c **** 
 604:./FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 605:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 606:./FreeRTOS/queue.c **** 
 607:./FreeRTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 608:./FreeRTOS/queue.c **** 
 609:./FreeRTOS/queue.c ****     TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 610:./FreeRTOS/queue.c ****     {
 611:./FreeRTOS/queue.c ****         TaskHandle_t pxReturn;
 612:./FreeRTOS/queue.c ****         Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 613:./FreeRTOS/queue.c **** 
 614:./FreeRTOS/queue.c ****         configASSERT( xSemaphore );
 615:./FreeRTOS/queue.c **** 
 616:./FreeRTOS/queue.c ****         /* This function is called by xSemaphoreGetMutexHolder(), and should not
 617:./FreeRTOS/queue.c ****          * be called directly.  Note:  This is a good way of determining if the
 618:./FreeRTOS/queue.c ****          * calling task is the mutex holder, but not a good way of determining the
 619:./FreeRTOS/queue.c ****          * identity of the mutex holder, as the holder may change between the
 620:./FreeRTOS/queue.c ****          * following critical section exiting and the function returning. */
 621:./FreeRTOS/queue.c ****         taskENTER_CRITICAL();
 622:./FreeRTOS/queue.c ****         {
 623:./FreeRTOS/queue.c ****             if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 624:./FreeRTOS/queue.c ****             {
 625:./FreeRTOS/queue.c ****                 pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 626:./FreeRTOS/queue.c ****             }
 627:./FreeRTOS/queue.c ****             else
 628:./FreeRTOS/queue.c ****             {
 629:./FreeRTOS/queue.c ****                 pxReturn = NULL;
 630:./FreeRTOS/queue.c ****             }
 631:./FreeRTOS/queue.c ****         }
 632:./FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
 633:./FreeRTOS/queue.c **** 
 634:./FreeRTOS/queue.c ****         return pxReturn;
 635:./FreeRTOS/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 636:./FreeRTOS/queue.c **** 
 637:./FreeRTOS/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 638:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 639:./FreeRTOS/queue.c **** 
 640:./FreeRTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 641:./FreeRTOS/queue.c **** 
 642:./FreeRTOS/queue.c ****     TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 643:./FreeRTOS/queue.c ****     {
 644:./FreeRTOS/queue.c ****         TaskHandle_t pxReturn;
 645:./FreeRTOS/queue.c **** 
 646:./FreeRTOS/queue.c ****         configASSERT( xSemaphore );
 647:./FreeRTOS/queue.c **** 
 648:./FreeRTOS/queue.c ****         /* Mutexes cannot be used in interrupt service routines, so the mutex
 649:./FreeRTOS/queue.c ****          * holder should not change in an ISR, and therefore a critical section is
 650:./FreeRTOS/queue.c ****          * not required here. */
 651:./FreeRTOS/queue.c ****         if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 652:./FreeRTOS/queue.c ****         {
 653:./FreeRTOS/queue.c ****             pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 654:./FreeRTOS/queue.c ****         }
 655:./FreeRTOS/queue.c ****         else
 656:./FreeRTOS/queue.c ****         {
 657:./FreeRTOS/queue.c ****             pxReturn = NULL;
 658:./FreeRTOS/queue.c ****         }
 659:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 13


 660:./FreeRTOS/queue.c ****         return pxReturn;
 661:./FreeRTOS/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 662:./FreeRTOS/queue.c **** 
 663:./FreeRTOS/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 664:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 665:./FreeRTOS/queue.c **** 
 666:./FreeRTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 667:./FreeRTOS/queue.c **** 
 668:./FreeRTOS/queue.c ****     BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 669:./FreeRTOS/queue.c ****     {
 670:./FreeRTOS/queue.c ****         BaseType_t xReturn;
 671:./FreeRTOS/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 672:./FreeRTOS/queue.c **** 
 673:./FreeRTOS/queue.c ****         configASSERT( pxMutex );
 674:./FreeRTOS/queue.c **** 
 675:./FreeRTOS/queue.c ****         /* If this is the task that holds the mutex then xMutexHolder will not
 676:./FreeRTOS/queue.c ****          * change outside of this task.  If this task does not hold the mutex then
 677:./FreeRTOS/queue.c ****          * pxMutexHolder can never coincidentally equal the tasks handle, and as
 678:./FreeRTOS/queue.c ****          * this is the only condition we are interested in it does not matter if
 679:./FreeRTOS/queue.c ****          * pxMutexHolder is accessed simultaneously by another task.  Therefore no
 680:./FreeRTOS/queue.c ****          * mutual exclusion is required to test the pxMutexHolder variable. */
 681:./FreeRTOS/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 682:./FreeRTOS/queue.c ****         {
 683:./FreeRTOS/queue.c ****             traceGIVE_MUTEX_RECURSIVE( pxMutex );
 684:./FreeRTOS/queue.c **** 
 685:./FreeRTOS/queue.c ****             /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 686:./FreeRTOS/queue.c ****              * the task handle, therefore no underflow check is required.  Also,
 687:./FreeRTOS/queue.c ****              * uxRecursiveCallCount is only modified by the mutex holder, and as
 688:./FreeRTOS/queue.c ****              * there can only be one, no mutual exclusion is required to modify the
 689:./FreeRTOS/queue.c ****              * uxRecursiveCallCount member. */
 690:./FreeRTOS/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 691:./FreeRTOS/queue.c **** 
 692:./FreeRTOS/queue.c ****             /* Has the recursive call count unwound to 0? */
 693:./FreeRTOS/queue.c ****             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 694:./FreeRTOS/queue.c ****             {
 695:./FreeRTOS/queue.c ****                 /* Return the mutex.  This will automatically unblock any other
 696:./FreeRTOS/queue.c ****                  * task that might be waiting to access the mutex. */
 697:./FreeRTOS/queue.c ****                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO
 698:./FreeRTOS/queue.c ****             }
 699:./FreeRTOS/queue.c ****             else
 700:./FreeRTOS/queue.c ****             {
 701:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 702:./FreeRTOS/queue.c ****             }
 703:./FreeRTOS/queue.c **** 
 704:./FreeRTOS/queue.c ****             xReturn = pdPASS;
 705:./FreeRTOS/queue.c ****         }
 706:./FreeRTOS/queue.c ****         else
 707:./FreeRTOS/queue.c ****         {
 708:./FreeRTOS/queue.c ****             /* The mutex cannot be given because the calling task is not the
 709:./FreeRTOS/queue.c ****              * holder. */
 710:./FreeRTOS/queue.c ****             xReturn = pdFAIL;
 711:./FreeRTOS/queue.c **** 
 712:./FreeRTOS/queue.c ****             traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 713:./FreeRTOS/queue.c ****         }
 714:./FreeRTOS/queue.c **** 
 715:./FreeRTOS/queue.c ****         return xReturn;
 716:./FreeRTOS/queue.c ****     }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 14


 717:./FreeRTOS/queue.c **** 
 718:./FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 719:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 720:./FreeRTOS/queue.c **** 
 721:./FreeRTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 722:./FreeRTOS/queue.c **** 
 723:./FreeRTOS/queue.c ****     BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
 724:./FreeRTOS/queue.c ****                                          TickType_t xTicksToWait )
 725:./FreeRTOS/queue.c ****     {
 726:./FreeRTOS/queue.c ****         BaseType_t xReturn;
 727:./FreeRTOS/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 728:./FreeRTOS/queue.c **** 
 729:./FreeRTOS/queue.c ****         configASSERT( pxMutex );
 730:./FreeRTOS/queue.c **** 
 731:./FreeRTOS/queue.c ****         /* Comments regarding mutual exclusion as per those within
 732:./FreeRTOS/queue.c ****          * xQueueGiveMutexRecursive(). */
 733:./FreeRTOS/queue.c **** 
 734:./FreeRTOS/queue.c ****         traceTAKE_MUTEX_RECURSIVE( pxMutex );
 735:./FreeRTOS/queue.c **** 
 736:./FreeRTOS/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 737:./FreeRTOS/queue.c ****         {
 738:./FreeRTOS/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 739:./FreeRTOS/queue.c ****             xReturn = pdPASS;
 740:./FreeRTOS/queue.c ****         }
 741:./FreeRTOS/queue.c ****         else
 742:./FreeRTOS/queue.c ****         {
 743:./FreeRTOS/queue.c ****             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 744:./FreeRTOS/queue.c **** 
 745:./FreeRTOS/queue.c ****             /* pdPASS will only be returned if the mutex was successfully
 746:./FreeRTOS/queue.c ****              * obtained.  The calling task may have entered the Blocked state
 747:./FreeRTOS/queue.c ****              * before reaching here. */
 748:./FreeRTOS/queue.c ****             if( xReturn != pdFAIL )
 749:./FreeRTOS/queue.c ****             {
 750:./FreeRTOS/queue.c ****                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 751:./FreeRTOS/queue.c ****             }
 752:./FreeRTOS/queue.c ****             else
 753:./FreeRTOS/queue.c ****             {
 754:./FreeRTOS/queue.c ****                 traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 755:./FreeRTOS/queue.c ****             }
 756:./FreeRTOS/queue.c ****         }
 757:./FreeRTOS/queue.c **** 
 758:./FreeRTOS/queue.c ****         return xReturn;
 759:./FreeRTOS/queue.c ****     }
 760:./FreeRTOS/queue.c **** 
 761:./FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 762:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 763:./FreeRTOS/queue.c **** 
 764:./FreeRTOS/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 765:./FreeRTOS/queue.c **** 
 766:./FreeRTOS/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
 767:./FreeRTOS/queue.c ****                                                        const UBaseType_t uxInitialCount,
 768:./FreeRTOS/queue.c ****                                                        StaticQueue_t * pxStaticQueue )
 769:./FreeRTOS/queue.c ****     {
 770:./FreeRTOS/queue.c ****         QueueHandle_t xHandle = NULL;
 771:./FreeRTOS/queue.c **** 
 772:./FreeRTOS/queue.c ****         if( ( uxMaxCount != 0 ) &&
 773:./FreeRTOS/queue.c ****             ( uxInitialCount <= uxMaxCount ) )
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 15


 774:./FreeRTOS/queue.c ****         {
 775:./FreeRTOS/queue.c ****             xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL
 776:./FreeRTOS/queue.c **** 
 777:./FreeRTOS/queue.c ****             if( xHandle != NULL )
 778:./FreeRTOS/queue.c ****             {
 779:./FreeRTOS/queue.c ****                 ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 780:./FreeRTOS/queue.c **** 
 781:./FreeRTOS/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE();
 782:./FreeRTOS/queue.c ****             }
 783:./FreeRTOS/queue.c ****             else
 784:./FreeRTOS/queue.c ****             {
 785:./FreeRTOS/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE_FAILED();
 786:./FreeRTOS/queue.c ****             }
 787:./FreeRTOS/queue.c ****         }
 788:./FreeRTOS/queue.c ****         else
 789:./FreeRTOS/queue.c ****         {
 790:./FreeRTOS/queue.c ****             configASSERT( xHandle );
 791:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 792:./FreeRTOS/queue.c ****         }
 793:./FreeRTOS/queue.c **** 
 794:./FreeRTOS/queue.c ****         return xHandle;
 795:./FreeRTOS/queue.c ****     }
 796:./FreeRTOS/queue.c **** 
 797:./FreeRTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 798:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 799:./FreeRTOS/queue.c **** 
 800:./FreeRTOS/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 801:./FreeRTOS/queue.c **** 
 802:./FreeRTOS/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
 803:./FreeRTOS/queue.c ****                                                  const UBaseType_t uxInitialCount )
 804:./FreeRTOS/queue.c ****     {
 805:./FreeRTOS/queue.c ****         QueueHandle_t xHandle = NULL;
 806:./FreeRTOS/queue.c **** 
 807:./FreeRTOS/queue.c ****         if( ( uxMaxCount != 0 ) &&
 808:./FreeRTOS/queue.c ****             ( uxInitialCount <= uxMaxCount ) )
 809:./FreeRTOS/queue.c ****         {
 810:./FreeRTOS/queue.c ****             xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE
 811:./FreeRTOS/queue.c **** 
 812:./FreeRTOS/queue.c ****             if( xHandle != NULL )
 813:./FreeRTOS/queue.c ****             {
 814:./FreeRTOS/queue.c ****                 ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 815:./FreeRTOS/queue.c **** 
 816:./FreeRTOS/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE();
 817:./FreeRTOS/queue.c ****             }
 818:./FreeRTOS/queue.c ****             else
 819:./FreeRTOS/queue.c ****             {
 820:./FreeRTOS/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE_FAILED();
 821:./FreeRTOS/queue.c ****             }
 822:./FreeRTOS/queue.c ****         }
 823:./FreeRTOS/queue.c ****         else
 824:./FreeRTOS/queue.c ****         {
 825:./FreeRTOS/queue.c ****             configASSERT( xHandle );
 826:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 827:./FreeRTOS/queue.c ****         }
 828:./FreeRTOS/queue.c **** 
 829:./FreeRTOS/queue.c ****         return xHandle;
 830:./FreeRTOS/queue.c ****     }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 16


 831:./FreeRTOS/queue.c **** 
 832:./FreeRTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 833:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 834:./FreeRTOS/queue.c **** 
 835:./FreeRTOS/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
 836:./FreeRTOS/queue.c ****                               const void * const pvItemToQueue,
 837:./FreeRTOS/queue.c ****                               TickType_t xTicksToWait,
 838:./FreeRTOS/queue.c ****                               const BaseType_t xCopyPosition )
 839:./FreeRTOS/queue.c **** {
 840:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 841:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 842:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 843:./FreeRTOS/queue.c **** 
 844:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
 845:./FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 846:./FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 847:./FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 848:./FreeRTOS/queue.c ****     {
 849:./FreeRTOS/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
 850:./FreeRTOS/queue.c ****     }
 851:./FreeRTOS/queue.c ****     #endif
 852:./FreeRTOS/queue.c **** 
 853:./FreeRTOS/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to
 854:./FreeRTOS/queue.c ****      * allow return statements within the function itself.  This is done in the
 855:./FreeRTOS/queue.c ****      * interest of execution time efficiency. */
 856:./FreeRTOS/queue.c ****     for( ; ; )
 857:./FreeRTOS/queue.c ****     {
 858:./FreeRTOS/queue.c ****         taskENTER_CRITICAL();
 859:./FreeRTOS/queue.c ****         {
 860:./FreeRTOS/queue.c ****             /* Is there room on the queue now?  The running task must be the
 861:./FreeRTOS/queue.c ****              * highest priority task wanting to access the queue.  If the head item
 862:./FreeRTOS/queue.c ****              * in the queue is to be overwritten then it does not matter if the
 863:./FreeRTOS/queue.c ****              * queue is full. */
 864:./FreeRTOS/queue.c ****             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERW
 865:./FreeRTOS/queue.c ****             {
 866:./FreeRTOS/queue.c ****                 traceQUEUE_SEND( pxQueue );
 867:./FreeRTOS/queue.c **** 
 868:./FreeRTOS/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
 869:./FreeRTOS/queue.c ****                 {
 870:./FreeRTOS/queue.c ****                     const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 871:./FreeRTOS/queue.c **** 
 872:./FreeRTOS/queue.c ****                     xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 873:./FreeRTOS/queue.c **** 
 874:./FreeRTOS/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
 875:./FreeRTOS/queue.c ****                     {
 876:./FreeRTOS/queue.c ****                         if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != (
 877:./FreeRTOS/queue.c ****                         {
 878:./FreeRTOS/queue.c ****                             /* Do not notify the queue set as an existing item
 879:./FreeRTOS/queue.c ****                              * was overwritten in the queue so the number of items
 880:./FreeRTOS/queue.c ****                              * in the queue has not changed. */
 881:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 882:./FreeRTOS/queue.c ****                         }
 883:./FreeRTOS/queue.c ****                         else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 884:./FreeRTOS/queue.c ****                         {
 885:./FreeRTOS/queue.c ****                             /* The queue is a member of a queue set, and posting
 886:./FreeRTOS/queue.c ****                              * to the queue set caused a higher priority task to
 887:./FreeRTOS/queue.c ****                              * unblock. A context switch is required. */
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 17


 888:./FreeRTOS/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 889:./FreeRTOS/queue.c ****                         }
 890:./FreeRTOS/queue.c ****                         else
 891:./FreeRTOS/queue.c ****                         {
 892:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 893:./FreeRTOS/queue.c ****                         }
 894:./FreeRTOS/queue.c ****                     }
 895:./FreeRTOS/queue.c ****                     else
 896:./FreeRTOS/queue.c ****                     {
 897:./FreeRTOS/queue.c ****                         /* If there was a task waiting for data to arrive on the
 898:./FreeRTOS/queue.c ****                          * queue then unblock it now. */
 899:./FreeRTOS/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 900:./FreeRTOS/queue.c ****                         {
 901:./FreeRTOS/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
 902:./FreeRTOS/queue.c ****                             {
 903:./FreeRTOS/queue.c ****                                 /* The unblocked task has a priority higher than
 904:./FreeRTOS/queue.c ****                                  * our own so yield immediately.  Yes it is ok to
 905:./FreeRTOS/queue.c ****                                  * do this from within the critical section - the
 906:./FreeRTOS/queue.c ****                                  * kernel takes care of that. */
 907:./FreeRTOS/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 908:./FreeRTOS/queue.c ****                             }
 909:./FreeRTOS/queue.c ****                             else
 910:./FreeRTOS/queue.c ****                             {
 911:./FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 912:./FreeRTOS/queue.c ****                             }
 913:./FreeRTOS/queue.c ****                         }
 914:./FreeRTOS/queue.c ****                         else if( xYieldRequired != pdFALSE )
 915:./FreeRTOS/queue.c ****                         {
 916:./FreeRTOS/queue.c ****                             /* This path is a special case that will only get
 917:./FreeRTOS/queue.c ****                              * executed if the task was holding multiple mutexes
 918:./FreeRTOS/queue.c ****                              * and the mutexes were given back in an order that is
 919:./FreeRTOS/queue.c ****                              * different to that in which they were taken. */
 920:./FreeRTOS/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 921:./FreeRTOS/queue.c ****                         }
 922:./FreeRTOS/queue.c ****                         else
 923:./FreeRTOS/queue.c ****                         {
 924:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 925:./FreeRTOS/queue.c ****                         }
 926:./FreeRTOS/queue.c ****                     }
 927:./FreeRTOS/queue.c ****                 }
 928:./FreeRTOS/queue.c ****                 #else /* configUSE_QUEUE_SETS */
 929:./FreeRTOS/queue.c ****                 {
 930:./FreeRTOS/queue.c ****                     xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 931:./FreeRTOS/queue.c **** 
 932:./FreeRTOS/queue.c ****                     /* If there was a task waiting for data to arrive on the
 933:./FreeRTOS/queue.c ****                      * queue then unblock it now. */
 934:./FreeRTOS/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 935:./FreeRTOS/queue.c ****                     {
 936:./FreeRTOS/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
 937:./FreeRTOS/queue.c ****                         {
 938:./FreeRTOS/queue.c ****                             /* The unblocked task has a priority higher than
 939:./FreeRTOS/queue.c ****                              * our own so yield immediately.  Yes it is ok to do
 940:./FreeRTOS/queue.c ****                              * this from within the critical section - the kernel
 941:./FreeRTOS/queue.c ****                              * takes care of that. */
 942:./FreeRTOS/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 943:./FreeRTOS/queue.c ****                         }
 944:./FreeRTOS/queue.c ****                         else
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 18


 945:./FreeRTOS/queue.c ****                         {
 946:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 947:./FreeRTOS/queue.c ****                         }
 948:./FreeRTOS/queue.c ****                     }
 949:./FreeRTOS/queue.c ****                     else if( xYieldRequired != pdFALSE )
 950:./FreeRTOS/queue.c ****                     {
 951:./FreeRTOS/queue.c ****                         /* This path is a special case that will only get
 952:./FreeRTOS/queue.c ****                          * executed if the task was holding multiple mutexes and
 953:./FreeRTOS/queue.c ****                          * the mutexes were given back in an order that is
 954:./FreeRTOS/queue.c ****                          * different to that in which they were taken. */
 955:./FreeRTOS/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
 956:./FreeRTOS/queue.c ****                     }
 957:./FreeRTOS/queue.c ****                     else
 958:./FreeRTOS/queue.c ****                     {
 959:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
 960:./FreeRTOS/queue.c ****                     }
 961:./FreeRTOS/queue.c ****                 }
 962:./FreeRTOS/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
 963:./FreeRTOS/queue.c **** 
 964:./FreeRTOS/queue.c ****                 taskEXIT_CRITICAL();
 965:./FreeRTOS/queue.c ****                 return pdPASS;
 966:./FreeRTOS/queue.c ****             }
 967:./FreeRTOS/queue.c ****             else
 968:./FreeRTOS/queue.c ****             {
 969:./FreeRTOS/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 970:./FreeRTOS/queue.c ****                 {
 971:./FreeRTOS/queue.c ****                     /* The queue was full and no block time is specified (or
 972:./FreeRTOS/queue.c ****                      * the block time has expired) so leave now. */
 973:./FreeRTOS/queue.c ****                     taskEXIT_CRITICAL();
 974:./FreeRTOS/queue.c **** 
 975:./FreeRTOS/queue.c ****                     /* Return to the original privilege level before exiting
 976:./FreeRTOS/queue.c ****                      * the function. */
 977:./FreeRTOS/queue.c ****                     traceQUEUE_SEND_FAILED( pxQueue );
 978:./FreeRTOS/queue.c ****                     return errQUEUE_FULL;
 979:./FreeRTOS/queue.c ****                 }
 980:./FreeRTOS/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 981:./FreeRTOS/queue.c ****                 {
 982:./FreeRTOS/queue.c ****                     /* The queue was full and a block time was specified so
 983:./FreeRTOS/queue.c ****                      * configure the timeout structure. */
 984:./FreeRTOS/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 985:./FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 986:./FreeRTOS/queue.c ****                 }
 987:./FreeRTOS/queue.c ****                 else
 988:./FreeRTOS/queue.c ****                 {
 989:./FreeRTOS/queue.c ****                     /* Entry time was already set. */
 990:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 991:./FreeRTOS/queue.c ****                 }
 992:./FreeRTOS/queue.c ****             }
 993:./FreeRTOS/queue.c ****         }
 994:./FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
 995:./FreeRTOS/queue.c **** 
 996:./FreeRTOS/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
 997:./FreeRTOS/queue.c ****          * now the critical section has been exited. */
 998:./FreeRTOS/queue.c **** 
 999:./FreeRTOS/queue.c ****         vTaskSuspendAll();
1000:./FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
1001:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 19


1002:./FreeRTOS/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1003:./FreeRTOS/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1004:./FreeRTOS/queue.c ****         {
1005:./FreeRTOS/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
1006:./FreeRTOS/queue.c ****             {
1007:./FreeRTOS/queue.c ****                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );
1008:./FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
1009:./FreeRTOS/queue.c **** 
1010:./FreeRTOS/queue.c ****                 /* Unlocking the queue means queue events can effect the
1011:./FreeRTOS/queue.c ****                  * event list. It is possible that interrupts occurring now
1012:./FreeRTOS/queue.c ****                  * remove this task from the event list again - but as the
1013:./FreeRTOS/queue.c ****                  * scheduler is suspended the task will go onto the pending
1014:./FreeRTOS/queue.c ****                  * ready list instead of the actual ready list. */
1015:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1016:./FreeRTOS/queue.c **** 
1017:./FreeRTOS/queue.c ****                 /* Resuming the scheduler will move tasks from the pending
1018:./FreeRTOS/queue.c ****                  * ready list into the ready list - so it is feasible that this
1019:./FreeRTOS/queue.c ****                  * task is already in the ready list before it yields - in which
1020:./FreeRTOS/queue.c ****                  * case the yield will not cause a context switch unless there
1021:./FreeRTOS/queue.c ****                  * is also a higher priority task in the pending ready list. */
1022:./FreeRTOS/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1023:./FreeRTOS/queue.c ****                 {
1024:./FreeRTOS/queue.c ****                     portYIELD_WITHIN_API();
1025:./FreeRTOS/queue.c ****                 }
1026:./FreeRTOS/queue.c ****             }
1027:./FreeRTOS/queue.c ****             else
1028:./FreeRTOS/queue.c ****             {
1029:./FreeRTOS/queue.c ****                 /* Try again. */
1030:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1031:./FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
1032:./FreeRTOS/queue.c ****             }
1033:./FreeRTOS/queue.c ****         }
1034:./FreeRTOS/queue.c ****         else
1035:./FreeRTOS/queue.c ****         {
1036:./FreeRTOS/queue.c ****             /* The timeout has expired. */
1037:./FreeRTOS/queue.c ****             prvUnlockQueue( pxQueue );
1038:./FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
1039:./FreeRTOS/queue.c **** 
1040:./FreeRTOS/queue.c ****             traceQUEUE_SEND_FAILED( pxQueue );
1041:./FreeRTOS/queue.c ****             return errQUEUE_FULL;
1042:./FreeRTOS/queue.c ****         }
1043:./FreeRTOS/queue.c ****     } /*lint -restore */
1044:./FreeRTOS/queue.c **** }
1045:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1046:./FreeRTOS/queue.c **** 
1047:./FreeRTOS/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
1048:./FreeRTOS/queue.c ****                                      const void * const pvItemToQueue,
1049:./FreeRTOS/queue.c ****                                      BaseType_t * const pxHigherPriorityTaskWoken,
1050:./FreeRTOS/queue.c ****                                      const BaseType_t xCopyPosition )
1051:./FreeRTOS/queue.c **** {
1052:./FreeRTOS/queue.c ****     BaseType_t xReturn;
1053:./FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1054:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1055:./FreeRTOS/queue.c **** 
1056:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
1057:./FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
1058:./FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 20


1059:./FreeRTOS/queue.c **** 
1060:./FreeRTOS/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1061:./FreeRTOS/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1062:./FreeRTOS/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1063:./FreeRTOS/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1064:./FreeRTOS/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1065:./FreeRTOS/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1066:./FreeRTOS/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1067:./FreeRTOS/queue.c ****      * assigned a priority above the configured maximum system call priority.
1068:./FreeRTOS/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1069:./FreeRTOS/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1070:./FreeRTOS/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1071:./FreeRTOS/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1072:./FreeRTOS/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1073:./FreeRTOS/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1074:./FreeRTOS/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1075:./FreeRTOS/queue.c **** 
1076:./FreeRTOS/queue.c ****     /* Similar to xQueueGenericSend, except without blocking if there is no room
1077:./FreeRTOS/queue.c ****      * in the queue.  Also don't directly wake a task that was blocked on a queue
1078:./FreeRTOS/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1079:./FreeRTOS/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1080:./FreeRTOS/queue.c ****      * post). */
1081:./FreeRTOS/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1082:./FreeRTOS/queue.c ****     {
1083:./FreeRTOS/queue.c ****         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE
1084:./FreeRTOS/queue.c ****         {
1085:./FreeRTOS/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
1086:./FreeRTOS/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
1087:./FreeRTOS/queue.c **** 
1088:./FreeRTOS/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1089:./FreeRTOS/queue.c **** 
1090:./FreeRTOS/queue.c ****             /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1091:./FreeRTOS/queue.c ****              *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1092:./FreeRTOS/queue.c ****              *  in a task disinheriting a priority and prvCopyDataToQueue() can be
1093:./FreeRTOS/queue.c ****              *  called here even though the disinherit function does not check if
1094:./FreeRTOS/queue.c ****              *  the scheduler is suspended before accessing the ready lists. */
1095:./FreeRTOS/queue.c ****             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1096:./FreeRTOS/queue.c **** 
1097:./FreeRTOS/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1098:./FreeRTOS/queue.c ****              * be done when the queue is unlocked later. */
1099:./FreeRTOS/queue.c ****             if( cTxLock == queueUNLOCKED )
1100:./FreeRTOS/queue.c ****             {
1101:./FreeRTOS/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1102:./FreeRTOS/queue.c ****                 {
1103:./FreeRTOS/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
1104:./FreeRTOS/queue.c ****                     {
1105:./FreeRTOS/queue.c ****                         if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != (
1106:./FreeRTOS/queue.c ****                         {
1107:./FreeRTOS/queue.c ****                             /* Do not notify the queue set as an existing item
1108:./FreeRTOS/queue.c ****                              * was overwritten in the queue so the number of items
1109:./FreeRTOS/queue.c ****                              * in the queue has not changed. */
1110:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1111:./FreeRTOS/queue.c ****                         }
1112:./FreeRTOS/queue.c ****                         else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1113:./FreeRTOS/queue.c ****                         {
1114:./FreeRTOS/queue.c ****                             /* The queue is a member of a queue set, and posting
1115:./FreeRTOS/queue.c ****                              * to the queue set caused a higher priority task to
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 21


1116:./FreeRTOS/queue.c ****                              * unblock.  A context switch is required. */
1117:./FreeRTOS/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
1118:./FreeRTOS/queue.c ****                             {
1119:./FreeRTOS/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1120:./FreeRTOS/queue.c ****                             }
1121:./FreeRTOS/queue.c ****                             else
1122:./FreeRTOS/queue.c ****                             {
1123:./FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1124:./FreeRTOS/queue.c ****                             }
1125:./FreeRTOS/queue.c ****                         }
1126:./FreeRTOS/queue.c ****                         else
1127:./FreeRTOS/queue.c ****                         {
1128:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1129:./FreeRTOS/queue.c ****                         }
1130:./FreeRTOS/queue.c ****                     }
1131:./FreeRTOS/queue.c ****                     else
1132:./FreeRTOS/queue.c ****                     {
1133:./FreeRTOS/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1134:./FreeRTOS/queue.c ****                         {
1135:./FreeRTOS/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1136:./FreeRTOS/queue.c ****                             {
1137:./FreeRTOS/queue.c ****                                 /* The task waiting has a higher priority so
1138:./FreeRTOS/queue.c ****                                  *  record that a context switch is required. */
1139:./FreeRTOS/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1140:./FreeRTOS/queue.c ****                                 {
1141:./FreeRTOS/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1142:./FreeRTOS/queue.c ****                                 }
1143:./FreeRTOS/queue.c ****                                 else
1144:./FreeRTOS/queue.c ****                                 {
1145:./FreeRTOS/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1146:./FreeRTOS/queue.c ****                                 }
1147:./FreeRTOS/queue.c ****                             }
1148:./FreeRTOS/queue.c ****                             else
1149:./FreeRTOS/queue.c ****                             {
1150:./FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1151:./FreeRTOS/queue.c ****                             }
1152:./FreeRTOS/queue.c ****                         }
1153:./FreeRTOS/queue.c ****                         else
1154:./FreeRTOS/queue.c ****                         {
1155:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1156:./FreeRTOS/queue.c ****                         }
1157:./FreeRTOS/queue.c ****                     }
1158:./FreeRTOS/queue.c ****                 }
1159:./FreeRTOS/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1160:./FreeRTOS/queue.c ****                 {
1161:./FreeRTOS/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1162:./FreeRTOS/queue.c ****                     {
1163:./FreeRTOS/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
1164:./FreeRTOS/queue.c ****                         {
1165:./FreeRTOS/queue.c ****                             /* The task waiting has a higher priority so record that a
1166:./FreeRTOS/queue.c ****                              * context switch is required. */
1167:./FreeRTOS/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
1168:./FreeRTOS/queue.c ****                             {
1169:./FreeRTOS/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1170:./FreeRTOS/queue.c ****                             }
1171:./FreeRTOS/queue.c ****                             else
1172:./FreeRTOS/queue.c ****                             {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 22


1173:./FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1174:./FreeRTOS/queue.c ****                             }
1175:./FreeRTOS/queue.c ****                         }
1176:./FreeRTOS/queue.c ****                         else
1177:./FreeRTOS/queue.c ****                         {
1178:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1179:./FreeRTOS/queue.c ****                         }
1180:./FreeRTOS/queue.c ****                     }
1181:./FreeRTOS/queue.c ****                     else
1182:./FreeRTOS/queue.c ****                     {
1183:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1184:./FreeRTOS/queue.c ****                     }
1185:./FreeRTOS/queue.c **** 
1186:./FreeRTOS/queue.c ****                     /* Not used in this path. */
1187:./FreeRTOS/queue.c ****                     ( void ) uxPreviousMessagesWaiting;
1188:./FreeRTOS/queue.c ****                 }
1189:./FreeRTOS/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1190:./FreeRTOS/queue.c ****             }
1191:./FreeRTOS/queue.c ****             else
1192:./FreeRTOS/queue.c ****             {
1193:./FreeRTOS/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1194:./FreeRTOS/queue.c ****                  * knows that data was posted while it was locked. */
1195:./FreeRTOS/queue.c ****                 prvIncrementQueueTxLock( pxQueue, cTxLock );
1196:./FreeRTOS/queue.c ****             }
1197:./FreeRTOS/queue.c **** 
1198:./FreeRTOS/queue.c ****             xReturn = pdPASS;
1199:./FreeRTOS/queue.c ****         }
1200:./FreeRTOS/queue.c ****         else
1201:./FreeRTOS/queue.c ****         {
1202:./FreeRTOS/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1203:./FreeRTOS/queue.c ****             xReturn = errQUEUE_FULL;
1204:./FreeRTOS/queue.c ****         }
1205:./FreeRTOS/queue.c ****     }
1206:./FreeRTOS/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1207:./FreeRTOS/queue.c **** 
1208:./FreeRTOS/queue.c ****     return xReturn;
1209:./FreeRTOS/queue.c **** }
1210:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1211:./FreeRTOS/queue.c **** 
1212:./FreeRTOS/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
1213:./FreeRTOS/queue.c ****                               BaseType_t * const pxHigherPriorityTaskWoken )
1214:./FreeRTOS/queue.c **** {
1215:./FreeRTOS/queue.c ****     BaseType_t xReturn;
1216:./FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1217:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1218:./FreeRTOS/queue.c **** 
1219:./FreeRTOS/queue.c ****     /* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1220:./FreeRTOS/queue.c ****      * item size is 0.  Don't directly wake a task that was blocked on a queue
1221:./FreeRTOS/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1222:./FreeRTOS/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1223:./FreeRTOS/queue.c ****      * post). */
1224:./FreeRTOS/queue.c **** 
1225:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
1226:./FreeRTOS/queue.c **** 
1227:./FreeRTOS/queue.c ****     /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1228:./FreeRTOS/queue.c ****      * if the item size is not 0. */
1229:./FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 23


1230:./FreeRTOS/queue.c **** 
1231:./FreeRTOS/queue.c ****     /* Normally a mutex would not be given from an interrupt, especially if
1232:./FreeRTOS/queue.c ****      * there is a mutex holder, as priority inheritance makes no sense for an
1233:./FreeRTOS/queue.c ****      * interrupts, only tasks. */
1234:./FreeRTOS/queue.c ****     configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMu
1235:./FreeRTOS/queue.c **** 
1236:./FreeRTOS/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1237:./FreeRTOS/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1238:./FreeRTOS/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1239:./FreeRTOS/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1240:./FreeRTOS/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1241:./FreeRTOS/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1242:./FreeRTOS/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1243:./FreeRTOS/queue.c ****      * assigned a priority above the configured maximum system call priority.
1244:./FreeRTOS/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1245:./FreeRTOS/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1246:./FreeRTOS/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1247:./FreeRTOS/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1248:./FreeRTOS/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1249:./FreeRTOS/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1250:./FreeRTOS/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1251:./FreeRTOS/queue.c **** 
1252:./FreeRTOS/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1253:./FreeRTOS/queue.c ****     {
1254:./FreeRTOS/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1255:./FreeRTOS/queue.c **** 
1256:./FreeRTOS/queue.c ****         /* When the queue is used to implement a semaphore no data is ever
1257:./FreeRTOS/queue.c ****          * moved through the queue but it is still valid to see if the queue 'has
1258:./FreeRTOS/queue.c ****          * space'. */
1259:./FreeRTOS/queue.c ****         if( uxMessagesWaiting < pxQueue->uxLength )
1260:./FreeRTOS/queue.c ****         {
1261:./FreeRTOS/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
1262:./FreeRTOS/queue.c **** 
1263:./FreeRTOS/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1264:./FreeRTOS/queue.c **** 
1265:./FreeRTOS/queue.c ****             /* A task can only have an inherited priority if it is a mutex
1266:./FreeRTOS/queue.c ****              * holder - and if there is a mutex holder then the mutex cannot be
1267:./FreeRTOS/queue.c ****              * given from an ISR.  As this is the ISR version of the function it
1268:./FreeRTOS/queue.c ****              * can be assumed there is no mutex holder and no need to determine if
1269:./FreeRTOS/queue.c ****              * priority disinheritance is needed.  Simply increase the count of
1270:./FreeRTOS/queue.c ****              * messages (semaphores) available. */
1271:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1272:./FreeRTOS/queue.c **** 
1273:./FreeRTOS/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1274:./FreeRTOS/queue.c ****              * be done when the queue is unlocked later. */
1275:./FreeRTOS/queue.c ****             if( cTxLock == queueUNLOCKED )
1276:./FreeRTOS/queue.c ****             {
1277:./FreeRTOS/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1278:./FreeRTOS/queue.c ****                 {
1279:./FreeRTOS/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
1280:./FreeRTOS/queue.c ****                     {
1281:./FreeRTOS/queue.c ****                         if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1282:./FreeRTOS/queue.c ****                         {
1283:./FreeRTOS/queue.c ****                             /* The semaphore is a member of a queue set, and
1284:./FreeRTOS/queue.c ****                              * posting to the queue set caused a higher priority
1285:./FreeRTOS/queue.c ****                              * task to unblock.  A context switch is required. */
1286:./FreeRTOS/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 24


1287:./FreeRTOS/queue.c ****                             {
1288:./FreeRTOS/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1289:./FreeRTOS/queue.c ****                             }
1290:./FreeRTOS/queue.c ****                             else
1291:./FreeRTOS/queue.c ****                             {
1292:./FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1293:./FreeRTOS/queue.c ****                             }
1294:./FreeRTOS/queue.c ****                         }
1295:./FreeRTOS/queue.c ****                         else
1296:./FreeRTOS/queue.c ****                         {
1297:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1298:./FreeRTOS/queue.c ****                         }
1299:./FreeRTOS/queue.c ****                     }
1300:./FreeRTOS/queue.c ****                     else
1301:./FreeRTOS/queue.c ****                     {
1302:./FreeRTOS/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1303:./FreeRTOS/queue.c ****                         {
1304:./FreeRTOS/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1305:./FreeRTOS/queue.c ****                             {
1306:./FreeRTOS/queue.c ****                                 /* The task waiting has a higher priority so
1307:./FreeRTOS/queue.c ****                                  *  record that a context switch is required. */
1308:./FreeRTOS/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1309:./FreeRTOS/queue.c ****                                 {
1310:./FreeRTOS/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1311:./FreeRTOS/queue.c ****                                 }
1312:./FreeRTOS/queue.c ****                                 else
1313:./FreeRTOS/queue.c ****                                 {
1314:./FreeRTOS/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1315:./FreeRTOS/queue.c ****                                 }
1316:./FreeRTOS/queue.c ****                             }
1317:./FreeRTOS/queue.c ****                             else
1318:./FreeRTOS/queue.c ****                             {
1319:./FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1320:./FreeRTOS/queue.c ****                             }
1321:./FreeRTOS/queue.c ****                         }
1322:./FreeRTOS/queue.c ****                         else
1323:./FreeRTOS/queue.c ****                         {
1324:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1325:./FreeRTOS/queue.c ****                         }
1326:./FreeRTOS/queue.c ****                     }
1327:./FreeRTOS/queue.c ****                 }
1328:./FreeRTOS/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1329:./FreeRTOS/queue.c ****                 {
1330:./FreeRTOS/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1331:./FreeRTOS/queue.c ****                     {
1332:./FreeRTOS/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
1333:./FreeRTOS/queue.c ****                         {
1334:./FreeRTOS/queue.c ****                             /* The task waiting has a higher priority so record that a
1335:./FreeRTOS/queue.c ****                              * context switch is required. */
1336:./FreeRTOS/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
1337:./FreeRTOS/queue.c ****                             {
1338:./FreeRTOS/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1339:./FreeRTOS/queue.c ****                             }
1340:./FreeRTOS/queue.c ****                             else
1341:./FreeRTOS/queue.c ****                             {
1342:./FreeRTOS/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1343:./FreeRTOS/queue.c ****                             }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 25


1344:./FreeRTOS/queue.c ****                         }
1345:./FreeRTOS/queue.c ****                         else
1346:./FreeRTOS/queue.c ****                         {
1347:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1348:./FreeRTOS/queue.c ****                         }
1349:./FreeRTOS/queue.c ****                     }
1350:./FreeRTOS/queue.c ****                     else
1351:./FreeRTOS/queue.c ****                     {
1352:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1353:./FreeRTOS/queue.c ****                     }
1354:./FreeRTOS/queue.c ****                 }
1355:./FreeRTOS/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1356:./FreeRTOS/queue.c ****             }
1357:./FreeRTOS/queue.c ****             else
1358:./FreeRTOS/queue.c ****             {
1359:./FreeRTOS/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1360:./FreeRTOS/queue.c ****                  * knows that data was posted while it was locked. */
1361:./FreeRTOS/queue.c ****                 prvIncrementQueueTxLock( pxQueue, cTxLock );
1362:./FreeRTOS/queue.c ****             }
1363:./FreeRTOS/queue.c **** 
1364:./FreeRTOS/queue.c ****             xReturn = pdPASS;
1365:./FreeRTOS/queue.c ****         }
1366:./FreeRTOS/queue.c ****         else
1367:./FreeRTOS/queue.c ****         {
1368:./FreeRTOS/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1369:./FreeRTOS/queue.c ****             xReturn = errQUEUE_FULL;
1370:./FreeRTOS/queue.c ****         }
1371:./FreeRTOS/queue.c ****     }
1372:./FreeRTOS/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1373:./FreeRTOS/queue.c **** 
1374:./FreeRTOS/queue.c ****     return xReturn;
1375:./FreeRTOS/queue.c **** }
1376:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1377:./FreeRTOS/queue.c **** 
1378:./FreeRTOS/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue,
1379:./FreeRTOS/queue.c ****                           void * const pvBuffer,
1380:./FreeRTOS/queue.c ****                           TickType_t xTicksToWait )
1381:./FreeRTOS/queue.c **** {
1382:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1383:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
1384:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1385:./FreeRTOS/queue.c **** 
1386:./FreeRTOS/queue.c ****     /* Check the pointer is not NULL. */
1387:./FreeRTOS/queue.c ****     configASSERT( ( pxQueue ) );
1388:./FreeRTOS/queue.c **** 
1389:./FreeRTOS/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1390:./FreeRTOS/queue.c ****      * is zero (so no data is copied into the buffer). */
1391:./FreeRTOS/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
1392:./FreeRTOS/queue.c **** 
1393:./FreeRTOS/queue.c ****     /* Cannot block if the scheduler is suspended. */
1394:./FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1395:./FreeRTOS/queue.c ****     {
1396:./FreeRTOS/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
1397:./FreeRTOS/queue.c ****     }
1398:./FreeRTOS/queue.c ****     #endif
1399:./FreeRTOS/queue.c **** 
1400:./FreeRTOS/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 26


1401:./FreeRTOS/queue.c ****      * allow return statements within the function itself.  This is done in the
1402:./FreeRTOS/queue.c ****      * interest of execution time efficiency. */
1403:./FreeRTOS/queue.c ****     for( ; ; )
1404:./FreeRTOS/queue.c ****     {
1405:./FreeRTOS/queue.c ****         taskENTER_CRITICAL();
1406:./FreeRTOS/queue.c ****         {
1407:./FreeRTOS/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1408:./FreeRTOS/queue.c **** 
1409:./FreeRTOS/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1410:./FreeRTOS/queue.c ****              * must be the highest priority task wanting to access the queue. */
1411:./FreeRTOS/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1412:./FreeRTOS/queue.c ****             {
1413:./FreeRTOS/queue.c ****                 /* Data available, remove one item. */
1414:./FreeRTOS/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
1415:./FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1416:./FreeRTOS/queue.c ****                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1417:./FreeRTOS/queue.c **** 
1418:./FreeRTOS/queue.c ****                 /* There is now space in the queue, were any tasks waiting to
1419:./FreeRTOS/queue.c ****                  * post to the queue?  If so, unblock the highest priority waiting
1420:./FreeRTOS/queue.c ****                  * task. */
1421:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1422:./FreeRTOS/queue.c ****                 {
1423:./FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1424:./FreeRTOS/queue.c ****                     {
1425:./FreeRTOS/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1426:./FreeRTOS/queue.c ****                     }
1427:./FreeRTOS/queue.c ****                     else
1428:./FreeRTOS/queue.c ****                     {
1429:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1430:./FreeRTOS/queue.c ****                     }
1431:./FreeRTOS/queue.c ****                 }
1432:./FreeRTOS/queue.c ****                 else
1433:./FreeRTOS/queue.c ****                 {
1434:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1435:./FreeRTOS/queue.c ****                 }
1436:./FreeRTOS/queue.c **** 
1437:./FreeRTOS/queue.c ****                 taskEXIT_CRITICAL();
1438:./FreeRTOS/queue.c ****                 return pdPASS;
1439:./FreeRTOS/queue.c ****             }
1440:./FreeRTOS/queue.c ****             else
1441:./FreeRTOS/queue.c ****             {
1442:./FreeRTOS/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1443:./FreeRTOS/queue.c ****                 {
1444:./FreeRTOS/queue.c ****                     /* The queue was empty and no block time is specified (or
1445:./FreeRTOS/queue.c ****                      * the block time has expired) so leave now. */
1446:./FreeRTOS/queue.c ****                     taskEXIT_CRITICAL();
1447:./FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1448:./FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
1449:./FreeRTOS/queue.c ****                 }
1450:./FreeRTOS/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1451:./FreeRTOS/queue.c ****                 {
1452:./FreeRTOS/queue.c ****                     /* The queue was empty and a block time was specified so
1453:./FreeRTOS/queue.c ****                      * configure the timeout structure. */
1454:./FreeRTOS/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1455:./FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
1456:./FreeRTOS/queue.c ****                 }
1457:./FreeRTOS/queue.c ****                 else
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 27


1458:./FreeRTOS/queue.c ****                 {
1459:./FreeRTOS/queue.c ****                     /* Entry time was already set. */
1460:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1461:./FreeRTOS/queue.c ****                 }
1462:./FreeRTOS/queue.c ****             }
1463:./FreeRTOS/queue.c ****         }
1464:./FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
1465:./FreeRTOS/queue.c **** 
1466:./FreeRTOS/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1467:./FreeRTOS/queue.c ****          * now the critical section has been exited. */
1468:./FreeRTOS/queue.c **** 
1469:./FreeRTOS/queue.c ****         vTaskSuspendAll();
1470:./FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
1471:./FreeRTOS/queue.c **** 
1472:./FreeRTOS/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1473:./FreeRTOS/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1474:./FreeRTOS/queue.c ****         {
1475:./FreeRTOS/queue.c ****             /* The timeout has not expired.  If the queue is still empty place
1476:./FreeRTOS/queue.c ****              * the task on the list of tasks waiting to receive from the queue. */
1477:./FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1478:./FreeRTOS/queue.c ****             {
1479:./FreeRTOS/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1480:./FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1481:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1482:./FreeRTOS/queue.c **** 
1483:./FreeRTOS/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1484:./FreeRTOS/queue.c ****                 {
1485:./FreeRTOS/queue.c ****                     portYIELD_WITHIN_API();
1486:./FreeRTOS/queue.c ****                 }
1487:./FreeRTOS/queue.c ****                 else
1488:./FreeRTOS/queue.c ****                 {
1489:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1490:./FreeRTOS/queue.c ****                 }
1491:./FreeRTOS/queue.c ****             }
1492:./FreeRTOS/queue.c ****             else
1493:./FreeRTOS/queue.c ****             {
1494:./FreeRTOS/queue.c ****                 /* The queue contains data again.  Loop back to try and read the
1495:./FreeRTOS/queue.c ****                  * data. */
1496:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1497:./FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
1498:./FreeRTOS/queue.c ****             }
1499:./FreeRTOS/queue.c ****         }
1500:./FreeRTOS/queue.c ****         else
1501:./FreeRTOS/queue.c ****         {
1502:./FreeRTOS/queue.c ****             /* Timed out.  If there is no data in the queue exit, otherwise loop
1503:./FreeRTOS/queue.c ****              * back and attempt to read the data. */
1504:./FreeRTOS/queue.c ****             prvUnlockQueue( pxQueue );
1505:./FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
1506:./FreeRTOS/queue.c **** 
1507:./FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1508:./FreeRTOS/queue.c ****             {
1509:./FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1510:./FreeRTOS/queue.c ****                 return errQUEUE_EMPTY;
1511:./FreeRTOS/queue.c ****             }
1512:./FreeRTOS/queue.c ****             else
1513:./FreeRTOS/queue.c ****             {
1514:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 28


1515:./FreeRTOS/queue.c ****             }
1516:./FreeRTOS/queue.c ****         }
1517:./FreeRTOS/queue.c ****     } /*lint -restore */
1518:./FreeRTOS/queue.c **** }
1519:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1520:./FreeRTOS/queue.c **** 
1521:./FreeRTOS/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
1522:./FreeRTOS/queue.c ****                                 TickType_t xTicksToWait )
1523:./FreeRTOS/queue.c **** {
1524:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1525:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
1526:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1527:./FreeRTOS/queue.c **** 
1528:./FreeRTOS/queue.c ****     #if ( configUSE_MUTEXES == 1 )
1529:./FreeRTOS/queue.c ****         BaseType_t xInheritanceOccurred = pdFALSE;
1530:./FreeRTOS/queue.c ****     #endif
1531:./FreeRTOS/queue.c **** 
1532:./FreeRTOS/queue.c ****     /* Check the queue pointer is not NULL. */
1533:./FreeRTOS/queue.c ****     configASSERT( ( pxQueue ) );
1534:./FreeRTOS/queue.c **** 
1535:./FreeRTOS/queue.c ****     /* Check this really is a semaphore, in which case the item size will be
1536:./FreeRTOS/queue.c ****      * 0. */
1537:./FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
1538:./FreeRTOS/queue.c **** 
1539:./FreeRTOS/queue.c ****     /* Cannot block if the scheduler is suspended. */
1540:./FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1541:./FreeRTOS/queue.c ****     {
1542:./FreeRTOS/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
1543:./FreeRTOS/queue.c ****     }
1544:./FreeRTOS/queue.c ****     #endif
1545:./FreeRTOS/queue.c **** 
1546:./FreeRTOS/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1547:./FreeRTOS/queue.c ****      * statements within the function itself.  This is done in the interest
1548:./FreeRTOS/queue.c ****      * of execution time efficiency. */
1549:./FreeRTOS/queue.c ****     for( ; ; )
1550:./FreeRTOS/queue.c ****     {
1551:./FreeRTOS/queue.c ****         taskENTER_CRITICAL();
1552:./FreeRTOS/queue.c ****         {
1553:./FreeRTOS/queue.c ****             /* Semaphores are queues with an item size of 0, and where the
1554:./FreeRTOS/queue.c ****              * number of messages in the queue is the semaphore's count value. */
1555:./FreeRTOS/queue.c ****             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1556:./FreeRTOS/queue.c **** 
1557:./FreeRTOS/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1558:./FreeRTOS/queue.c ****              * must be the highest priority task wanting to access the queue. */
1559:./FreeRTOS/queue.c ****             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1560:./FreeRTOS/queue.c ****             {
1561:./FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1562:./FreeRTOS/queue.c **** 
1563:./FreeRTOS/queue.c ****                 /* Semaphores are queues with a data size of zero and where the
1564:./FreeRTOS/queue.c ****                  * messages waiting is the semaphore's count.  Reduce the count. */
1565:./FreeRTOS/queue.c ****                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1566:./FreeRTOS/queue.c **** 
1567:./FreeRTOS/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1568:./FreeRTOS/queue.c ****                 {
1569:./FreeRTOS/queue.c ****                     if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1570:./FreeRTOS/queue.c ****                     {
1571:./FreeRTOS/queue.c ****                         /* Record the information required to implement
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 29


1572:./FreeRTOS/queue.c ****                          * priority inheritance should it become necessary. */
1573:./FreeRTOS/queue.c ****                         pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1574:./FreeRTOS/queue.c ****                     }
1575:./FreeRTOS/queue.c ****                     else
1576:./FreeRTOS/queue.c ****                     {
1577:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1578:./FreeRTOS/queue.c ****                     }
1579:./FreeRTOS/queue.c ****                 }
1580:./FreeRTOS/queue.c ****                 #endif /* configUSE_MUTEXES */
1581:./FreeRTOS/queue.c **** 
1582:./FreeRTOS/queue.c ****                 /* Check to see if other tasks are blocked waiting to give the
1583:./FreeRTOS/queue.c ****                  * semaphore, and if so, unblock the highest priority such task. */
1584:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1585:./FreeRTOS/queue.c ****                 {
1586:./FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1587:./FreeRTOS/queue.c ****                     {
1588:./FreeRTOS/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1589:./FreeRTOS/queue.c ****                     }
1590:./FreeRTOS/queue.c ****                     else
1591:./FreeRTOS/queue.c ****                     {
1592:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1593:./FreeRTOS/queue.c ****                     }
1594:./FreeRTOS/queue.c ****                 }
1595:./FreeRTOS/queue.c ****                 else
1596:./FreeRTOS/queue.c ****                 {
1597:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1598:./FreeRTOS/queue.c ****                 }
1599:./FreeRTOS/queue.c **** 
1600:./FreeRTOS/queue.c ****                 taskEXIT_CRITICAL();
1601:./FreeRTOS/queue.c ****                 return pdPASS;
1602:./FreeRTOS/queue.c ****             }
1603:./FreeRTOS/queue.c ****             else
1604:./FreeRTOS/queue.c ****             {
1605:./FreeRTOS/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1606:./FreeRTOS/queue.c ****                 {
1607:./FreeRTOS/queue.c ****                     /* The semaphore count was 0 and no block time is specified
1608:./FreeRTOS/queue.c ****                      * (or the block time has expired) so exit now. */
1609:./FreeRTOS/queue.c ****                     taskEXIT_CRITICAL();
1610:./FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1611:./FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
1612:./FreeRTOS/queue.c ****                 }
1613:./FreeRTOS/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1614:./FreeRTOS/queue.c ****                 {
1615:./FreeRTOS/queue.c ****                     /* The semaphore count was 0 and a block time was specified
1616:./FreeRTOS/queue.c ****                      * so configure the timeout structure ready to block. */
1617:./FreeRTOS/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1618:./FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
1619:./FreeRTOS/queue.c ****                 }
1620:./FreeRTOS/queue.c ****                 else
1621:./FreeRTOS/queue.c ****                 {
1622:./FreeRTOS/queue.c ****                     /* Entry time was already set. */
1623:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1624:./FreeRTOS/queue.c ****                 }
1625:./FreeRTOS/queue.c ****             }
1626:./FreeRTOS/queue.c ****         }
1627:./FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
1628:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 30


1629:./FreeRTOS/queue.c ****         /* Interrupts and other tasks can give to and take from the semaphore
1630:./FreeRTOS/queue.c ****          * now the critical section has been exited. */
1631:./FreeRTOS/queue.c **** 
1632:./FreeRTOS/queue.c ****         vTaskSuspendAll();
1633:./FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
1634:./FreeRTOS/queue.c **** 
1635:./FreeRTOS/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1636:./FreeRTOS/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1637:./FreeRTOS/queue.c ****         {
1638:./FreeRTOS/queue.c ****             /* A block time is specified and not expired.  If the semaphore
1639:./FreeRTOS/queue.c ****              * count is 0 then enter the Blocked state to wait for a semaphore to
1640:./FreeRTOS/queue.c ****              * become available.  As semaphores are implemented with queues the
1641:./FreeRTOS/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1642:./FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1643:./FreeRTOS/queue.c ****             {
1644:./FreeRTOS/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1645:./FreeRTOS/queue.c **** 
1646:./FreeRTOS/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1647:./FreeRTOS/queue.c ****                 {
1648:./FreeRTOS/queue.c ****                     if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1649:./FreeRTOS/queue.c ****                     {
1650:./FreeRTOS/queue.c ****                         taskENTER_CRITICAL();
1651:./FreeRTOS/queue.c ****                         {
1652:./FreeRTOS/queue.c ****                             xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMut
1653:./FreeRTOS/queue.c ****                         }
1654:./FreeRTOS/queue.c ****                         taskEXIT_CRITICAL();
1655:./FreeRTOS/queue.c ****                     }
1656:./FreeRTOS/queue.c ****                     else
1657:./FreeRTOS/queue.c ****                     {
1658:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1659:./FreeRTOS/queue.c ****                     }
1660:./FreeRTOS/queue.c ****                 }
1661:./FreeRTOS/queue.c ****                 #endif /* if ( configUSE_MUTEXES == 1 ) */
1662:./FreeRTOS/queue.c **** 
1663:./FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1664:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1665:./FreeRTOS/queue.c **** 
1666:./FreeRTOS/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1667:./FreeRTOS/queue.c ****                 {
1668:./FreeRTOS/queue.c ****                     portYIELD_WITHIN_API();
1669:./FreeRTOS/queue.c ****                 }
1670:./FreeRTOS/queue.c ****                 else
1671:./FreeRTOS/queue.c ****                 {
1672:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1673:./FreeRTOS/queue.c ****                 }
1674:./FreeRTOS/queue.c ****             }
1675:./FreeRTOS/queue.c ****             else
1676:./FreeRTOS/queue.c ****             {
1677:./FreeRTOS/queue.c ****                 /* There was no timeout and the semaphore count was not 0, so
1678:./FreeRTOS/queue.c ****                  * attempt to take the semaphore again. */
1679:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1680:./FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
1681:./FreeRTOS/queue.c ****             }
1682:./FreeRTOS/queue.c ****         }
1683:./FreeRTOS/queue.c ****         else
1684:./FreeRTOS/queue.c ****         {
1685:./FreeRTOS/queue.c ****             /* Timed out. */
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 31


1686:./FreeRTOS/queue.c ****             prvUnlockQueue( pxQueue );
1687:./FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
1688:./FreeRTOS/queue.c **** 
1689:./FreeRTOS/queue.c ****             /* If the semaphore count is 0 exit now as the timeout has
1690:./FreeRTOS/queue.c ****              * expired.  Otherwise return to attempt to take the semaphore that is
1691:./FreeRTOS/queue.c ****              * known to be available.  As semaphores are implemented by queues the
1692:./FreeRTOS/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1693:./FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1694:./FreeRTOS/queue.c ****             {
1695:./FreeRTOS/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1696:./FreeRTOS/queue.c ****                 {
1697:./FreeRTOS/queue.c ****                     /* xInheritanceOccurred could only have be set if
1698:./FreeRTOS/queue.c ****                      * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1699:./FreeRTOS/queue.c ****                      * test the mutex type again to check it is actually a mutex. */
1700:./FreeRTOS/queue.c ****                     if( xInheritanceOccurred != pdFALSE )
1701:./FreeRTOS/queue.c ****                     {
1702:./FreeRTOS/queue.c ****                         taskENTER_CRITICAL();
1703:./FreeRTOS/queue.c ****                         {
1704:./FreeRTOS/queue.c ****                             UBaseType_t uxHighestWaitingPriority;
1705:./FreeRTOS/queue.c **** 
1706:./FreeRTOS/queue.c ****                             /* This task blocking on the mutex caused another
1707:./FreeRTOS/queue.c ****                              * task to inherit this task's priority.  Now this task
1708:./FreeRTOS/queue.c ****                              * has timed out the priority should be disinherited
1709:./FreeRTOS/queue.c ****                              * again, but only as low as the next highest priority
1710:./FreeRTOS/queue.c ****                              * task that is waiting for the same mutex. */
1711:./FreeRTOS/queue.c ****                             uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueu
1712:./FreeRTOS/queue.c ****                             vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder
1713:./FreeRTOS/queue.c ****                         }
1714:./FreeRTOS/queue.c ****                         taskEXIT_CRITICAL();
1715:./FreeRTOS/queue.c ****                     }
1716:./FreeRTOS/queue.c ****                 }
1717:./FreeRTOS/queue.c ****                 #endif /* configUSE_MUTEXES */
1718:./FreeRTOS/queue.c **** 
1719:./FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1720:./FreeRTOS/queue.c ****                 return errQUEUE_EMPTY;
1721:./FreeRTOS/queue.c ****             }
1722:./FreeRTOS/queue.c ****             else
1723:./FreeRTOS/queue.c ****             {
1724:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1725:./FreeRTOS/queue.c ****             }
1726:./FreeRTOS/queue.c ****         }
1727:./FreeRTOS/queue.c ****     } /*lint -restore */
1728:./FreeRTOS/queue.c **** }
1729:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1730:./FreeRTOS/queue.c **** 
1731:./FreeRTOS/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue,
1732:./FreeRTOS/queue.c ****                        void * const pvBuffer,
1733:./FreeRTOS/queue.c ****                        TickType_t xTicksToWait )
1734:./FreeRTOS/queue.c **** {
1735:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1736:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
1737:./FreeRTOS/queue.c ****     int8_t * pcOriginalReadPosition;
1738:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1739:./FreeRTOS/queue.c **** 
1740:./FreeRTOS/queue.c ****     /* Check the pointer is not NULL. */
1741:./FreeRTOS/queue.c ****     configASSERT( ( pxQueue ) );
1742:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 32


1743:./FreeRTOS/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1744:./FreeRTOS/queue.c ****      * is zero (so no data is copied into the buffer. */
1745:./FreeRTOS/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
1746:./FreeRTOS/queue.c **** 
1747:./FreeRTOS/queue.c ****     /* Cannot block if the scheduler is suspended. */
1748:./FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1749:./FreeRTOS/queue.c ****     {
1750:./FreeRTOS/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
1751:./FreeRTOS/queue.c ****     }
1752:./FreeRTOS/queue.c ****     #endif
1753:./FreeRTOS/queue.c **** 
1754:./FreeRTOS/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1755:./FreeRTOS/queue.c ****      * allow return statements within the function itself.  This is done in the
1756:./FreeRTOS/queue.c ****      * interest of execution time efficiency. */
1757:./FreeRTOS/queue.c ****     for( ; ; )
1758:./FreeRTOS/queue.c ****     {
1759:./FreeRTOS/queue.c ****         taskENTER_CRITICAL();
1760:./FreeRTOS/queue.c ****         {
1761:./FreeRTOS/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1762:./FreeRTOS/queue.c **** 
1763:./FreeRTOS/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1764:./FreeRTOS/queue.c ****              * must be the highest priority task wanting to access the queue. */
1765:./FreeRTOS/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1766:./FreeRTOS/queue.c ****             {
1767:./FreeRTOS/queue.c ****                 /* Remember the read position so it can be reset after the data
1768:./FreeRTOS/queue.c ****                  * is read from the queue as this function is only peeking the
1769:./FreeRTOS/queue.c ****                  * data, not removing it. */
1770:./FreeRTOS/queue.c ****                 pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1771:./FreeRTOS/queue.c **** 
1772:./FreeRTOS/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
1773:./FreeRTOS/queue.c ****                 traceQUEUE_PEEK( pxQueue );
1774:./FreeRTOS/queue.c **** 
1775:./FreeRTOS/queue.c ****                 /* The data is not being removed, so reset the read pointer. */
1776:./FreeRTOS/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1777:./FreeRTOS/queue.c **** 
1778:./FreeRTOS/queue.c ****                 /* The data is being left in the queue, so see if there are
1779:./FreeRTOS/queue.c ****                  * any other tasks waiting for the data. */
1780:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1781:./FreeRTOS/queue.c ****                 {
1782:./FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE
1783:./FreeRTOS/queue.c ****                     {
1784:./FreeRTOS/queue.c ****                         /* The task waiting has a higher priority than this task. */
1785:./FreeRTOS/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1786:./FreeRTOS/queue.c ****                     }
1787:./FreeRTOS/queue.c ****                     else
1788:./FreeRTOS/queue.c ****                     {
1789:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1790:./FreeRTOS/queue.c ****                     }
1791:./FreeRTOS/queue.c ****                 }
1792:./FreeRTOS/queue.c ****                 else
1793:./FreeRTOS/queue.c ****                 {
1794:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1795:./FreeRTOS/queue.c ****                 }
1796:./FreeRTOS/queue.c **** 
1797:./FreeRTOS/queue.c ****                 taskEXIT_CRITICAL();
1798:./FreeRTOS/queue.c ****                 return pdPASS;
1799:./FreeRTOS/queue.c ****             }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 33


1800:./FreeRTOS/queue.c ****             else
1801:./FreeRTOS/queue.c ****             {
1802:./FreeRTOS/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1803:./FreeRTOS/queue.c ****                 {
1804:./FreeRTOS/queue.c ****                     /* The queue was empty and no block time is specified (or
1805:./FreeRTOS/queue.c ****                      * the block time has expired) so leave now. */
1806:./FreeRTOS/queue.c ****                     taskEXIT_CRITICAL();
1807:./FreeRTOS/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
1808:./FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
1809:./FreeRTOS/queue.c ****                 }
1810:./FreeRTOS/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1811:./FreeRTOS/queue.c ****                 {
1812:./FreeRTOS/queue.c ****                     /* The queue was empty and a block time was specified so
1813:./FreeRTOS/queue.c ****                      * configure the timeout structure ready to enter the blocked
1814:./FreeRTOS/queue.c ****                      * state. */
1815:./FreeRTOS/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1816:./FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
1817:./FreeRTOS/queue.c ****                 }
1818:./FreeRTOS/queue.c ****                 else
1819:./FreeRTOS/queue.c ****                 {
1820:./FreeRTOS/queue.c ****                     /* Entry time was already set. */
1821:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1822:./FreeRTOS/queue.c ****                 }
1823:./FreeRTOS/queue.c ****             }
1824:./FreeRTOS/queue.c ****         }
1825:./FreeRTOS/queue.c ****         taskEXIT_CRITICAL();
1826:./FreeRTOS/queue.c **** 
1827:./FreeRTOS/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1828:./FreeRTOS/queue.c ****          * now that the critical section has been exited. */
1829:./FreeRTOS/queue.c **** 
1830:./FreeRTOS/queue.c ****         vTaskSuspendAll();
1831:./FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
1832:./FreeRTOS/queue.c **** 
1833:./FreeRTOS/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1834:./FreeRTOS/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1835:./FreeRTOS/queue.c ****         {
1836:./FreeRTOS/queue.c ****             /* Timeout has not expired yet, check to see if there is data in the
1837:./FreeRTOS/queue.c ****             * queue now, and if not enter the Blocked state to wait for data. */
1838:./FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1839:./FreeRTOS/queue.c ****             {
1840:./FreeRTOS/queue.c ****                 traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1841:./FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1842:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1843:./FreeRTOS/queue.c **** 
1844:./FreeRTOS/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1845:./FreeRTOS/queue.c ****                 {
1846:./FreeRTOS/queue.c ****                     portYIELD_WITHIN_API();
1847:./FreeRTOS/queue.c ****                 }
1848:./FreeRTOS/queue.c ****                 else
1849:./FreeRTOS/queue.c ****                 {
1850:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1851:./FreeRTOS/queue.c ****                 }
1852:./FreeRTOS/queue.c ****             }
1853:./FreeRTOS/queue.c ****             else
1854:./FreeRTOS/queue.c ****             {
1855:./FreeRTOS/queue.c ****                 /* There is data in the queue now, so don't enter the blocked
1856:./FreeRTOS/queue.c ****                  * state, instead return to try and obtain the data. */
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 34


1857:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
1858:./FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
1859:./FreeRTOS/queue.c ****             }
1860:./FreeRTOS/queue.c ****         }
1861:./FreeRTOS/queue.c ****         else
1862:./FreeRTOS/queue.c ****         {
1863:./FreeRTOS/queue.c ****             /* The timeout has expired.  If there is still no data in the queue
1864:./FreeRTOS/queue.c ****              * exit, otherwise go back and try to read the data again. */
1865:./FreeRTOS/queue.c ****             prvUnlockQueue( pxQueue );
1866:./FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
1867:./FreeRTOS/queue.c **** 
1868:./FreeRTOS/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1869:./FreeRTOS/queue.c ****             {
1870:./FreeRTOS/queue.c ****                 traceQUEUE_PEEK_FAILED( pxQueue );
1871:./FreeRTOS/queue.c ****                 return errQUEUE_EMPTY;
1872:./FreeRTOS/queue.c ****             }
1873:./FreeRTOS/queue.c ****             else
1874:./FreeRTOS/queue.c ****             {
1875:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1876:./FreeRTOS/queue.c ****             }
1877:./FreeRTOS/queue.c ****         }
1878:./FreeRTOS/queue.c ****     } /*lint -restore */
1879:./FreeRTOS/queue.c **** }
1880:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1881:./FreeRTOS/queue.c **** 
1882:./FreeRTOS/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
1883:./FreeRTOS/queue.c ****                                  void * const pvBuffer,
1884:./FreeRTOS/queue.c ****                                  BaseType_t * const pxHigherPriorityTaskWoken )
1885:./FreeRTOS/queue.c **** {
1886:./FreeRTOS/queue.c ****     BaseType_t xReturn;
1887:./FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1888:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1889:./FreeRTOS/queue.c **** 
1890:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
1891:./FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1892:./FreeRTOS/queue.c **** 
1893:./FreeRTOS/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1894:./FreeRTOS/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1895:./FreeRTOS/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1896:./FreeRTOS/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1897:./FreeRTOS/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1898:./FreeRTOS/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1899:./FreeRTOS/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1900:./FreeRTOS/queue.c ****      * assigned a priority above the configured maximum system call priority.
1901:./FreeRTOS/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1902:./FreeRTOS/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1903:./FreeRTOS/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1904:./FreeRTOS/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1905:./FreeRTOS/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1906:./FreeRTOS/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1907:./FreeRTOS/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1908:./FreeRTOS/queue.c **** 
1909:./FreeRTOS/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1910:./FreeRTOS/queue.c ****     {
1911:./FreeRTOS/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1912:./FreeRTOS/queue.c **** 
1913:./FreeRTOS/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 35


1914:./FreeRTOS/queue.c ****         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1915:./FreeRTOS/queue.c ****         {
1916:./FreeRTOS/queue.c ****             const int8_t cRxLock = pxQueue->cRxLock;
1917:./FreeRTOS/queue.c **** 
1918:./FreeRTOS/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1919:./FreeRTOS/queue.c **** 
1920:./FreeRTOS/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
1921:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1922:./FreeRTOS/queue.c **** 
1923:./FreeRTOS/queue.c ****             /* If the queue is locked the event list will not be modified.
1924:./FreeRTOS/queue.c ****              * Instead update the lock count so the task that unlocks the queue
1925:./FreeRTOS/queue.c ****              * will know that an ISR has removed data while the queue was
1926:./FreeRTOS/queue.c ****              * locked. */
1927:./FreeRTOS/queue.c ****             if( cRxLock == queueUNLOCKED )
1928:./FreeRTOS/queue.c ****             {
1929:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1930:./FreeRTOS/queue.c ****                 {
1931:./FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1932:./FreeRTOS/queue.c ****                     {
1933:./FreeRTOS/queue.c ****                         /* The task waiting has a higher priority than us so
1934:./FreeRTOS/queue.c ****                          * force a context switch. */
1935:./FreeRTOS/queue.c ****                         if( pxHigherPriorityTaskWoken != NULL )
1936:./FreeRTOS/queue.c ****                         {
1937:./FreeRTOS/queue.c ****                             *pxHigherPriorityTaskWoken = pdTRUE;
1938:./FreeRTOS/queue.c ****                         }
1939:./FreeRTOS/queue.c ****                         else
1940:./FreeRTOS/queue.c ****                         {
1941:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1942:./FreeRTOS/queue.c ****                         }
1943:./FreeRTOS/queue.c ****                     }
1944:./FreeRTOS/queue.c ****                     else
1945:./FreeRTOS/queue.c ****                     {
1946:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1947:./FreeRTOS/queue.c ****                     }
1948:./FreeRTOS/queue.c ****                 }
1949:./FreeRTOS/queue.c ****                 else
1950:./FreeRTOS/queue.c ****                 {
1951:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1952:./FreeRTOS/queue.c ****                 }
1953:./FreeRTOS/queue.c ****             }
1954:./FreeRTOS/queue.c ****             else
1955:./FreeRTOS/queue.c ****             {
1956:./FreeRTOS/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1957:./FreeRTOS/queue.c ****                  * knows that data was removed while it was locked. */
1958:./FreeRTOS/queue.c ****                 prvIncrementQueueRxLock( pxQueue, cRxLock );
1959:./FreeRTOS/queue.c ****             }
1960:./FreeRTOS/queue.c **** 
1961:./FreeRTOS/queue.c ****             xReturn = pdPASS;
1962:./FreeRTOS/queue.c ****         }
1963:./FreeRTOS/queue.c ****         else
1964:./FreeRTOS/queue.c ****         {
1965:./FreeRTOS/queue.c ****             xReturn = pdFAIL;
1966:./FreeRTOS/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1967:./FreeRTOS/queue.c ****         }
1968:./FreeRTOS/queue.c ****     }
1969:./FreeRTOS/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1970:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 36


1971:./FreeRTOS/queue.c ****     return xReturn;
1972:./FreeRTOS/queue.c **** }
1973:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1974:./FreeRTOS/queue.c **** 
1975:./FreeRTOS/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
1976:./FreeRTOS/queue.c ****                               void * const pvBuffer )
1977:./FreeRTOS/queue.c **** {
1978:./FreeRTOS/queue.c ****     BaseType_t xReturn;
1979:./FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1980:./FreeRTOS/queue.c ****     int8_t * pcOriginalReadPosition;
1981:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
1982:./FreeRTOS/queue.c **** 
1983:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
1984:./FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1985:./FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1986:./FreeRTOS/queue.c **** 
1987:./FreeRTOS/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1988:./FreeRTOS/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1989:./FreeRTOS/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1990:./FreeRTOS/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1991:./FreeRTOS/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1992:./FreeRTOS/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1993:./FreeRTOS/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1994:./FreeRTOS/queue.c ****      * assigned a priority above the configured maximum system call priority.
1995:./FreeRTOS/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1996:./FreeRTOS/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1997:./FreeRTOS/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1998:./FreeRTOS/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1999:./FreeRTOS/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
2000:./FreeRTOS/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
2001:./FreeRTOS/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2002:./FreeRTOS/queue.c **** 
2003:./FreeRTOS/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2004:./FreeRTOS/queue.c ****     {
2005:./FreeRTOS/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
2006:./FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2007:./FreeRTOS/queue.c ****         {
2008:./FreeRTOS/queue.c ****             traceQUEUE_PEEK_FROM_ISR( pxQueue );
2009:./FreeRTOS/queue.c **** 
2010:./FreeRTOS/queue.c ****             /* Remember the read position so it can be reset as nothing is
2011:./FreeRTOS/queue.c ****              * actually being removed from the queue. */
2012:./FreeRTOS/queue.c ****             pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
2013:./FreeRTOS/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
2014:./FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
2015:./FreeRTOS/queue.c **** 
2016:./FreeRTOS/queue.c ****             xReturn = pdPASS;
2017:./FreeRTOS/queue.c ****         }
2018:./FreeRTOS/queue.c ****         else
2019:./FreeRTOS/queue.c ****         {
2020:./FreeRTOS/queue.c ****             xReturn = pdFAIL;
2021:./FreeRTOS/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
2022:./FreeRTOS/queue.c ****         }
2023:./FreeRTOS/queue.c ****     }
2024:./FreeRTOS/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2025:./FreeRTOS/queue.c **** 
2026:./FreeRTOS/queue.c ****     return xReturn;
2027:./FreeRTOS/queue.c **** }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 37


2028:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2029:./FreeRTOS/queue.c **** 
2030:./FreeRTOS/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
2031:./FreeRTOS/queue.c **** {
2032:./FreeRTOS/queue.c ****     UBaseType_t uxReturn;
2033:./FreeRTOS/queue.c **** 
2034:./FreeRTOS/queue.c ****     configASSERT( xQueue );
2035:./FreeRTOS/queue.c **** 
2036:./FreeRTOS/queue.c ****     taskENTER_CRITICAL();
2037:./FreeRTOS/queue.c ****     {
2038:./FreeRTOS/queue.c ****         uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
2039:./FreeRTOS/queue.c ****     }
2040:./FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
2041:./FreeRTOS/queue.c **** 
2042:./FreeRTOS/queue.c ****     return uxReturn;
2043:./FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2044:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2045:./FreeRTOS/queue.c **** 
2046:./FreeRTOS/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
2047:./FreeRTOS/queue.c **** {
2048:./FreeRTOS/queue.c ****     UBaseType_t uxReturn;
2049:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
2050:./FreeRTOS/queue.c **** 
2051:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
2052:./FreeRTOS/queue.c **** 
2053:./FreeRTOS/queue.c ****     taskENTER_CRITICAL();
2054:./FreeRTOS/queue.c ****     {
2055:./FreeRTOS/queue.c ****         uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
2056:./FreeRTOS/queue.c ****     }
2057:./FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
2058:./FreeRTOS/queue.c **** 
2059:./FreeRTOS/queue.c ****     return uxReturn;
2060:./FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2061:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2062:./FreeRTOS/queue.c **** 
2063:./FreeRTOS/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
2064:./FreeRTOS/queue.c **** {
2065:./FreeRTOS/queue.c ****     UBaseType_t uxReturn;
2066:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
2067:./FreeRTOS/queue.c **** 
2068:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
2069:./FreeRTOS/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
2070:./FreeRTOS/queue.c **** 
2071:./FreeRTOS/queue.c ****     return uxReturn;
2072:./FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2073:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2074:./FreeRTOS/queue.c **** 
2075:./FreeRTOS/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
2076:./FreeRTOS/queue.c **** {
2077:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
2078:./FreeRTOS/queue.c **** 
2079:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
2080:./FreeRTOS/queue.c ****     traceQUEUE_DELETE( pxQueue );
2081:./FreeRTOS/queue.c **** 
2082:./FreeRTOS/queue.c ****     #if ( configQUEUE_REGISTRY_SIZE > 0 )
2083:./FreeRTOS/queue.c ****     {
2084:./FreeRTOS/queue.c ****         vQueueUnregisterQueue( pxQueue );
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 38


2085:./FreeRTOS/queue.c ****     }
2086:./FreeRTOS/queue.c ****     #endif
2087:./FreeRTOS/queue.c **** 
2088:./FreeRTOS/queue.c ****     #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
2089:./FreeRTOS/queue.c ****     {
2090:./FreeRTOS/queue.c ****         /* The queue can only have been allocated dynamically - free it
2091:./FreeRTOS/queue.c ****          * again. */
2092:./FreeRTOS/queue.c ****         vPortFree( pxQueue );
2093:./FreeRTOS/queue.c ****     }
2094:./FreeRTOS/queue.c ****     #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
2095:./FreeRTOS/queue.c ****     {
2096:./FreeRTOS/queue.c ****         /* The queue could have been allocated statically or dynamically, so
2097:./FreeRTOS/queue.c ****          * check before attempting to free the memory. */
2098:./FreeRTOS/queue.c ****         if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
2099:./FreeRTOS/queue.c ****         {
2100:./FreeRTOS/queue.c ****             vPortFree( pxQueue );
2101:./FreeRTOS/queue.c ****         }
2102:./FreeRTOS/queue.c ****         else
2103:./FreeRTOS/queue.c ****         {
2104:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2105:./FreeRTOS/queue.c ****         }
2106:./FreeRTOS/queue.c ****     }
2107:./FreeRTOS/queue.c ****     #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION ==
2108:./FreeRTOS/queue.c ****     {
2109:./FreeRTOS/queue.c ****         /* The queue must have been statically allocated, so is not going to be
2110:./FreeRTOS/queue.c ****          * deleted.  Avoid compiler warnings about the unused parameter. */
2111:./FreeRTOS/queue.c ****         ( void ) pxQueue;
2112:./FreeRTOS/queue.c ****     }
2113:./FreeRTOS/queue.c ****     #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2114:./FreeRTOS/queue.c **** }
2115:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2116:./FreeRTOS/queue.c **** 
2117:./FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2118:./FreeRTOS/queue.c **** 
2119:./FreeRTOS/queue.c ****     UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2120:./FreeRTOS/queue.c ****     {
2121:./FreeRTOS/queue.c ****         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2122:./FreeRTOS/queue.c ****     }
2123:./FreeRTOS/queue.c **** 
2124:./FreeRTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2125:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2126:./FreeRTOS/queue.c **** 
2127:./FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2128:./FreeRTOS/queue.c **** 
2129:./FreeRTOS/queue.c ****     void vQueueSetQueueNumber( QueueHandle_t xQueue,
2130:./FreeRTOS/queue.c ****                                UBaseType_t uxQueueNumber )
2131:./FreeRTOS/queue.c ****     {
2132:./FreeRTOS/queue.c ****         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2133:./FreeRTOS/queue.c ****     }
2134:./FreeRTOS/queue.c **** 
2135:./FreeRTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2136:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2137:./FreeRTOS/queue.c **** 
2138:./FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2139:./FreeRTOS/queue.c **** 
2140:./FreeRTOS/queue.c ****     uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2141:./FreeRTOS/queue.c ****     {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 39


2142:./FreeRTOS/queue.c ****         return ( ( Queue_t * ) xQueue )->ucQueueType;
2143:./FreeRTOS/queue.c ****     }
2144:./FreeRTOS/queue.c **** 
2145:./FreeRTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2146:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2147:./FreeRTOS/queue.c **** 
2148:./FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
2149:./FreeRTOS/queue.c **** 
2150:./FreeRTOS/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2151:./FreeRTOS/queue.c ****     {
  27              		.loc 1 2151 5 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              		.loc 1 2151 5 is_stmt 0 view .LVU1
  33 0000 0346     		mov	r3, r0
2152:./FreeRTOS/queue.c ****         UBaseType_t uxHighestPriorityOfWaitingTasks;
  34              		.loc 1 2152 9 is_stmt 1 view .LVU2
2153:./FreeRTOS/queue.c **** 
2154:./FreeRTOS/queue.c ****         /* If a task waiting for a mutex causes the mutex holder to inherit a
2155:./FreeRTOS/queue.c ****          * priority, but the waiting task times out, then the holder should
2156:./FreeRTOS/queue.c ****          * disinherit the priority - but only down to the highest priority of any
2157:./FreeRTOS/queue.c ****          * other tasks that are waiting for the same mutex.  For this purpose,
2158:./FreeRTOS/queue.c ****          * return the priority of the highest priority task that is waiting for the
2159:./FreeRTOS/queue.c ****          * mutex. */
2160:./FreeRTOS/queue.c ****         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
  35              		.loc 1 2160 9 view .LVU3
  36              		.loc 1 2160 13 is_stmt 0 view .LVU4
  37 0002 406A     		ldr	r0, [r0, #36]
  38              	.LVL1:
  39              		.loc 1 2160 11 view .LVU5
  40 0004 18B1     		cbz	r0, .L1
2161:./FreeRTOS/queue.c ****         {
2162:./FreeRTOS/queue.c ****             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t 
  41              		.loc 1 2162 13 is_stmt 1 view .LVU6
  42              		.loc 1 2162 102 is_stmt 0 view .LVU7
  43 0006 1B6B     		ldr	r3, [r3, #48]
  44              	.LVL2:
  45              		.loc 1 2162 102 view .LVU8
  46 0008 1868     		ldr	r0, [r3]
  47              		.loc 1 2162 45 view .LVU9
  48 000a C0F12000 		rsb	r0, r0, #32
  49              	.LVL3:
2163:./FreeRTOS/queue.c ****         }
2164:./FreeRTOS/queue.c ****         else
2165:./FreeRTOS/queue.c ****         {
2166:./FreeRTOS/queue.c ****             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2167:./FreeRTOS/queue.c ****         }
2168:./FreeRTOS/queue.c **** 
2169:./FreeRTOS/queue.c ****         return uxHighestPriorityOfWaitingTasks;
  50              		.loc 1 2169 9 is_stmt 1 view .LVU10
  51              	.L1:
2170:./FreeRTOS/queue.c ****     }
  52              		.loc 1 2170 5 is_stmt 0 view .LVU11
  53 000e 7047     		bx	lr
  54              		.cfi_endproc
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 40


  55              	.LFE51:
  57              		.section	.text.prvIsQueueFull,"ax",%progbits
  58              		.align	1
  59              		.syntax unified
  60              		.thumb
  61              		.thumb_func
  63              	prvIsQueueFull:
  64              	.LVL4:
  65              	.LFB57:
2171:./FreeRTOS/queue.c **** 
2172:./FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
2173:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2174:./FreeRTOS/queue.c **** 
2175:./FreeRTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
2176:./FreeRTOS/queue.c ****                                       const void * pvItemToQueue,
2177:./FreeRTOS/queue.c ****                                       const BaseType_t xPosition )
2178:./FreeRTOS/queue.c **** {
2179:./FreeRTOS/queue.c ****     BaseType_t xReturn = pdFALSE;
2180:./FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
2181:./FreeRTOS/queue.c **** 
2182:./FreeRTOS/queue.c ****     /* This function is called from a critical section. */
2183:./FreeRTOS/queue.c **** 
2184:./FreeRTOS/queue.c ****     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2185:./FreeRTOS/queue.c **** 
2186:./FreeRTOS/queue.c ****     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2187:./FreeRTOS/queue.c ****     {
2188:./FreeRTOS/queue.c ****         #if ( configUSE_MUTEXES == 1 )
2189:./FreeRTOS/queue.c ****         {
2190:./FreeRTOS/queue.c ****             if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2191:./FreeRTOS/queue.c ****             {
2192:./FreeRTOS/queue.c ****                 /* The mutex is no longer being held. */
2193:./FreeRTOS/queue.c ****                 xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2194:./FreeRTOS/queue.c ****                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
2195:./FreeRTOS/queue.c ****             }
2196:./FreeRTOS/queue.c ****             else
2197:./FreeRTOS/queue.c ****             {
2198:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2199:./FreeRTOS/queue.c ****             }
2200:./FreeRTOS/queue.c ****         }
2201:./FreeRTOS/queue.c ****         #endif /* configUSE_MUTEXES */
2202:./FreeRTOS/queue.c ****     }
2203:./FreeRTOS/queue.c ****     else if( xPosition == queueSEND_TO_BACK )
2204:./FreeRTOS/queue.c ****     {
2205:./FreeRTOS/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSi
2206:./FreeRTOS/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
2207:./FreeRTOS/queue.c **** 
2208:./FreeRTOS/queue.c ****         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                       
2209:./FreeRTOS/queue.c ****         {
2210:./FreeRTOS/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
2211:./FreeRTOS/queue.c ****         }
2212:./FreeRTOS/queue.c ****         else
2213:./FreeRTOS/queue.c ****         {
2214:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2215:./FreeRTOS/queue.c ****         }
2216:./FreeRTOS/queue.c ****     }
2217:./FreeRTOS/queue.c ****     else
2218:./FreeRTOS/queue.c ****     {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 41


2219:./FreeRTOS/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue
2220:./FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
2221:./FreeRTOS/queue.c **** 
2222:./FreeRTOS/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified
2223:./FreeRTOS/queue.c ****         {
2224:./FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
2225:./FreeRTOS/queue.c ****         }
2226:./FreeRTOS/queue.c ****         else
2227:./FreeRTOS/queue.c ****         {
2228:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2229:./FreeRTOS/queue.c ****         }
2230:./FreeRTOS/queue.c **** 
2231:./FreeRTOS/queue.c ****         if( xPosition == queueOVERWRITE )
2232:./FreeRTOS/queue.c ****         {
2233:./FreeRTOS/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2234:./FreeRTOS/queue.c ****             {
2235:./FreeRTOS/queue.c ****                 /* An item is not being added but overwritten, so subtract
2236:./FreeRTOS/queue.c ****                  * one from the recorded number of items in the queue so when
2237:./FreeRTOS/queue.c ****                  * one is added again below the number of recorded items remains
2238:./FreeRTOS/queue.c ****                  * correct. */
2239:./FreeRTOS/queue.c ****                 --uxMessagesWaiting;
2240:./FreeRTOS/queue.c ****             }
2241:./FreeRTOS/queue.c ****             else
2242:./FreeRTOS/queue.c ****             {
2243:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2244:./FreeRTOS/queue.c ****             }
2245:./FreeRTOS/queue.c ****         }
2246:./FreeRTOS/queue.c ****         else
2247:./FreeRTOS/queue.c ****         {
2248:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2249:./FreeRTOS/queue.c ****         }
2250:./FreeRTOS/queue.c ****     }
2251:./FreeRTOS/queue.c **** 
2252:./FreeRTOS/queue.c ****     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2253:./FreeRTOS/queue.c **** 
2254:./FreeRTOS/queue.c ****     return xReturn;
2255:./FreeRTOS/queue.c **** }
2256:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2257:./FreeRTOS/queue.c **** 
2258:./FreeRTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
2259:./FreeRTOS/queue.c ****                                   void * const pvBuffer )
2260:./FreeRTOS/queue.c **** {
2261:./FreeRTOS/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2262:./FreeRTOS/queue.c ****     {
2263:./FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithm
2264:./FreeRTOS/queue.c **** 
2265:./FreeRTOS/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception
2266:./FreeRTOS/queue.c ****         {
2267:./FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2268:./FreeRTOS/queue.c ****         }
2269:./FreeRTOS/queue.c ****         else
2270:./FreeRTOS/queue.c ****         {
2271:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2272:./FreeRTOS/queue.c ****         }
2273:./FreeRTOS/queue.c **** 
2274:./FreeRTOS/queue.c ****         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) p
2275:./FreeRTOS/queue.c ****     }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 42


2276:./FreeRTOS/queue.c **** }
2277:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2278:./FreeRTOS/queue.c **** 
2279:./FreeRTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2280:./FreeRTOS/queue.c **** {
2281:./FreeRTOS/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2282:./FreeRTOS/queue.c **** 
2283:./FreeRTOS/queue.c ****     /* The lock counts contains the number of extra data items placed or
2284:./FreeRTOS/queue.c ****      * removed from the queue while the queue was locked.  When a queue is
2285:./FreeRTOS/queue.c ****      * locked items can be added or removed, but the event lists cannot be
2286:./FreeRTOS/queue.c ****      * updated. */
2287:./FreeRTOS/queue.c ****     taskENTER_CRITICAL();
2288:./FreeRTOS/queue.c ****     {
2289:./FreeRTOS/queue.c ****         int8_t cTxLock = pxQueue->cTxLock;
2290:./FreeRTOS/queue.c **** 
2291:./FreeRTOS/queue.c ****         /* See if data was added to the queue while it was locked. */
2292:./FreeRTOS/queue.c ****         while( cTxLock > queueLOCKED_UNMODIFIED )
2293:./FreeRTOS/queue.c ****         {
2294:./FreeRTOS/queue.c ****             /* Data was posted while the queue was locked.  Are any tasks
2295:./FreeRTOS/queue.c ****              * blocked waiting for data to become available? */
2296:./FreeRTOS/queue.c ****             #if ( configUSE_QUEUE_SETS == 1 )
2297:./FreeRTOS/queue.c ****             {
2298:./FreeRTOS/queue.c ****                 if( pxQueue->pxQueueSetContainer != NULL )
2299:./FreeRTOS/queue.c ****                 {
2300:./FreeRTOS/queue.c ****                     if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2301:./FreeRTOS/queue.c ****                     {
2302:./FreeRTOS/queue.c ****                         /* The queue is a member of a queue set, and posting to
2303:./FreeRTOS/queue.c ****                          * the queue set caused a higher priority task to unblock.
2304:./FreeRTOS/queue.c ****                          * A context switch is required. */
2305:./FreeRTOS/queue.c ****                         vTaskMissedYield();
2306:./FreeRTOS/queue.c ****                     }
2307:./FreeRTOS/queue.c ****                     else
2308:./FreeRTOS/queue.c ****                     {
2309:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2310:./FreeRTOS/queue.c ****                     }
2311:./FreeRTOS/queue.c ****                 }
2312:./FreeRTOS/queue.c ****                 else
2313:./FreeRTOS/queue.c ****                 {
2314:./FreeRTOS/queue.c ****                     /* Tasks that are removed from the event list will get
2315:./FreeRTOS/queue.c ****                      * added to the pending ready list as the scheduler is still
2316:./FreeRTOS/queue.c ****                      * suspended. */
2317:./FreeRTOS/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2318:./FreeRTOS/queue.c ****                     {
2319:./FreeRTOS/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
2320:./FreeRTOS/queue.c ****                         {
2321:./FreeRTOS/queue.c ****                             /* The task waiting has a higher priority so record that a
2322:./FreeRTOS/queue.c ****                              * context switch is required. */
2323:./FreeRTOS/queue.c ****                             vTaskMissedYield();
2324:./FreeRTOS/queue.c ****                         }
2325:./FreeRTOS/queue.c ****                         else
2326:./FreeRTOS/queue.c ****                         {
2327:./FreeRTOS/queue.c ****                             mtCOVERAGE_TEST_MARKER();
2328:./FreeRTOS/queue.c ****                         }
2329:./FreeRTOS/queue.c ****                     }
2330:./FreeRTOS/queue.c ****                     else
2331:./FreeRTOS/queue.c ****                     {
2332:./FreeRTOS/queue.c ****                         break;
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 43


2333:./FreeRTOS/queue.c ****                     }
2334:./FreeRTOS/queue.c ****                 }
2335:./FreeRTOS/queue.c ****             }
2336:./FreeRTOS/queue.c ****             #else /* configUSE_QUEUE_SETS */
2337:./FreeRTOS/queue.c ****             {
2338:./FreeRTOS/queue.c ****                 /* Tasks that are removed from the event list will get added to
2339:./FreeRTOS/queue.c ****                  * the pending ready list as the scheduler is still suspended. */
2340:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2341:./FreeRTOS/queue.c ****                 {
2342:./FreeRTOS/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE
2343:./FreeRTOS/queue.c ****                     {
2344:./FreeRTOS/queue.c ****                         /* The task waiting has a higher priority so record that
2345:./FreeRTOS/queue.c ****                          * a context switch is required. */
2346:./FreeRTOS/queue.c ****                         vTaskMissedYield();
2347:./FreeRTOS/queue.c ****                     }
2348:./FreeRTOS/queue.c ****                     else
2349:./FreeRTOS/queue.c ****                     {
2350:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2351:./FreeRTOS/queue.c ****                     }
2352:./FreeRTOS/queue.c ****                 }
2353:./FreeRTOS/queue.c ****                 else
2354:./FreeRTOS/queue.c ****                 {
2355:./FreeRTOS/queue.c ****                     break;
2356:./FreeRTOS/queue.c ****                 }
2357:./FreeRTOS/queue.c ****             }
2358:./FreeRTOS/queue.c ****             #endif /* configUSE_QUEUE_SETS */
2359:./FreeRTOS/queue.c **** 
2360:./FreeRTOS/queue.c ****             --cTxLock;
2361:./FreeRTOS/queue.c ****         }
2362:./FreeRTOS/queue.c **** 
2363:./FreeRTOS/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
2364:./FreeRTOS/queue.c ****     }
2365:./FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
2366:./FreeRTOS/queue.c **** 
2367:./FreeRTOS/queue.c ****     /* Do the same for the Rx lock. */
2368:./FreeRTOS/queue.c ****     taskENTER_CRITICAL();
2369:./FreeRTOS/queue.c ****     {
2370:./FreeRTOS/queue.c ****         int8_t cRxLock = pxQueue->cRxLock;
2371:./FreeRTOS/queue.c **** 
2372:./FreeRTOS/queue.c ****         while( cRxLock > queueLOCKED_UNMODIFIED )
2373:./FreeRTOS/queue.c ****         {
2374:./FreeRTOS/queue.c ****             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2375:./FreeRTOS/queue.c ****             {
2376:./FreeRTOS/queue.c ****                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2377:./FreeRTOS/queue.c ****                 {
2378:./FreeRTOS/queue.c ****                     vTaskMissedYield();
2379:./FreeRTOS/queue.c ****                 }
2380:./FreeRTOS/queue.c ****                 else
2381:./FreeRTOS/queue.c ****                 {
2382:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2383:./FreeRTOS/queue.c ****                 }
2384:./FreeRTOS/queue.c **** 
2385:./FreeRTOS/queue.c ****                 --cRxLock;
2386:./FreeRTOS/queue.c ****             }
2387:./FreeRTOS/queue.c ****             else
2388:./FreeRTOS/queue.c ****             {
2389:./FreeRTOS/queue.c ****                 break;
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 44


2390:./FreeRTOS/queue.c ****             }
2391:./FreeRTOS/queue.c ****         }
2392:./FreeRTOS/queue.c **** 
2393:./FreeRTOS/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
2394:./FreeRTOS/queue.c ****     }
2395:./FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
2396:./FreeRTOS/queue.c **** }
2397:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2398:./FreeRTOS/queue.c **** 
2399:./FreeRTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
2400:./FreeRTOS/queue.c **** {
2401:./FreeRTOS/queue.c ****     BaseType_t xReturn;
2402:./FreeRTOS/queue.c **** 
2403:./FreeRTOS/queue.c ****     taskENTER_CRITICAL();
2404:./FreeRTOS/queue.c ****     {
2405:./FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2406:./FreeRTOS/queue.c ****         {
2407:./FreeRTOS/queue.c ****             xReturn = pdTRUE;
2408:./FreeRTOS/queue.c ****         }
2409:./FreeRTOS/queue.c ****         else
2410:./FreeRTOS/queue.c ****         {
2411:./FreeRTOS/queue.c ****             xReturn = pdFALSE;
2412:./FreeRTOS/queue.c ****         }
2413:./FreeRTOS/queue.c ****     }
2414:./FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
2415:./FreeRTOS/queue.c **** 
2416:./FreeRTOS/queue.c ****     return xReturn;
2417:./FreeRTOS/queue.c **** }
2418:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2419:./FreeRTOS/queue.c **** 
2420:./FreeRTOS/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2421:./FreeRTOS/queue.c **** {
2422:./FreeRTOS/queue.c ****     BaseType_t xReturn;
2423:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
2424:./FreeRTOS/queue.c **** 
2425:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
2426:./FreeRTOS/queue.c **** 
2427:./FreeRTOS/queue.c ****     if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2428:./FreeRTOS/queue.c ****     {
2429:./FreeRTOS/queue.c ****         xReturn = pdTRUE;
2430:./FreeRTOS/queue.c ****     }
2431:./FreeRTOS/queue.c ****     else
2432:./FreeRTOS/queue.c ****     {
2433:./FreeRTOS/queue.c ****         xReturn = pdFALSE;
2434:./FreeRTOS/queue.c ****     }
2435:./FreeRTOS/queue.c **** 
2436:./FreeRTOS/queue.c ****     return xReturn;
2437:./FreeRTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2438:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2439:./FreeRTOS/queue.c **** 
2440:./FreeRTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
2441:./FreeRTOS/queue.c **** {
  66              		.loc 1 2441 1 is_stmt 1 view -0
  67              		.cfi_startproc
  68              		@ args = 0, pretend = 0, frame = 0
  69              		@ frame_needed = 0, uses_anonymous_args = 0
  70              		.loc 1 2441 1 is_stmt 0 view .LVU13
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 45


  71 0000 10B5     		push	{r4, lr}
  72              	.LCFI0:
  73              		.cfi_def_cfa_offset 8
  74              		.cfi_offset 4, -8
  75              		.cfi_offset 14, -4
  76 0002 0446     		mov	r4, r0
2442:./FreeRTOS/queue.c ****     BaseType_t xReturn;
  77              		.loc 1 2442 5 is_stmt 1 view .LVU14
2443:./FreeRTOS/queue.c **** 
2444:./FreeRTOS/queue.c ****     taskENTER_CRITICAL();
  78              		.loc 1 2444 5 view .LVU15
  79 0004 FFF7FEFF 		bl	vPortEnterCritical
  80              	.LVL5:
2445:./FreeRTOS/queue.c ****     {
2446:./FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  81              		.loc 1 2446 9 view .LVU16
  82              		.loc 1 2446 20 is_stmt 0 view .LVU17
  83 0008 A26B     		ldr	r2, [r4, #56]
  84              		.loc 1 2446 50 view .LVU18
  85 000a E36B     		ldr	r3, [r4, #60]
  86              		.loc 1 2446 11 view .LVU19
  87 000c 9A42     		cmp	r2, r3
  88 000e 04D0     		beq	.L7
2447:./FreeRTOS/queue.c ****         {
2448:./FreeRTOS/queue.c ****             xReturn = pdTRUE;
2449:./FreeRTOS/queue.c ****         }
2450:./FreeRTOS/queue.c ****         else
2451:./FreeRTOS/queue.c ****         {
2452:./FreeRTOS/queue.c ****             xReturn = pdFALSE;
  89              		.loc 1 2452 21 view .LVU20
  90 0010 0024     		movs	r4, #0
  91              	.LVL6:
  92              	.L4:
2453:./FreeRTOS/queue.c ****         }
2454:./FreeRTOS/queue.c ****     }
2455:./FreeRTOS/queue.c ****     taskEXIT_CRITICAL();
  93              		.loc 1 2455 5 is_stmt 1 view .LVU21
  94 0012 FFF7FEFF 		bl	vPortExitCritical
  95              	.LVL7:
2456:./FreeRTOS/queue.c **** 
2457:./FreeRTOS/queue.c ****     return xReturn;
  96              		.loc 1 2457 5 view .LVU22
2458:./FreeRTOS/queue.c **** }
  97              		.loc 1 2458 1 is_stmt 0 view .LVU23
  98 0016 2046     		mov	r0, r4
  99 0018 10BD     		pop	{r4, pc}
 100              	.LVL8:
 101              	.L7:
2448:./FreeRTOS/queue.c ****         }
 102              		.loc 1 2448 21 view .LVU24
 103 001a 0124     		movs	r4, #1
 104              	.LVL9:
2448:./FreeRTOS/queue.c ****         }
 105              		.loc 1 2448 21 view .LVU25
 106 001c F9E7     		b	.L4
 107              		.cfi_endproc
 108              	.LFE57:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 46


 110              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 111              		.align	1
 112              		.syntax unified
 113              		.thumb
 114              		.thumb_func
 116              	prvIsQueueEmpty:
 117              	.LVL10:
 118              	.LFB55:
2400:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 119              		.loc 1 2400 1 is_stmt 1 view -0
 120              		.cfi_startproc
 121              		@ args = 0, pretend = 0, frame = 0
 122              		@ frame_needed = 0, uses_anonymous_args = 0
2400:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 123              		.loc 1 2400 1 is_stmt 0 view .LVU27
 124 0000 10B5     		push	{r4, lr}
 125              	.LCFI1:
 126              		.cfi_def_cfa_offset 8
 127              		.cfi_offset 4, -8
 128              		.cfi_offset 14, -4
 129 0002 0446     		mov	r4, r0
2401:./FreeRTOS/queue.c **** 
 130              		.loc 1 2401 5 is_stmt 1 view .LVU28
2403:./FreeRTOS/queue.c ****     {
 131              		.loc 1 2403 5 view .LVU29
 132 0004 FFF7FEFF 		bl	vPortEnterCritical
 133              	.LVL11:
2405:./FreeRTOS/queue.c ****         {
 134              		.loc 1 2405 9 view .LVU30
2405:./FreeRTOS/queue.c ****         {
 135              		.loc 1 2405 20 is_stmt 0 view .LVU31
 136 0008 A36B     		ldr	r3, [r4, #56]
2405:./FreeRTOS/queue.c ****         {
 137              		.loc 1 2405 11 view .LVU32
 138 000a 23B9     		cbnz	r3, .L10
2407:./FreeRTOS/queue.c ****         }
 139              		.loc 1 2407 21 view .LVU33
 140 000c 0124     		movs	r4, #1
 141              	.LVL12:
 142              	.L9:
2414:./FreeRTOS/queue.c **** 
 143              		.loc 1 2414 5 is_stmt 1 view .LVU34
 144 000e FFF7FEFF 		bl	vPortExitCritical
 145              	.LVL13:
2416:./FreeRTOS/queue.c **** }
 146              		.loc 1 2416 5 view .LVU35
2417:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 147              		.loc 1 2417 1 is_stmt 0 view .LVU36
 148 0012 2046     		mov	r0, r4
 149 0014 10BD     		pop	{r4, pc}
 150              	.LVL14:
 151              	.L10:
2411:./FreeRTOS/queue.c ****         }
 152              		.loc 1 2411 21 view .LVU37
 153 0016 0024     		movs	r4, #0
 154              	.LVL15:
2411:./FreeRTOS/queue.c ****         }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 47


 155              		.loc 1 2411 21 view .LVU38
 156 0018 F9E7     		b	.L9
 157              		.cfi_endproc
 158              	.LFE55:
 160              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 161              		.align	1
 162              		.syntax unified
 163              		.thumb
 164              		.thumb_func
 166              	prvCopyDataToQueue:
 167              	.LVL16:
 168              	.LFB52:
2178:./FreeRTOS/queue.c ****     BaseType_t xReturn = pdFALSE;
 169              		.loc 1 2178 1 is_stmt 1 view -0
 170              		.cfi_startproc
 171              		@ args = 0, pretend = 0, frame = 0
 172              		@ frame_needed = 0, uses_anonymous_args = 0
2178:./FreeRTOS/queue.c ****     BaseType_t xReturn = pdFALSE;
 173              		.loc 1 2178 1 is_stmt 0 view .LVU40
 174 0000 70B5     		push	{r4, r5, r6, lr}
 175              	.LCFI2:
 176              		.cfi_def_cfa_offset 16
 177              		.cfi_offset 4, -16
 178              		.cfi_offset 5, -12
 179              		.cfi_offset 6, -8
 180              		.cfi_offset 14, -4
 181 0002 0446     		mov	r4, r0
 182 0004 1546     		mov	r5, r2
2179:./FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 183              		.loc 1 2179 5 is_stmt 1 view .LVU41
 184              	.LVL17:
2180:./FreeRTOS/queue.c **** 
 185              		.loc 1 2180 5 view .LVU42
2184:./FreeRTOS/queue.c **** 
 186              		.loc 1 2184 5 view .LVU43
2184:./FreeRTOS/queue.c **** 
 187              		.loc 1 2184 23 is_stmt 0 view .LVU44
 188 0006 866B     		ldr	r6, [r0, #56]
 189              	.LVL18:
2186:./FreeRTOS/queue.c ****     {
 190              		.loc 1 2186 5 is_stmt 1 view .LVU45
2186:./FreeRTOS/queue.c ****     {
 191              		.loc 1 2186 16 is_stmt 0 view .LVU46
 192 0008 026C     		ldr	r2, [r0, #64]
 193              	.LVL19:
2186:./FreeRTOS/queue.c ****     {
 194              		.loc 1 2186 7 view .LVU47
 195 000a 5AB9     		cbnz	r2, .L13
2190:./FreeRTOS/queue.c ****             {
 196              		.loc 1 2190 13 is_stmt 1 view .LVU48
2190:./FreeRTOS/queue.c ****             {
 197              		.loc 1 2190 24 is_stmt 0 view .LVU49
 198 000c 0368     		ldr	r3, [r0]
2190:./FreeRTOS/queue.c ****             {
 199              		.loc 1 2190 15 view .LVU50
 200 000e 1BB1     		cbz	r3, .L22
2179:./FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 48


 201              		.loc 1 2179 16 view .LVU51
 202 0010 0020     		movs	r0, #0
 203              	.LVL20:
 204              	.L14:
2248:./FreeRTOS/queue.c ****         }
 205              		.loc 1 2248 37 is_stmt 1 view .LVU52
2252:./FreeRTOS/queue.c **** 
 206              		.loc 1 2252 5 view .LVU53
2252:./FreeRTOS/queue.c **** 
 207              		.loc 1 2252 52 is_stmt 0 view .LVU54
 208 0012 0136     		adds	r6, r6, #1
 209              	.LVL21:
2252:./FreeRTOS/queue.c **** 
 210              		.loc 1 2252 32 view .LVU55
 211 0014 A663     		str	r6, [r4, #56]
2254:./FreeRTOS/queue.c **** }
 212              		.loc 1 2254 5 is_stmt 1 view .LVU56
2255:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 213              		.loc 1 2255 1 is_stmt 0 view .LVU57
 214 0016 70BD     		pop	{r4, r5, r6, pc}
 215              	.LVL22:
 216              	.L22:
2193:./FreeRTOS/queue.c ****                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
 217              		.loc 1 2193 17 is_stmt 1 view .LVU58
2193:./FreeRTOS/queue.c ****                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
 218              		.loc 1 2193 27 is_stmt 0 view .LVU59
 219 0018 8068     		ldr	r0, [r0, #8]
 220              	.LVL23:
2193:./FreeRTOS/queue.c ****                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
 221              		.loc 1 2193 27 view .LVU60
 222 001a FFF7FEFF 		bl	xTaskPriorityDisinherit
 223              	.LVL24:
2194:./FreeRTOS/queue.c ****             }
 224              		.loc 1 2194 17 is_stmt 1 view .LVU61
2194:./FreeRTOS/queue.c ****             }
 225              		.loc 1 2194 52 is_stmt 0 view .LVU62
 226 001e 0023     		movs	r3, #0
 227 0020 A360     		str	r3, [r4, #8]
 228 0022 F6E7     		b	.L14
 229              	.LVL25:
 230              	.L13:
2203:./FreeRTOS/queue.c ****     {
 231              		.loc 1 2203 10 is_stmt 1 view .LVU63
2203:./FreeRTOS/queue.c ****     {
 232              		.loc 1 2203 12 is_stmt 0 view .LVU64
 233 0024 6DB9     		cbnz	r5, .L15
2205:./FreeRTOS/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 234              		.loc 1 2205 9 is_stmt 1 view .LVU65
2205:./FreeRTOS/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 235              		.loc 1 2205 18 is_stmt 0 view .LVU66
 236 0026 4068     		ldr	r0, [r0, #4]
 237              	.LVL26:
2205:./FreeRTOS/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 238              		.loc 1 2205 18 view .LVU67
 239 0028 FFF7FEFF 		bl	memcpy
 240              	.LVL27:
2206:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 49


 241              		.loc 1 2206 9 is_stmt 1 view .LVU68
2206:./FreeRTOS/queue.c **** 
 242              		.loc 1 2206 16 is_stmt 0 view .LVU69
 243 002c 6368     		ldr	r3, [r4, #4]
2206:./FreeRTOS/queue.c **** 
 244              		.loc 1 2206 38 view .LVU70
 245 002e 226C     		ldr	r2, [r4, #64]
2206:./FreeRTOS/queue.c **** 
 246              		.loc 1 2206 28 view .LVU71
 247 0030 1344     		add	r3, r3, r2
 248 0032 6360     		str	r3, [r4, #4]
2208:./FreeRTOS/queue.c ****         {
 249              		.loc 1 2208 9 is_stmt 1 view .LVU72
2208:./FreeRTOS/queue.c ****         {
 250              		.loc 1 2208 52 is_stmt 0 view .LVU73
 251 0034 A268     		ldr	r2, [r4, #8]
2208:./FreeRTOS/queue.c ****         {
 252              		.loc 1 2208 11 view .LVU74
 253 0036 9342     		cmp	r3, r2
 254 0038 19D3     		bcc	.L18
2210:./FreeRTOS/queue.c ****         }
 255              		.loc 1 2210 13 is_stmt 1 view .LVU75
2210:./FreeRTOS/queue.c ****         }
 256              		.loc 1 2210 41 is_stmt 0 view .LVU76
 257 003a 2368     		ldr	r3, [r4]
2210:./FreeRTOS/queue.c ****         }
 258              		.loc 1 2210 32 view .LVU77
 259 003c 6360     		str	r3, [r4, #4]
2179:./FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 260              		.loc 1 2179 16 view .LVU78
 261 003e 2846     		mov	r0, r5
 262 0040 E7E7     		b	.L14
 263              	.LVL28:
 264              	.L15:
2219:./FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 265              		.loc 1 2219 9 is_stmt 1 view .LVU79
2219:./FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 266              		.loc 1 2219 18 is_stmt 0 view .LVU80
 267 0042 C068     		ldr	r0, [r0, #12]
 268              	.LVL29:
2219:./FreeRTOS/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 269              		.loc 1 2219 18 view .LVU81
 270 0044 FFF7FEFF 		bl	memcpy
 271              	.LVL30:
2220:./FreeRTOS/queue.c **** 
 272              		.loc 1 2220 9 is_stmt 1 view .LVU82
2220:./FreeRTOS/queue.c **** 
 273              		.loc 1 2220 26 is_stmt 0 view .LVU83
 274 0048 E368     		ldr	r3, [r4, #12]
2220:./FreeRTOS/queue.c **** 
 275              		.loc 1 2220 48 view .LVU84
 276 004a 226C     		ldr	r2, [r4, #64]
2220:./FreeRTOS/queue.c **** 
 277              		.loc 1 2220 38 view .LVU85
 278 004c 5142     		rsbs	r1, r2, #0
 279 004e 9B1A     		subs	r3, r3, r2
 280 0050 E360     		str	r3, [r4, #12]
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 50


2222:./FreeRTOS/queue.c ****         {
 281              		.loc 1 2222 9 is_stmt 1 view .LVU86
2222:./FreeRTOS/queue.c ****         {
 282              		.loc 1 2222 51 is_stmt 0 view .LVU87
 283 0052 2268     		ldr	r2, [r4]
2222:./FreeRTOS/queue.c ****         {
 284              		.loc 1 2222 11 view .LVU88
 285 0054 9342     		cmp	r3, r2
 286 0056 02D2     		bcs	.L16
2224:./FreeRTOS/queue.c ****         }
 287              		.loc 1 2224 13 is_stmt 1 view .LVU89
2224:./FreeRTOS/queue.c ****         }
 288              		.loc 1 2224 63 is_stmt 0 view .LVU90
 289 0058 A368     		ldr	r3, [r4, #8]
2224:./FreeRTOS/queue.c ****         }
 290              		.loc 1 2224 71 view .LVU91
 291 005a 0B44     		add	r3, r3, r1
2224:./FreeRTOS/queue.c ****         }
 292              		.loc 1 2224 42 view .LVU92
 293 005c E360     		str	r3, [r4, #12]
 294              	.L16:
2228:./FreeRTOS/queue.c ****         }
 295              		.loc 1 2228 37 is_stmt 1 view .LVU93
2231:./FreeRTOS/queue.c ****         {
 296              		.loc 1 2231 9 view .LVU94
2231:./FreeRTOS/queue.c ****         {
 297              		.loc 1 2231 11 is_stmt 0 view .LVU95
 298 005e 022D     		cmp	r5, #2
 299 0060 01D0     		beq	.L23
2179:./FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 300              		.loc 1 2179 16 view .LVU96
 301 0062 0020     		movs	r0, #0
 302 0064 D5E7     		b	.L14
 303              	.L23:
2233:./FreeRTOS/queue.c ****             {
 304              		.loc 1 2233 13 is_stmt 1 view .LVU97
2233:./FreeRTOS/queue.c ****             {
 305              		.loc 1 2233 15 is_stmt 0 view .LVU98
 306 0066 26B1     		cbz	r6, .L20
2239:./FreeRTOS/queue.c ****             }
 307              		.loc 1 2239 17 is_stmt 1 view .LVU99
 308 0068 013E     		subs	r6, r6, #1
 309              	.LVL31:
2179:./FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 310              		.loc 1 2179 16 is_stmt 0 view .LVU100
 311 006a 0020     		movs	r0, #0
 312 006c D1E7     		b	.L14
 313              	.L18:
2179:./FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 314              		.loc 1 2179 16 view .LVU101
 315 006e 2846     		mov	r0, r5
 316 0070 CFE7     		b	.L14
 317              	.L20:
2179:./FreeRTOS/queue.c ****     UBaseType_t uxMessagesWaiting;
 318              		.loc 1 2179 16 view .LVU102
 319 0072 0020     		movs	r0, #0
 320 0074 CDE7     		b	.L14
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 51


 321              		.cfi_endproc
 322              	.LFE52:
 324              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 325              		.align	1
 326              		.syntax unified
 327              		.thumb
 328              		.thumb_func
 330              	prvCopyDataFromQueue:
 331              	.LVL32:
 332              	.LFB53:
2260:./FreeRTOS/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 333              		.loc 1 2260 1 is_stmt 1 view -0
 334              		.cfi_startproc
 335              		@ args = 0, pretend = 0, frame = 0
 336              		@ frame_needed = 0, uses_anonymous_args = 0
2260:./FreeRTOS/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 337              		.loc 1 2260 1 is_stmt 0 view .LVU104
 338 0000 08B5     		push	{r3, lr}
 339              	.LCFI3:
 340              		.cfi_def_cfa_offset 8
 341              		.cfi_offset 3, -8
 342              		.cfi_offset 14, -4
 343 0002 0346     		mov	r3, r0
2261:./FreeRTOS/queue.c ****     {
 344              		.loc 1 2261 5 is_stmt 1 view .LVU105
2261:./FreeRTOS/queue.c ****     {
 345              		.loc 1 2261 16 is_stmt 0 view .LVU106
 346 0004 026C     		ldr	r2, [r0, #64]
2261:./FreeRTOS/queue.c ****     {
 347              		.loc 1 2261 7 view .LVU107
 348 0006 62B1     		cbz	r2, .L24
 349 0008 0846     		mov	r0, r1
 350              	.LVL33:
2263:./FreeRTOS/queue.c **** 
 351              		.loc 1 2263 9 is_stmt 1 view .LVU108
2263:./FreeRTOS/queue.c **** 
 352              		.loc 1 2263 26 is_stmt 0 view .LVU109
 353 000a D968     		ldr	r1, [r3, #12]
 354              	.LVL34:
2263:./FreeRTOS/queue.c **** 
 355              		.loc 1 2263 38 view .LVU110
 356 000c 1144     		add	r1, r1, r2
 357 000e D960     		str	r1, [r3, #12]
2265:./FreeRTOS/queue.c ****         {
 358              		.loc 1 2265 9 is_stmt 1 view .LVU111
2265:./FreeRTOS/queue.c ****         {
 359              		.loc 1 2265 11 is_stmt 0 view .LVU112
 360 0010 D3F808C0 		ldr	ip, [r3, #8]
 361 0014 6145     		cmp	r1, ip
 362 0016 01D3     		bcc	.L26
2267:./FreeRTOS/queue.c ****         }
 363              		.loc 1 2267 13 is_stmt 1 view .LVU113
2267:./FreeRTOS/queue.c ****         }
 364              		.loc 1 2267 51 is_stmt 0 view .LVU114
 365 0018 1968     		ldr	r1, [r3]
2267:./FreeRTOS/queue.c ****         }
 366              		.loc 1 2267 42 view .LVU115
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 52


 367 001a D960     		str	r1, [r3, #12]
 368              	.L26:
2271:./FreeRTOS/queue.c ****         }
 369              		.loc 1 2271 37 is_stmt 1 view .LVU116
2274:./FreeRTOS/queue.c ****     }
 370              		.loc 1 2274 9 view .LVU117
2274:./FreeRTOS/queue.c ****     }
 371              		.loc 1 2274 18 is_stmt 0 view .LVU118
 372 001c D968     		ldr	r1, [r3, #12]
 373 001e FFF7FEFF 		bl	memcpy
 374              	.LVL35:
 375              	.L24:
2276:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 376              		.loc 1 2276 1 view .LVU119
 377 0022 08BD     		pop	{r3, pc}
 378              		.cfi_endproc
 379              	.LFE53:
 381              		.section	.text.prvUnlockQueue,"ax",%progbits
 382              		.align	1
 383              		.syntax unified
 384              		.thumb
 385              		.thumb_func
 387              	prvUnlockQueue:
 388              	.LVL36:
 389              	.LFB54:
2280:./FreeRTOS/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 390              		.loc 1 2280 1 is_stmt 1 view -0
 391              		.cfi_startproc
 392              		@ args = 0, pretend = 0, frame = 0
 393              		@ frame_needed = 0, uses_anonymous_args = 0
2280:./FreeRTOS/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 394              		.loc 1 2280 1 is_stmt 0 view .LVU121
 395 0000 38B5     		push	{r3, r4, r5, lr}
 396              	.LCFI4:
 397              		.cfi_def_cfa_offset 16
 398              		.cfi_offset 3, -16
 399              		.cfi_offset 4, -12
 400              		.cfi_offset 5, -8
 401              		.cfi_offset 14, -4
 402 0002 0546     		mov	r5, r0
2287:./FreeRTOS/queue.c ****     {
 403              		.loc 1 2287 5 is_stmt 1 view .LVU122
 404 0004 FFF7FEFF 		bl	vPortEnterCritical
 405              	.LVL37:
 406              	.LBB26:
2289:./FreeRTOS/queue.c **** 
 407              		.loc 1 2289 9 view .LVU123
2289:./FreeRTOS/queue.c **** 
 408              		.loc 1 2289 16 is_stmt 0 view .LVU124
 409 0008 95F84540 		ldrb	r4, [r5, #69]	@ zero_extendqisi2
 410 000c 64B2     		sxtb	r4, r4
 411              	.LVL38:
2292:./FreeRTOS/queue.c ****         {
 412              		.loc 1 2292 9 is_stmt 1 view .LVU125
2292:./FreeRTOS/queue.c ****         {
 413              		.loc 1 2292 14 is_stmt 0 view .LVU126
 414 000e 01E0     		b	.L29
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 53


 415              	.L31:
2350:./FreeRTOS/queue.c ****                     }
 416              		.loc 1 2350 49 is_stmt 1 view .LVU127
2360:./FreeRTOS/queue.c ****         }
 417              		.loc 1 2360 13 view .LVU128
 418 0010 013C     		subs	r4, r4, #1
 419              	.LVL39:
2360:./FreeRTOS/queue.c ****         }
 420              		.loc 1 2360 13 is_stmt 0 view .LVU129
 421 0012 64B2     		sxtb	r4, r4
 422              	.LVL40:
 423              	.L29:
2292:./FreeRTOS/queue.c ****         {
 424              		.loc 1 2292 24 is_stmt 1 view .LVU130
 425 0014 002C     		cmp	r4, #0
 426 0016 0ADD     		ble	.L30
2340:./FreeRTOS/queue.c ****                 {
 427              		.loc 1 2340 17 view .LVU131
2340:./FreeRTOS/queue.c ****                 {
 428              		.loc 1 2340 21 is_stmt 0 view .LVU132
 429 0018 6B6A     		ldr	r3, [r5, #36]
2340:./FreeRTOS/queue.c ****                 {
 430              		.loc 1 2340 19 view .LVU133
 431 001a 43B1     		cbz	r3, .L30
2342:./FreeRTOS/queue.c ****                     {
 432              		.loc 1 2342 21 is_stmt 1 view .LVU134
2342:./FreeRTOS/queue.c ****                     {
 433              		.loc 1 2342 25 is_stmt 0 view .LVU135
 434 001c 05F12400 		add	r0, r5, #36
 435 0020 FFF7FEFF 		bl	xTaskRemoveFromEventList
 436              	.LVL41:
2342:./FreeRTOS/queue.c ****                     {
 437              		.loc 1 2342 23 view .LVU136
 438 0024 0028     		cmp	r0, #0
 439 0026 F3D0     		beq	.L31
2346:./FreeRTOS/queue.c ****                     }
 440              		.loc 1 2346 25 is_stmt 1 view .LVU137
 441 0028 FFF7FEFF 		bl	vTaskMissedYield
 442              	.LVL42:
 443 002c F0E7     		b	.L31
 444              	.L30:
2363:./FreeRTOS/queue.c ****     }
 445              		.loc 1 2363 9 view .LVU138
2363:./FreeRTOS/queue.c ****     }
 446              		.loc 1 2363 26 is_stmt 0 view .LVU139
 447 002e FF23     		movs	r3, #255
 448 0030 85F84530 		strb	r3, [r5, #69]
 449              	.LBE26:
2365:./FreeRTOS/queue.c **** 
 450              		.loc 1 2365 5 is_stmt 1 view .LVU140
 451 0034 FFF7FEFF 		bl	vPortExitCritical
 452              	.LVL43:
2368:./FreeRTOS/queue.c ****     {
 453              		.loc 1 2368 5 view .LVU141
 454 0038 FFF7FEFF 		bl	vPortEnterCritical
 455              	.LVL44:
 456              	.LBB27:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 54


2370:./FreeRTOS/queue.c **** 
 457              		.loc 1 2370 9 view .LVU142
2370:./FreeRTOS/queue.c **** 
 458              		.loc 1 2370 16 is_stmt 0 view .LVU143
 459 003c 95F84440 		ldrb	r4, [r5, #68]	@ zero_extendqisi2
 460              	.LVL45:
2370:./FreeRTOS/queue.c **** 
 461              		.loc 1 2370 16 view .LVU144
 462 0040 64B2     		sxtb	r4, r4
 463              	.LVL46:
2372:./FreeRTOS/queue.c ****         {
 464              		.loc 1 2372 9 is_stmt 1 view .LVU145
2372:./FreeRTOS/queue.c ****         {
 465              		.loc 1 2372 14 is_stmt 0 view .LVU146
 466 0042 01E0     		b	.L33
 467              	.L35:
2382:./FreeRTOS/queue.c ****                 }
 468              		.loc 1 2382 45 is_stmt 1 view .LVU147
2385:./FreeRTOS/queue.c ****             }
 469              		.loc 1 2385 17 view .LVU148
 470 0044 013C     		subs	r4, r4, #1
 471              	.LVL47:
2385:./FreeRTOS/queue.c ****             }
 472              		.loc 1 2385 17 is_stmt 0 view .LVU149
 473 0046 64B2     		sxtb	r4, r4
 474              	.LVL48:
 475              	.L33:
2372:./FreeRTOS/queue.c ****         {
 476              		.loc 1 2372 24 is_stmt 1 view .LVU150
 477 0048 002C     		cmp	r4, #0
 478 004a 0ADD     		ble	.L34
2374:./FreeRTOS/queue.c ****             {
 479              		.loc 1 2374 13 view .LVU151
2374:./FreeRTOS/queue.c ****             {
 480              		.loc 1 2374 17 is_stmt 0 view .LVU152
 481 004c 2B69     		ldr	r3, [r5, #16]
2374:./FreeRTOS/queue.c ****             {
 482              		.loc 1 2374 15 view .LVU153
 483 004e 43B1     		cbz	r3, .L34
2376:./FreeRTOS/queue.c ****                 {
 484              		.loc 1 2376 17 is_stmt 1 view .LVU154
2376:./FreeRTOS/queue.c ****                 {
 485              		.loc 1 2376 21 is_stmt 0 view .LVU155
 486 0050 05F11000 		add	r0, r5, #16
 487 0054 FFF7FEFF 		bl	xTaskRemoveFromEventList
 488              	.LVL49:
2376:./FreeRTOS/queue.c ****                 {
 489              		.loc 1 2376 19 view .LVU156
 490 0058 0028     		cmp	r0, #0
 491 005a F3D0     		beq	.L35
2378:./FreeRTOS/queue.c ****                 }
 492              		.loc 1 2378 21 is_stmt 1 view .LVU157
 493 005c FFF7FEFF 		bl	vTaskMissedYield
 494              	.LVL50:
 495 0060 F0E7     		b	.L35
 496              	.L34:
2393:./FreeRTOS/queue.c ****     }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 55


 497              		.loc 1 2393 9 view .LVU158
2393:./FreeRTOS/queue.c ****     }
 498              		.loc 1 2393 26 is_stmt 0 view .LVU159
 499 0062 FF23     		movs	r3, #255
 500 0064 85F84430 		strb	r3, [r5, #68]
 501              	.LBE27:
2395:./FreeRTOS/queue.c **** }
 502              		.loc 1 2395 5 is_stmt 1 view .LVU160
 503 0068 FFF7FEFF 		bl	vPortExitCritical
 504              	.LVL51:
2396:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 505              		.loc 1 2396 1 is_stmt 0 view .LVU161
 506 006c 38BD     		pop	{r3, r4, r5, pc}
2396:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 507              		.loc 1 2396 1 view .LVU162
 508              		.cfi_endproc
 509              	.LFE54:
 511              		.section	.text.xQueueGenericReset,"ax",%progbits
 512              		.align	1
 513              		.global	xQueueGenericReset
 514              		.syntax unified
 515              		.thumb
 516              		.thumb_func
 518              	xQueueGenericReset:
 519              	.LVL52:
 520              	.LFB34:
 298:./FreeRTOS/queue.c ****     BaseType_t xReturn = pdPASS;
 521              		.loc 1 298 1 is_stmt 1 view -0
 522              		.cfi_startproc
 523              		@ args = 0, pretend = 0, frame = 0
 524              		@ frame_needed = 0, uses_anonymous_args = 0
 299:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 525              		.loc 1 299 5 view .LVU164
 300:./FreeRTOS/queue.c **** 
 526              		.loc 1 300 5 view .LVU165
 302:./FreeRTOS/queue.c **** 
 527              		.loc 1 302 28 view .LVU166
 304:./FreeRTOS/queue.c ****         ( pxQueue->uxLength >= 1U ) &&
 528              		.loc 1 304 5 view .LVU167
 304:./FreeRTOS/queue.c ****         ( pxQueue->uxLength >= 1U ) &&
 529              		.loc 1 304 7 is_stmt 0 view .LVU168
 530 0000 0028     		cmp	r0, #0
 531 0002 44D0     		beq	.L44
 298:./FreeRTOS/queue.c ****     BaseType_t xReturn = pdPASS;
 532              		.loc 1 298 1 discriminator 1 view .LVU169
 533 0004 38B5     		push	{r3, r4, r5, lr}
 534              	.LCFI5:
 535              		.cfi_def_cfa_offset 16
 536              		.cfi_offset 3, -16
 537              		.cfi_offset 4, -12
 538              		.cfi_offset 5, -8
 539              		.cfi_offset 14, -4
 540 0006 0D46     		mov	r5, r1
 541 0008 0446     		mov	r4, r0
 305:./FreeRTOS/queue.c ****         /* Check for multiplication overflow. */
 542              		.loc 1 305 18 discriminator 1 view .LVU170
 543 000a C36B     		ldr	r3, [r0, #60]
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 56


 304:./FreeRTOS/queue.c ****         ( pxQueue->uxLength >= 1U ) &&
 544              		.loc 1 304 29 discriminator 1 view .LVU171
 545 000c 002B     		cmp	r3, #0
 546 000e 40D0     		beq	.L45
 307:./FreeRTOS/queue.c ****     {
 547              		.loc 1 307 54 view .LVU172
 548 0010 026C     		ldr	r2, [r0, #64]
 307:./FreeRTOS/queue.c ****     {
 549              		.loc 1 307 44 view .LVU173
 550 0012 0021     		movs	r1, #0
 551              	.LVL53:
 307:./FreeRTOS/queue.c ****     {
 552              		.loc 1 307 44 view .LVU174
 553 0014 A2FB0323 		umull	r2, r3, r2, r3
 554 0018 13B9     		cbnz	r3, .L51
 555              	.L40:
 305:./FreeRTOS/queue.c ****         /* Check for multiplication overflow. */
 556              		.loc 1 305 37 view .LVU175
 557 001a 19B1     		cbz	r1, .L52
 352:./FreeRTOS/queue.c ****     }
 558              		.loc 1 352 17 view .LVU176
 559 001c 0020     		movs	r0, #0
 560              	.LVL54:
 355:./FreeRTOS/queue.c **** 
 561              		.loc 1 355 38 is_stmt 1 view .LVU177
 359:./FreeRTOS/queue.c **** }
 562              		.loc 1 359 5 view .LVU178
 359:./FreeRTOS/queue.c **** }
 563              		.loc 1 359 12 is_stmt 0 view .LVU179
 564 001e 39E0     		b	.L38
 565              	.LVL55:
 566              	.L51:
 307:./FreeRTOS/queue.c ****     {
 567              		.loc 1 307 44 view .LVU180
 568 0020 0121     		movs	r1, #1
 569 0022 FAE7     		b	.L40
 570              	.L52:
 309:./FreeRTOS/queue.c ****         {
 571              		.loc 1 309 9 is_stmt 1 view .LVU181
 572 0024 FFF7FEFF 		bl	vPortEnterCritical
 573              	.LVL56:
 311:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 574              		.loc 1 311 13 view .LVU182
 311:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 575              		.loc 1 311 47 is_stmt 0 view .LVU183
 576 0028 2368     		ldr	r3, [r4]
 311:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 577              		.loc 1 311 67 view .LVU184
 578 002a E26B     		ldr	r2, [r4, #60]
 311:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 579              		.loc 1 311 87 view .LVU185
 580 002c 216C     		ldr	r1, [r4, #64]
 311:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 581              		.loc 1 311 56 view .LVU186
 582 002e 01FB0230 		mla	r0, r1, r2, r3
 311:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 583              		.loc 1 311 38 view .LVU187
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 57


 584 0032 A060     		str	r0, [r4, #8]
 312:./FreeRTOS/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
 585              		.loc 1 312 13 is_stmt 1 view .LVU188
 312:./FreeRTOS/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
 586              		.loc 1 312 40 is_stmt 0 view .LVU189
 587 0034 0020     		movs	r0, #0
 588 0036 A063     		str	r0, [r4, #56]
 313:./FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue
 589              		.loc 1 313 13 is_stmt 1 view .LVU190
 313:./FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue
 590              		.loc 1 313 32 is_stmt 0 view .LVU191
 591 0038 6360     		str	r3, [r4, #4]
 314:./FreeRTOS/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 592              		.loc 1 314 13 is_stmt 1 view .LVU192
 314:./FreeRTOS/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 593              		.loc 1 314 84 is_stmt 0 view .LVU193
 594 003a 013A     		subs	r2, r2, #1
 314:./FreeRTOS/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 595              		.loc 1 314 60 view .LVU194
 596 003c 02FB0133 		mla	r3, r2, r1, r3
 314:./FreeRTOS/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 597              		.loc 1 314 42 view .LVU195
 598 0040 E360     		str	r3, [r4, #12]
 315:./FreeRTOS/queue.c ****             pxQueue->cTxLock = queueUNLOCKED;
 599              		.loc 1 315 13 is_stmt 1 view .LVU196
 315:./FreeRTOS/queue.c ****             pxQueue->cTxLock = queueUNLOCKED;
 600              		.loc 1 315 30 is_stmt 0 view .LVU197
 601 0042 FF23     		movs	r3, #255
 602 0044 84F84430 		strb	r3, [r4, #68]
 316:./FreeRTOS/queue.c **** 
 603              		.loc 1 316 13 is_stmt 1 view .LVU198
 316:./FreeRTOS/queue.c **** 
 604              		.loc 1 316 30 is_stmt 0 view .LVU199
 605 0048 84F84530 		strb	r3, [r4, #69]
 318:./FreeRTOS/queue.c ****             {
 606              		.loc 1 318 13 is_stmt 1 view .LVU200
 318:./FreeRTOS/queue.c ****             {
 607              		.loc 1 318 15 is_stmt 0 view .LVU201
 608 004c B5B9     		cbnz	r5, .L42
 325:./FreeRTOS/queue.c ****                 {
 609              		.loc 1 325 17 is_stmt 1 view .LVU202
 325:./FreeRTOS/queue.c ****                 {
 610              		.loc 1 325 21 is_stmt 0 view .LVU203
 611 004e 2369     		ldr	r3, [r4, #16]
 325:./FreeRTOS/queue.c ****                 {
 612              		.loc 1 325 19 view .LVU204
 613 0050 1BB9     		cbnz	r3, .L53
 614              	.L43:
 348:./FreeRTOS/queue.c ****     }
 615              		.loc 1 348 9 is_stmt 1 view .LVU205
 616 0052 FFF7FEFF 		bl	vPortExitCritical
 617              	.LVL57:
 299:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 618              		.loc 1 299 16 is_stmt 0 view .LVU206
 619 0056 0120     		movs	r0, #1
 348:./FreeRTOS/queue.c ****     }
 620              		.loc 1 348 9 view .LVU207
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 58


 621 0058 1CE0     		b	.L38
 622              	.L53:
 327:./FreeRTOS/queue.c ****                     {
 623              		.loc 1 327 21 is_stmt 1 view .LVU208
 327:./FreeRTOS/queue.c ****                     {
 624              		.loc 1 327 25 is_stmt 0 view .LVU209
 625 005a 04F11000 		add	r0, r4, #16
 626 005e FFF7FEFF 		bl	xTaskRemoveFromEventList
 627              	.LVL58:
 327:./FreeRTOS/queue.c ****                     {
 628              		.loc 1 327 23 view .LVU210
 629 0062 0028     		cmp	r0, #0
 630 0064 F5D0     		beq	.L43
 329:./FreeRTOS/queue.c ****                     }
 631              		.loc 1 329 25 is_stmt 1 view .LVU211
 632 0066 4FF0E023 		mov	r3, #-536813568
 633 006a 4FF08052 		mov	r2, #268435456
 634 006e C3F8042D 		str	r2, [r3, #3332]
 329:./FreeRTOS/queue.c ****                     }
 635              		.loc 1 329 25 view .LVU212
 636              		.syntax unified
 637              	@ 329 "./FreeRTOS/queue.c" 1
 638 0072 BFF34F8F 		dsb
 639              	@ 0 "" 2
 329:./FreeRTOS/queue.c ****                     }
 640              		.loc 1 329 25 view .LVU213
 641              	@ 329 "./FreeRTOS/queue.c" 1
 642 0076 BFF36F8F 		isb
 643              	@ 0 "" 2
 329:./FreeRTOS/queue.c ****                     }
 644              		.loc 1 329 57 view .LVU214
 645              		.thumb
 646              		.syntax unified
 647 007a EAE7     		b	.L43
 648              	.L42:
 344:./FreeRTOS/queue.c ****                 vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 649              		.loc 1 344 17 view .LVU215
 650 007c 04F11000 		add	r0, r4, #16
 651 0080 FFF7FEFF 		bl	vListInitialise
 652              	.LVL59:
 345:./FreeRTOS/queue.c ****             }
 653              		.loc 1 345 17 view .LVU216
 654 0084 04F12400 		add	r0, r4, #36
 655 0088 FFF7FEFF 		bl	vListInitialise
 656              	.LVL60:
 657 008c E1E7     		b	.L43
 658              	.LVL61:
 659              	.L44:
 660              	.LCFI6:
 661              		.cfi_def_cfa_offset 0
 662              		.cfi_restore 3
 663              		.cfi_restore 4
 664              		.cfi_restore 5
 665              		.cfi_restore 14
 352:./FreeRTOS/queue.c ****     }
 666              		.loc 1 352 17 is_stmt 0 view .LVU217
 667 008e 0020     		movs	r0, #0
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 59


 668              	.LVL62:
 360:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 669              		.loc 1 360 1 view .LVU218
 670 0090 7047     		bx	lr
 671              	.LVL63:
 672              	.L45:
 673              	.LCFI7:
 674              		.cfi_def_cfa_offset 16
 675              		.cfi_offset 3, -16
 676              		.cfi_offset 4, -12
 677              		.cfi_offset 5, -8
 678              		.cfi_offset 14, -4
 352:./FreeRTOS/queue.c ****     }
 679              		.loc 1 352 17 view .LVU219
 680 0092 0020     		movs	r0, #0
 681              	.LVL64:
 682              	.L38:
 360:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 683              		.loc 1 360 1 view .LVU220
 684 0094 38BD     		pop	{r3, r4, r5, pc}
 360:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 685              		.loc 1 360 1 view .LVU221
 686              		.cfi_endproc
 687              	.LFE34:
 689              		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 690              		.align	1
 691              		.syntax unified
 692              		.thumb
 693              		.thumb_func
 695              	prvInitialiseNewQueue:
 696              	.LVL65:
 697              	.LFB36:
 499:./FreeRTOS/queue.c ****     /* Remove compiler warnings about unused parameters should
 698              		.loc 1 499 1 is_stmt 1 view -0
 699              		.cfi_startproc
 700              		@ args = 4, pretend = 0, frame = 0
 701              		@ frame_needed = 0, uses_anonymous_args = 0
 499:./FreeRTOS/queue.c ****     /* Remove compiler warnings about unused parameters should
 702              		.loc 1 499 1 is_stmt 0 view .LVU223
 703 0000 10B5     		push	{r4, lr}
 704              	.LCFI8:
 705              		.cfi_def_cfa_offset 8
 706              		.cfi_offset 4, -8
 707              		.cfi_offset 14, -4
 708 0002 0346     		mov	r3, r0
 709              	.LVL66:
 499:./FreeRTOS/queue.c ****     /* Remove compiler warnings about unused parameters should
 710              		.loc 1 499 1 view .LVU224
 711 0004 0298     		ldr	r0, [sp, #8]
 712              	.LVL67:
 502:./FreeRTOS/queue.c **** 
 713              		.loc 1 502 5 is_stmt 1 view .LVU225
 504:./FreeRTOS/queue.c ****     {
 714              		.loc 1 504 5 view .LVU226
 504:./FreeRTOS/queue.c ****     {
 715              		.loc 1 504 7 is_stmt 0 view .LVU227
 716 0006 0C46     		mov	r4, r1
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 60


 717 0008 31B9     		cbnz	r1, .L55
 510:./FreeRTOS/queue.c ****     }
 718              		.loc 1 510 9 is_stmt 1 view .LVU228
 510:./FreeRTOS/queue.c ****     }
 719              		.loc 1 510 28 is_stmt 0 view .LVU229
 720 000a 0060     		str	r0, [r0]
 721              	.L56:
 520:./FreeRTOS/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 722              		.loc 1 520 5 is_stmt 1 view .LVU230
 520:./FreeRTOS/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 723              		.loc 1 520 26 is_stmt 0 view .LVU231
 724 000c C363     		str	r3, [r0, #60]
 521:./FreeRTOS/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 725              		.loc 1 521 5 is_stmt 1 view .LVU232
 521:./FreeRTOS/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 726              		.loc 1 521 28 is_stmt 0 view .LVU233
 727 000e 0464     		str	r4, [r0, #64]
 522:./FreeRTOS/queue.c **** 
 728              		.loc 1 522 5 is_stmt 1 view .LVU234
 522:./FreeRTOS/queue.c **** 
 729              		.loc 1 522 14 is_stmt 0 view .LVU235
 730 0010 0121     		movs	r1, #1
 731              	.LVL68:
 522:./FreeRTOS/queue.c **** 
 732              		.loc 1 522 14 view .LVU236
 733 0012 FFF7FEFF 		bl	xQueueGenericReset
 734              	.LVL69:
 536:./FreeRTOS/queue.c **** }
 735              		.loc 1 536 36 is_stmt 1 view .LVU237
 537:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 736              		.loc 1 537 1 is_stmt 0 view .LVU238
 737 0016 10BD     		pop	{r4, pc}
 738              	.LVL70:
 739              	.L55:
 515:./FreeRTOS/queue.c ****     }
 740              		.loc 1 515 9 is_stmt 1 view .LVU239
 515:./FreeRTOS/queue.c ****     }
 741              		.loc 1 515 28 is_stmt 0 view .LVU240
 742 0018 0260     		str	r2, [r0]
 743 001a F7E7     		b	.L56
 744              		.cfi_endproc
 745              	.LFE36:
 747              		.section	.text.xQueueGenericCreate,"ax",%progbits
 748              		.align	1
 749              		.global	xQueueGenericCreate
 750              		.syntax unified
 751              		.thumb
 752              		.thumb_func
 754              	xQueueGenericCreate:
 755              	.LVL71:
 756              	.LFB35:
 431:./FreeRTOS/queue.c ****         Queue_t * pxNewQueue = NULL;
 757              		.loc 1 431 5 is_stmt 1 view -0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 0
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 431:./FreeRTOS/queue.c ****         Queue_t * pxNewQueue = NULL;
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 61


 761              		.loc 1 431 5 is_stmt 0 view .LVU242
 762 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 763              	.LCFI9:
 764              		.cfi_def_cfa_offset 20
 765              		.cfi_offset 4, -20
 766              		.cfi_offset 5, -16
 767              		.cfi_offset 6, -12
 768              		.cfi_offset 7, -8
 769              		.cfi_offset 14, -4
 770 0002 83B0     		sub	sp, sp, #12
 771              	.LCFI10:
 772              		.cfi_def_cfa_offset 32
 432:./FreeRTOS/queue.c ****         size_t xQueueSizeInBytes;
 773              		.loc 1 432 9 is_stmt 1 view .LVU243
 774              	.LVL72:
 433:./FreeRTOS/queue.c ****         uint8_t * pucQueueStorage;
 775              		.loc 1 433 9 view .LVU244
 434:./FreeRTOS/queue.c **** 
 776              		.loc 1 434 9 view .LVU245
 436:./FreeRTOS/queue.c ****             /* Check for multiplication overflow. */
 777              		.loc 1 436 9 view .LVU246
 436:./FreeRTOS/queue.c ****             /* Check for multiplication overflow. */
 778              		.loc 1 436 11 is_stmt 0 view .LVU247
 779 0004 E0B1     		cbz	r0, .L62
 780 0006 0C46     		mov	r4, r1
 781 0008 1746     		mov	r7, r2
 782 000a 0546     		mov	r5, r0
 438:./FreeRTOS/queue.c ****             /* Check for addition overflow. */
 783              		.loc 1 438 44 discriminator 1 view .LVU248
 784 000c 0023     		movs	r3, #0
 785 000e A4FB0012 		umull	r1, r2, r4, r0
 786              	.LVL73:
 438:./FreeRTOS/queue.c ****             /* Check for addition overflow. */
 787              		.loc 1 438 44 discriminator 1 view .LVU249
 788 0012 9AB9     		cbnz	r2, .L66
 789              	.L60:
 436:./FreeRTOS/queue.c ****             /* Check for multiplication overflow. */
 790              		.loc 1 436 51 discriminator 1 view .LVU250
 791 0014 C3B9     		cbnz	r3, .L63
 440:./FreeRTOS/queue.c ****         {
 792              		.loc 1 440 67 view .LVU251
 793 0016 04FB05F0 		mul	r0, r4, r5
 794              	.LVL74:
 438:./FreeRTOS/queue.c ****             /* Check for addition overflow. */
 795              		.loc 1 438 60 view .LVU252
 796 001a 10F1490F 		cmn	r0, #73
 797 001e 15D8     		bhi	.L64
 445:./FreeRTOS/queue.c **** 
 798              		.loc 1 445 13 is_stmt 1 view .LVU253
 799              	.LVL75:
 456:./FreeRTOS/queue.c **** 
 800              		.loc 1 456 13 view .LVU254
 456:./FreeRTOS/queue.c **** 
 801              		.loc 1 456 40 is_stmt 0 view .LVU255
 802 0020 4830     		adds	r0, r0, #72
 803              	.LVL76:
 456:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 62


 804              		.loc 1 456 40 view .LVU256
 805 0022 FFF7FEFF 		bl	pvPortMalloc
 806              	.LVL77:
 458:./FreeRTOS/queue.c ****             {
 807              		.loc 1 458 13 is_stmt 1 view .LVU257
 458:./FreeRTOS/queue.c ****             {
 808              		.loc 1 458 15 is_stmt 0 view .LVU258
 809 0026 0646     		mov	r6, r0
 810 0028 58B1     		cbz	r0, .L58
 462:./FreeRTOS/queue.c ****                 pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on c
 811              		.loc 1 462 17 is_stmt 1 view .LVU259
 812              	.LVL78:
 463:./FreeRTOS/queue.c **** 
 813              		.loc 1 463 17 view .LVU260
 474:./FreeRTOS/queue.c ****             }
 814              		.loc 1 474 17 view .LVU261
 815 002a 0090     		str	r0, [sp]
 816 002c 3B46     		mov	r3, r7
 817 002e 00F14802 		add	r2, r0, #72
 818              	.LVL79:
 474:./FreeRTOS/queue.c ****             }
 819              		.loc 1 474 17 is_stmt 0 view .LVU262
 820 0032 2146     		mov	r1, r4
 821 0034 2846     		mov	r0, r5
 822              	.LVL80:
 474:./FreeRTOS/queue.c ****             }
 823              		.loc 1 474 17 view .LVU263
 824 0036 FFF7FEFF 		bl	prvInitialiseNewQueue
 825              	.LVL81:
 474:./FreeRTOS/queue.c ****             }
 826              		.loc 1 474 17 view .LVU264
 827 003a 02E0     		b	.L58
 828              	.LVL82:
 829              	.L66:
 438:./FreeRTOS/queue.c ****             /* Check for addition overflow. */
 830              		.loc 1 438 44 discriminator 1 view .LVU265
 831 003c 0123     		movs	r3, #1
 832 003e E9E7     		b	.L60
 833              	.LVL83:
 834              	.L62:
 432:./FreeRTOS/queue.c ****         size_t xQueueSizeInBytes;
 835              		.loc 1 432 19 view .LVU266
 836 0040 0026     		movs	r6, #0
 837              	.LVL84:
 838              	.L58:
 489:./FreeRTOS/queue.c **** 
 839              		.loc 1 489 5 view .LVU267
 840 0042 3046     		mov	r0, r6
 841 0044 03B0     		add	sp, sp, #12
 842              	.LCFI11:
 843              		.cfi_remember_state
 844              		.cfi_def_cfa_offset 20
 845              		@ sp needed
 846 0046 F0BD     		pop	{r4, r5, r6, r7, pc}
 847              	.LVL85:
 848              	.L63:
 849              	.LCFI12:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 63


 850              		.cfi_restore_state
 432:./FreeRTOS/queue.c ****         size_t xQueueSizeInBytes;
 851              		.loc 1 432 19 view .LVU268
 852 0048 0026     		movs	r6, #0
 853 004a FAE7     		b	.L58
 854              	.LVL86:
 855              	.L64:
 432:./FreeRTOS/queue.c ****         size_t xQueueSizeInBytes;
 856              		.loc 1 432 19 view .LVU269
 857 004c 0026     		movs	r6, #0
 484:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 858              		.loc 1 484 39 is_stmt 1 view .LVU270
 485:./FreeRTOS/queue.c ****         }
 859              		.loc 1 485 37 view .LVU271
 488:./FreeRTOS/queue.c ****     }
 860              		.loc 1 488 9 view .LVU272
 488:./FreeRTOS/queue.c ****     }
 861              		.loc 1 488 16 is_stmt 0 view .LVU273
 862 004e F8E7     		b	.L58
 863              		.cfi_endproc
 864              	.LFE35:
 866              		.section	.text.xQueueGenericSend,"ax",%progbits
 867              		.align	1
 868              		.global	xQueueGenericSend
 869              		.syntax unified
 870              		.thumb
 871              		.thumb_func
 873              	xQueueGenericSend:
 874              	.LVL87:
 875              	.LFB39:
 839:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 876              		.loc 1 839 1 is_stmt 1 view -0
 877              		.cfi_startproc
 878              		@ args = 0, pretend = 0, frame = 16
 879              		@ frame_needed = 0, uses_anonymous_args = 0
 839:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 880              		.loc 1 839 1 is_stmt 0 view .LVU275
 881 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 882              	.LCFI13:
 883              		.cfi_def_cfa_offset 20
 884              		.cfi_offset 4, -20
 885              		.cfi_offset 5, -16
 886              		.cfi_offset 6, -12
 887              		.cfi_offset 7, -8
 888              		.cfi_offset 14, -4
 889 0002 85B0     		sub	sp, sp, #20
 890              	.LCFI14:
 891              		.cfi_def_cfa_offset 40
 892 0004 0446     		mov	r4, r0
 893 0006 0F46     		mov	r7, r1
 894 0008 0192     		str	r2, [sp, #4]
 895 000a 1D46     		mov	r5, r3
 840:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 896              		.loc 1 840 5 is_stmt 1 view .LVU276
 897              	.LVL88:
 841:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 898              		.loc 1 841 5 view .LVU277
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 64


 842:./FreeRTOS/queue.c **** 
 899              		.loc 1 842 5 view .LVU278
 840:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 900              		.loc 1 840 16 is_stmt 0 view .LVU279
 901 000c 0026     		movs	r6, #0
 902 000e 3DE0     		b	.L68
 903              	.LVL89:
 904              	.L69:
 866:./FreeRTOS/queue.c **** 
 905              		.loc 1 866 43 is_stmt 1 view .LVU280
 930:./FreeRTOS/queue.c **** 
 906              		.loc 1 930 21 view .LVU281
 930:./FreeRTOS/queue.c **** 
 907              		.loc 1 930 38 is_stmt 0 view .LVU282
 908 0010 2A46     		mov	r2, r5
 909 0012 3946     		mov	r1, r7
 910 0014 2046     		mov	r0, r4
 911 0016 FFF7FEFF 		bl	prvCopyDataToQueue
 912              	.LVL90:
 934:./FreeRTOS/queue.c ****                     {
 913              		.loc 1 934 21 is_stmt 1 view .LVU283
 934:./FreeRTOS/queue.c ****                     {
 914              		.loc 1 934 25 is_stmt 0 view .LVU284
 915 001a 636A     		ldr	r3, [r4, #36]
 934:./FreeRTOS/queue.c ****                     {
 916              		.loc 1 934 23 view .LVU285
 917 001c 7BB9     		cbnz	r3, .L82
 949:./FreeRTOS/queue.c ****                     {
 918              		.loc 1 949 26 is_stmt 1 view .LVU286
 949:./FreeRTOS/queue.c ****                     {
 919              		.loc 1 949 28 is_stmt 0 view .LVU287
 920 001e 48B1     		cbz	r0, .L72
 955:./FreeRTOS/queue.c ****                     }
 921              		.loc 1 955 25 is_stmt 1 view .LVU288
 922 0020 4FF0E023 		mov	r3, #-536813568
 923 0024 4FF08052 		mov	r2, #268435456
 924 0028 C3F8042D 		str	r2, [r3, #3332]
 955:./FreeRTOS/queue.c ****                     }
 925              		.loc 1 955 25 view .LVU289
 926              		.syntax unified
 927              	@ 955 "./FreeRTOS/queue.c" 1
 928 002c BFF34F8F 		dsb
 929              	@ 0 "" 2
 955:./FreeRTOS/queue.c ****                     }
 930              		.loc 1 955 25 view .LVU290
 931              	@ 955 "./FreeRTOS/queue.c" 1
 932 0030 BFF36F8F 		isb
 933              	@ 0 "" 2
 955:./FreeRTOS/queue.c ****                     }
 934              		.loc 1 955 57 view .LVU291
 935              	.LVL91:
 936              		.thumb
 937              		.syntax unified
 938              	.L72:
 959:./FreeRTOS/queue.c ****                     }
 939              		.loc 1 959 49 view .LVU292
 964:./FreeRTOS/queue.c ****                 return pdPASS;
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 65


 940              		.loc 1 964 17 view .LVU293
 941 0034 FFF7FEFF 		bl	vPortExitCritical
 942              	.LVL92:
 965:./FreeRTOS/queue.c ****             }
 943              		.loc 1 965 17 view .LVU294
 965:./FreeRTOS/queue.c ****             }
 944              		.loc 1 965 24 is_stmt 0 view .LVU295
 945 0038 0120     		movs	r0, #1
 946              	.LVL93:
 947              	.L67:
1044:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 948              		.loc 1 1044 1 view .LVU296
 949 003a 05B0     		add	sp, sp, #20
 950              	.LCFI15:
 951              		.cfi_remember_state
 952              		.cfi_def_cfa_offset 20
 953              		@ sp needed
 954 003c F0BD     		pop	{r4, r5, r6, r7, pc}
 955              	.LVL94:
 956              	.L82:
 957              	.LCFI16:
 958              		.cfi_restore_state
 936:./FreeRTOS/queue.c ****                         {
 959              		.loc 1 936 25 is_stmt 1 view .LVU297
 936:./FreeRTOS/queue.c ****                         {
 960              		.loc 1 936 29 is_stmt 0 view .LVU298
 961 003e 04F12400 		add	r0, r4, #36
 962              	.LVL95:
 936:./FreeRTOS/queue.c ****                         {
 963              		.loc 1 936 29 view .LVU299
 964 0042 FFF7FEFF 		bl	xTaskRemoveFromEventList
 965              	.LVL96:
 936:./FreeRTOS/queue.c ****                         {
 966              		.loc 1 936 27 view .LVU300
 967 0046 0028     		cmp	r0, #0
 968 0048 F4D0     		beq	.L72
 942:./FreeRTOS/queue.c ****                         }
 969              		.loc 1 942 29 is_stmt 1 view .LVU301
 970 004a 4FF0E023 		mov	r3, #-536813568
 971 004e 4FF08052 		mov	r2, #268435456
 972 0052 C3F8042D 		str	r2, [r3, #3332]
 942:./FreeRTOS/queue.c ****                         }
 973              		.loc 1 942 29 view .LVU302
 974              		.syntax unified
 975              	@ 942 "./FreeRTOS/queue.c" 1
 976 0056 BFF34F8F 		dsb
 977              	@ 0 "" 2
 942:./FreeRTOS/queue.c ****                         }
 978              		.loc 1 942 29 view .LVU303
 979              	@ 942 "./FreeRTOS/queue.c" 1
 980 005a BFF36F8F 		isb
 981              	@ 0 "" 2
 942:./FreeRTOS/queue.c ****                         }
 982              		.loc 1 942 61 view .LVU304
 983              		.thumb
 984              		.syntax unified
 985 005e E9E7     		b	.L72
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 66


 986              	.LVL97:
 987              	.L83:
 973:./FreeRTOS/queue.c **** 
 988              		.loc 1 973 21 view .LVU305
 989 0060 FFF7FEFF 		bl	vPortExitCritical
 990              	.LVL98:
 977:./FreeRTOS/queue.c ****                     return errQUEUE_FULL;
 991              		.loc 1 977 54 view .LVU306
 978:./FreeRTOS/queue.c ****                 }
 992              		.loc 1 978 21 view .LVU307
 978:./FreeRTOS/queue.c ****                 }
 993              		.loc 1 978 28 is_stmt 0 view .LVU308
 994 0064 0020     		movs	r0, #0
 995 0066 E8E7     		b	.L67
 996              	.L84:
 984:./FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 997              		.loc 1 984 21 is_stmt 1 view .LVU309
 998 0068 02A8     		add	r0, sp, #8
 999 006a FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 1000              	.LVL99:
 985:./FreeRTOS/queue.c ****                 }
 1001              		.loc 1 985 21 view .LVU310
 985:./FreeRTOS/queue.c ****                 }
 1002              		.loc 1 985 35 is_stmt 0 view .LVU311
 1003 006e 0126     		movs	r6, #1
 1004 0070 19E0     		b	.L75
 1005              	.LVL100:
 1006              	.L85:
1000:./FreeRTOS/queue.c **** 
 1007              		.loc 1 1000 9 is_stmt 1 discriminator 1 view .LVU312
 1008 0072 0023     		movs	r3, #0
 1009 0074 84F84430 		strb	r3, [r4, #68]
 1010 0078 21E0     		b	.L76
 1011              	.L86:
1000:./FreeRTOS/queue.c **** 
 1012              		.loc 1 1000 9 discriminator 4 view .LVU313
 1013 007a 0023     		movs	r3, #0
 1014 007c 84F84530 		strb	r3, [r4, #69]
 1015 0080 23E0     		b	.L77
 1016              	.L79:
1030:./FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
 1017              		.loc 1 1030 17 view .LVU314
 1018 0082 2046     		mov	r0, r4
 1019 0084 FFF7FEFF 		bl	prvUnlockQueue
 1020              	.LVL101:
1031:./FreeRTOS/queue.c ****             }
 1021              		.loc 1 1031 17 view .LVU315
1031:./FreeRTOS/queue.c ****             }
 1022              		.loc 1 1031 26 is_stmt 0 view .LVU316
 1023 0088 FFF7FEFF 		bl	xTaskResumeAll
 1024              	.LVL102:
 1025              	.L68:
 844:./FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1026              		.loc 1 844 28 is_stmt 1 view .LVU317
 845:./FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1027              		.loc 1 845 100 view .LVU318
 846:./FreeRTOS/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 67


 1028              		.loc 1 846 91 view .LVU319
 849:./FreeRTOS/queue.c ****     }
 1029              		.loc 1 849 110 view .LVU320
 856:./FreeRTOS/queue.c ****     {
 1030              		.loc 1 856 5 view .LVU321
 858:./FreeRTOS/queue.c ****         {
 1031              		.loc 1 858 9 view .LVU322
 1032 008c FFF7FEFF 		bl	vPortEnterCritical
 1033              	.LVL103:
 864:./FreeRTOS/queue.c ****             {
 1034              		.loc 1 864 13 view .LVU323
 864:./FreeRTOS/queue.c ****             {
 1035              		.loc 1 864 26 is_stmt 0 view .LVU324
 1036 0090 A26B     		ldr	r2, [r4, #56]
 864:./FreeRTOS/queue.c ****             {
 1037              		.loc 1 864 55 view .LVU325
 1038 0092 E36B     		ldr	r3, [r4, #60]
 864:./FreeRTOS/queue.c ****             {
 1039              		.loc 1 864 15 view .LVU326
 1040 0094 9A42     		cmp	r2, r3
 1041 0096 BBD3     		bcc	.L69
 864:./FreeRTOS/queue.c ****             {
 1042              		.loc 1 864 68 discriminator 1 view .LVU327
 1043 0098 022D     		cmp	r5, #2
 1044 009a B9D0     		beq	.L69
 969:./FreeRTOS/queue.c ****                 {
 1045              		.loc 1 969 17 is_stmt 1 view .LVU328
 969:./FreeRTOS/queue.c ****                 {
 1046              		.loc 1 969 34 is_stmt 0 view .LVU329
 1047 009c 019B     		ldr	r3, [sp, #4]
 969:./FreeRTOS/queue.c ****                 {
 1048              		.loc 1 969 19 view .LVU330
 1049 009e 002B     		cmp	r3, #0
 1050 00a0 DED0     		beq	.L83
 980:./FreeRTOS/queue.c ****                 {
 1051              		.loc 1 980 22 is_stmt 1 view .LVU331
 980:./FreeRTOS/queue.c ****                 {
 1052              		.loc 1 980 24 is_stmt 0 view .LVU332
 1053 00a2 002E     		cmp	r6, #0
 1054 00a4 E0D0     		beq	.L84
 1055              	.LVL104:
 1056              	.L75:
 990:./FreeRTOS/queue.c ****                 }
 1057              		.loc 1 990 45 is_stmt 1 view .LVU333
 994:./FreeRTOS/queue.c **** 
 1058              		.loc 1 994 9 view .LVU334
 1059 00a6 FFF7FEFF 		bl	vPortExitCritical
 1060              	.LVL105:
 999:./FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 1061              		.loc 1 999 9 view .LVU335
 1062 00aa FFF7FEFF 		bl	vTaskSuspendAll
 1063              	.LVL106:
1000:./FreeRTOS/queue.c **** 
 1064              		.loc 1 1000 9 view .LVU336
 1065 00ae FFF7FEFF 		bl	vPortEnterCritical
 1066              	.LVL107:
1000:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 68


 1067              		.loc 1 1000 9 view .LVU337
 1068 00b2 94F84400 		ldrb	r0, [r4, #68]	@ zero_extendqisi2
 1069 00b6 40B2     		sxtb	r0, r0
 1070 00b8 B0F1FF3F 		cmp	r0, #-1
 1071 00bc D9D0     		beq	.L85
 1072              	.L76:
1000:./FreeRTOS/queue.c **** 
 1073              		.loc 1 1000 9 discriminator 3 view .LVU338
 1074 00be 94F84500 		ldrb	r0, [r4, #69]	@ zero_extendqisi2
 1075 00c2 40B2     		sxtb	r0, r0
 1076 00c4 B0F1FF3F 		cmp	r0, #-1
 1077 00c8 D7D0     		beq	.L86
 1078              	.L77:
1000:./FreeRTOS/queue.c **** 
 1079              		.loc 1 1000 9 discriminator 6 view .LVU339
 1080 00ca FFF7FEFF 		bl	vPortExitCritical
 1081              	.LVL108:
1003:./FreeRTOS/queue.c ****         {
 1082              		.loc 1 1003 9 discriminator 6 view .LVU340
1003:./FreeRTOS/queue.c ****         {
 1083              		.loc 1 1003 13 is_stmt 0 discriminator 6 view .LVU341
 1084 00ce 01A9     		add	r1, sp, #4
 1085 00d0 02A8     		add	r0, sp, #8
 1086 00d2 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1087              	.LVL109:
1003:./FreeRTOS/queue.c ****         {
 1088              		.loc 1 1003 11 discriminator 6 view .LVU342
 1089 00d6 D8B9     		cbnz	r0, .L78
1005:./FreeRTOS/queue.c ****             {
 1090              		.loc 1 1005 13 is_stmt 1 view .LVU343
1005:./FreeRTOS/queue.c ****             {
 1091              		.loc 1 1005 17 is_stmt 0 view .LVU344
 1092 00d8 2046     		mov	r0, r4
 1093 00da FFF7FEFF 		bl	prvIsQueueFull
 1094              	.LVL110:
1005:./FreeRTOS/queue.c ****             {
 1095              		.loc 1 1005 15 view .LVU345
 1096 00de 0028     		cmp	r0, #0
 1097 00e0 CFD0     		beq	.L79
1007:./FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1098              		.loc 1 1007 55 is_stmt 1 view .LVU346
1008:./FreeRTOS/queue.c **** 
 1099              		.loc 1 1008 17 view .LVU347
 1100 00e2 0199     		ldr	r1, [sp, #4]
 1101 00e4 04F11000 		add	r0, r4, #16
 1102 00e8 FFF7FEFF 		bl	vTaskPlaceOnEventList
 1103              	.LVL111:
1015:./FreeRTOS/queue.c **** 
 1104              		.loc 1 1015 17 view .LVU348
 1105 00ec 2046     		mov	r0, r4
 1106 00ee FFF7FEFF 		bl	prvUnlockQueue
 1107              	.LVL112:
1022:./FreeRTOS/queue.c ****                 {
 1108              		.loc 1 1022 17 view .LVU349
1022:./FreeRTOS/queue.c ****                 {
 1109              		.loc 1 1022 21 is_stmt 0 view .LVU350
 1110 00f2 FFF7FEFF 		bl	xTaskResumeAll
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 69


 1111              	.LVL113:
1022:./FreeRTOS/queue.c ****                 {
 1112              		.loc 1 1022 19 view .LVU351
 1113 00f6 0028     		cmp	r0, #0
 1114 00f8 C8D1     		bne	.L68
1024:./FreeRTOS/queue.c ****                 }
 1115              		.loc 1 1024 21 is_stmt 1 view .LVU352
 1116 00fa 4FF0E023 		mov	r3, #-536813568
 1117 00fe 4FF08052 		mov	r2, #268435456
 1118 0102 C3F8042D 		str	r2, [r3, #3332]
1024:./FreeRTOS/queue.c ****                 }
 1119              		.loc 1 1024 21 view .LVU353
 1120              		.syntax unified
 1121              	@ 1024 "./FreeRTOS/queue.c" 1
 1122 0106 BFF34F8F 		dsb
 1123              	@ 0 "" 2
1024:./FreeRTOS/queue.c ****                 }
 1124              		.loc 1 1024 21 view .LVU354
 1125              	@ 1024 "./FreeRTOS/queue.c" 1
 1126 010a BFF36F8F 		isb
 1127              	@ 0 "" 2
 1128              		.thumb
 1129              		.syntax unified
 1130 010e BDE7     		b	.L68
 1131              	.L78:
1037:./FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
 1132              		.loc 1 1037 13 view .LVU355
 1133 0110 2046     		mov	r0, r4
 1134 0112 FFF7FEFF 		bl	prvUnlockQueue
 1135              	.LVL114:
1038:./FreeRTOS/queue.c **** 
 1136              		.loc 1 1038 13 view .LVU356
1038:./FreeRTOS/queue.c **** 
 1137              		.loc 1 1038 22 is_stmt 0 view .LVU357
 1138 0116 FFF7FEFF 		bl	xTaskResumeAll
 1139              	.LVL115:
1040:./FreeRTOS/queue.c ****             return errQUEUE_FULL;
 1140              		.loc 1 1040 46 is_stmt 1 view .LVU358
1041:./FreeRTOS/queue.c ****         }
 1141              		.loc 1 1041 13 view .LVU359
1041:./FreeRTOS/queue.c ****         }
 1142              		.loc 1 1041 20 is_stmt 0 view .LVU360
 1143 011a 0020     		movs	r0, #0
 1144 011c 8DE7     		b	.L67
 1145              		.cfi_endproc
 1146              	.LFE39:
 1148              		.section	.text.prvInitialiseMutex,"ax",%progbits
 1149              		.align	1
 1150              		.syntax unified
 1151              		.thumb
 1152              		.thumb_func
 1154              	prvInitialiseMutex:
 1155              	.LVL116:
 1156              	.LFB37:
 543:./FreeRTOS/queue.c ****         if( pxNewQueue != NULL )
 1157              		.loc 1 543 5 is_stmt 1 view -0
 1158              		.cfi_startproc
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 70


 1159              		@ args = 0, pretend = 0, frame = 0
 1160              		@ frame_needed = 0, uses_anonymous_args = 0
 544:./FreeRTOS/queue.c ****         {
 1161              		.loc 1 544 9 view .LVU362
 544:./FreeRTOS/queue.c ****         {
 1162              		.loc 1 544 11 is_stmt 0 view .LVU363
 1163 0000 48B1     		cbz	r0, .L90
 543:./FreeRTOS/queue.c ****         if( pxNewQueue != NULL )
 1164              		.loc 1 543 5 view .LVU364
 1165 0002 08B5     		push	{r3, lr}
 1166              	.LCFI17:
 1167              		.cfi_def_cfa_offset 8
 1168              		.cfi_offset 3, -8
 1169              		.cfi_offset 14, -4
 550:./FreeRTOS/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1170              		.loc 1 550 13 is_stmt 1 view .LVU365
 550:./FreeRTOS/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1171              		.loc 1 550 51 is_stmt 0 view .LVU366
 1172 0004 0021     		movs	r1, #0
 1173 0006 8160     		str	r1, [r0, #8]
 551:./FreeRTOS/queue.c **** 
 1174              		.loc 1 551 13 is_stmt 1 view .LVU367
 551:./FreeRTOS/queue.c **** 
 1175              		.loc 1 551 37 is_stmt 0 view .LVU368
 1176 0008 0160     		str	r1, [r0]
 554:./FreeRTOS/queue.c **** 
 1177              		.loc 1 554 13 is_stmt 1 view .LVU369
 554:./FreeRTOS/queue.c **** 
 1178              		.loc 1 554 59 is_stmt 0 view .LVU370
 1179 000a C160     		str	r1, [r0, #12]
 556:./FreeRTOS/queue.c **** 
 1180              		.loc 1 556 44 is_stmt 1 view .LVU371
 559:./FreeRTOS/queue.c ****         }
 1181              		.loc 1 559 13 view .LVU372
 559:./FreeRTOS/queue.c ****         }
 1182              		.loc 1 559 22 is_stmt 0 view .LVU373
 1183 000c 0B46     		mov	r3, r1
 1184 000e 0A46     		mov	r2, r1
 1185 0010 FFF7FEFF 		bl	xQueueGenericSend
 1186              	.LVL117:
 563:./FreeRTOS/queue.c ****         }
 1187              		.loc 1 563 39 is_stmt 1 view .LVU374
 565:./FreeRTOS/queue.c **** 
 1188              		.loc 1 565 5 is_stmt 0 view .LVU375
 1189 0014 08BD     		pop	{r3, pc}
 1190              	.LVL118:
 1191              	.L90:
 1192              	.LCFI18:
 1193              		.cfi_def_cfa_offset 0
 1194              		.cfi_restore 3
 1195              		.cfi_restore 14
 565:./FreeRTOS/queue.c **** 
 1196              		.loc 1 565 5 view .LVU376
 1197 0016 7047     		bx	lr
 1198              		.cfi_endproc
 1199              	.LFE37:
 1201              		.section	.text.xQueueCreateMutex,"ax",%progbits
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 71


 1202              		.align	1
 1203              		.global	xQueueCreateMutex
 1204              		.syntax unified
 1205              		.thumb
 1206              		.thumb_func
 1208              	xQueueCreateMutex:
 1209              	.LVL119:
 1210              	.LFB38:
 573:./FreeRTOS/queue.c ****         QueueHandle_t xNewQueue;
 1211              		.loc 1 573 5 is_stmt 1 view -0
 1212              		.cfi_startproc
 1213              		@ args = 0, pretend = 0, frame = 0
 1214              		@ frame_needed = 0, uses_anonymous_args = 0
 573:./FreeRTOS/queue.c ****         QueueHandle_t xNewQueue;
 1215              		.loc 1 573 5 is_stmt 0 view .LVU378
 1216 0000 10B5     		push	{r4, lr}
 1217              	.LCFI19:
 1218              		.cfi_def_cfa_offset 8
 1219              		.cfi_offset 4, -8
 1220              		.cfi_offset 14, -4
 1221 0002 0246     		mov	r2, r0
 574:./FreeRTOS/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 1222              		.loc 1 574 9 is_stmt 1 view .LVU379
 575:./FreeRTOS/queue.c **** 
 1223              		.loc 1 575 9 view .LVU380
 1224              	.LVL120:
 577:./FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1225              		.loc 1 577 9 view .LVU381
 577:./FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1226              		.loc 1 577 21 is_stmt 0 view .LVU382
 1227 0004 0021     		movs	r1, #0
 1228 0006 0120     		movs	r0, #1
 1229              	.LVL121:
 577:./FreeRTOS/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1230              		.loc 1 577 21 view .LVU383
 1231 0008 FFF7FEFF 		bl	xQueueGenericCreate
 1232              	.LVL122:
 1233 000c 0446     		mov	r4, r0
 1234              	.LVL123:
 578:./FreeRTOS/queue.c **** 
 1235              		.loc 1 578 9 is_stmt 1 view .LVU384
 1236 000e FFF7FEFF 		bl	prvInitialiseMutex
 1237              	.LVL124:
 580:./FreeRTOS/queue.c ****     }
 1238              		.loc 1 580 9 view .LVU385
 581:./FreeRTOS/queue.c **** 
 1239              		.loc 1 581 5 is_stmt 0 view .LVU386
 1240 0012 2046     		mov	r0, r4
 1241 0014 10BD     		pop	{r4, pc}
 581:./FreeRTOS/queue.c **** 
 1242              		.loc 1 581 5 view .LVU387
 1243              		.cfi_endproc
 1244              	.LFE38:
 1246              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 1247              		.align	1
 1248              		.global	xQueueGenericSendFromISR
 1249              		.syntax unified
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 72


 1250              		.thumb
 1251              		.thumb_func
 1253              	xQueueGenericSendFromISR:
 1254              	.LVL125:
 1255              	.LFB40:
1051:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 1256              		.loc 1 1051 1 is_stmt 1 view -0
 1257              		.cfi_startproc
 1258              		@ args = 0, pretend = 0, frame = 0
 1259              		@ frame_needed = 0, uses_anonymous_args = 0
1051:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 1260              		.loc 1 1051 1 is_stmt 0 view .LVU389
 1261 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1262              	.LCFI20:
 1263              		.cfi_def_cfa_offset 24
 1264              		.cfi_offset 3, -24
 1265              		.cfi_offset 4, -20
 1266              		.cfi_offset 5, -16
 1267              		.cfi_offset 6, -12
 1268              		.cfi_offset 7, -8
 1269              		.cfi_offset 14, -4
 1270 0002 0446     		mov	r4, r0
 1271 0004 1746     		mov	r7, r2
 1272 0006 1A46     		mov	r2, r3
 1273              	.LVL126:
1052:./FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 1274              		.loc 1 1052 5 is_stmt 1 view .LVU390
1053:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 1275              		.loc 1 1053 5 view .LVU391
1054:./FreeRTOS/queue.c **** 
 1276              		.loc 1 1054 5 view .LVU392
1056:./FreeRTOS/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1277              		.loc 1 1056 28 view .LVU393
1057:./FreeRTOS/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1278              		.loc 1 1057 100 view .LVU394
1058:./FreeRTOS/queue.c **** 
 1279              		.loc 1 1058 91 view .LVU395
1074:./FreeRTOS/queue.c **** 
 1280              		.loc 1 1074 47 view .LVU396
1081:./FreeRTOS/queue.c ****     {
 1281              		.loc 1 1081 5 view .LVU397
 1282              	.LBB28:
 1283              	.LBI28:
 1284              		.file 2 "FreeRTOS/portable/GCC/ARM_CM3/portmacro.h"
   1:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*
   2:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * FreeRTOS Kernel V10.5.1
   3:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  *
   5:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * SPDX-License-Identifier: MIT
   6:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  *
   7:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   9:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * the Software without restriction, including without limitation the rights to
  10:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * subject to the following conditions:
  13:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  *
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 73


  14:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  15:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * copies or substantial portions of the Software.
  16:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  *
  17:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  *
  24:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * https://www.FreeRTOS.org
  25:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * https://github.com/FreeRTOS
  26:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  *
  27:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  */
  28:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** #include <stdlib.h>
  29:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** #include <string.h>
  30:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** #include <stdint.h>
  31:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** #include <FreeRTOSConfig.h>
  32:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** #include <projdefs.h>
  33:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
  34:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  35:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define PORTMACRO_H
  36:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
  37:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #ifdef __cplusplus
  38:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         extern "C" {
  39:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #endif
  40:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
  41:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  42:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * Port specific definitions.
  43:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  *
  44:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  45:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * given hardware and compiler.
  46:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  *
  47:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * These settings should not be altered.
  48:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  49:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  */
  50:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
  51:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Type definitions. */
  52:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portCHAR          char
  53:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portFLOAT         float
  54:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portDOUBLE        double
  55:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portLONG          long
  56:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portSHORT         short
  57:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portSTACK_TYPE    uint32_t
  58:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portBASE_TYPE     long
  59:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
  60:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  61:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     typedef long             BaseType_t;
  62:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     typedef unsigned long    UBaseType_t;
  63:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
  64:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  65:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         typedef uint16_t     TickType_t;
  66:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  67:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #else
  68:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         typedef uint32_t     TickType_t;
  69:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  70:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 74


  71:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  72:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * not need to be guarded with a critical section. */
  73:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  74:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #endif
  75:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  76:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
  77:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Architecture specifics. */
  78:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  79:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  80:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portBYTE_ALIGNMENT    8
  81:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  82:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  83:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
  84:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Scheduler utilities. */
  85:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portYIELD()                                 \
  86:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {                                                   \
  87:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  88:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  89:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****                                                         \
  90:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  91:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****          * within the specified behaviour for the architecture. */ \
  92:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  93:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         __asm volatile ( "isb" );                                  \
  94:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
  95:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
  96:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  97:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  98:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    do { if( xSwitchRequired != pdFALSE ) portY
  99:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
 100:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 101:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 102:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Critical section management. */
 103:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     extern void vPortEnterCritical( void );
 104:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     extern void vPortExitCritical( void );
 105:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 106:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 107:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 108:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 109:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 110:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 111:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 112:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 113:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 114:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 115:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 116:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****  * (which build with all the ports) will build. */
 117:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 118:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 119:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 120:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 121:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 122:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 123:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 124:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 125:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #endif
 126:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 127:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 75


 128:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 129:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 130:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 131:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #endif
 132:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 133:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 134:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 135:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Generic helper function. */
 136:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 137:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         {
 138:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             uint8_t ucReturn;
 139:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 140:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 141:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 142:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             return ucReturn;
 143:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         }
 144:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 145:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Check the configuration. */
 146:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 147:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 148:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #endif
 149:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 150:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 151:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 152:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 153:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 154:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 155:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 156:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 157:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 158:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 159:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 160:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 161:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 162:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #ifdef configASSERT
 163:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         void vPortValidateInterruptPriority( void );
 164:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 165:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #endif
 166:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 167:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 168:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portNOP()
 169:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 170:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #define portINLINE              __inline
 171:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 172:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #ifndef portFORCE_INLINE
 173:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 174:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     #endif
 175:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 176:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 177:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 178:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 179:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 180:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         uint32_t ulCurrentInterrupt;
 181:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         BaseType_t xReturn;
 182:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 183:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 184:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 76


 185:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 186:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         if( ulCurrentInterrupt == 0 )
 187:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         {
 188:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             xReturn = pdFALSE;
 189:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         }
 190:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         else
 191:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         {
 192:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             xReturn = pdTRUE;
 193:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         }
 194:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 195:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         return xReturn;
 196:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
 197:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 198:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 199:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 200:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 201:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 202:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         uint32_t ulNewBASEPRI;
 203:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 204:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         __asm volatile
 205:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         (
 206:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             "	mov %0, %1												\n"\
 207:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             "	msr basepri, %0											\n"\
 208:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             "	isb														\n"\
 209:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             "	dsb														\n"\
 210:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             : "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 211:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         );
 212:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
 213:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 214:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 215:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 216:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 1285              		.loc 2 216 38 view .LVU398
 1286              	.LBB29:
 217:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 218:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 1287              		.loc 2 218 9 view .LVU399
 219:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 220:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         __asm volatile
 1288              		.loc 2 220 9 view .LVU400
 1289              		.syntax unified
 1290              	@ 220 "FreeRTOS/portable/GCC/ARM_CM3/portmacro.h" 1
 1291 0008 EFF31185 			mrs r5, basepri											
 1292 000c 4FF0BF03 		mov r3, #191												
 1293 0010 83F31188 		msr basepri, r3											
 1294 0014 BFF36F8F 		isb														
 1295 0018 BFF34F8F 		dsb														
 1296              	
 1297              	@ 0 "" 2
 1298              	.LVL127:
 221:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         (
 222:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             "	mrs %0, basepri											\n"\
 223:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             "	mov %1, %2												\n"\
 224:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             "	msr basepri, %1											\n"\
 225:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             "	isb														\n"\
 226:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             "	dsb														\n"\
 227:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****             : "=r" ( ulOriginalBASEPRI ), "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 77


 228:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         );
 229:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 230:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         /* This return will not be reached but is necessary to prevent compiler
 231:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****          * warnings. */
 232:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         return ulOriginalBASEPRI;
 1299              		.loc 2 232 9 view .LVU401
 1300              		.loc 2 232 9 is_stmt 0 view .LVU402
 1301              		.thumb
 1302              		.syntax unified
 1303              	.LBE29:
 1304              	.LBE28:
1083:./FreeRTOS/queue.c ****         {
 1305              		.loc 1 1083 9 is_stmt 1 view .LVU403
1083:./FreeRTOS/queue.c ****         {
 1306              		.loc 1 1083 22 is_stmt 0 view .LVU404
 1307 001c 806B     		ldr	r0, [r0, #56]
 1308              	.LVL128:
1083:./FreeRTOS/queue.c ****         {
 1309              		.loc 1 1083 51 view .LVU405
 1310 001e E36B     		ldr	r3, [r4, #60]
1083:./FreeRTOS/queue.c ****         {
 1311              		.loc 1 1083 11 view .LVU406
 1312 0020 9842     		cmp	r0, r3
 1313 0022 05D3     		bcc	.L96
1083:./FreeRTOS/queue.c ****         {
 1314              		.loc 1 1083 64 discriminator 1 view .LVU407
 1315 0024 022A     		cmp	r2, #2
 1316 0026 03D0     		beq	.L96
1203:./FreeRTOS/queue.c ****         }
 1317              		.loc 1 1203 21 view .LVU408
 1318 0028 0020     		movs	r0, #0
 1319              	.LVL129:
 1320              	.L97:
1206:./FreeRTOS/queue.c **** 
 1321              		.loc 1 1206 5 is_stmt 1 view .LVU409
 1322              	.LBB30:
 1323              	.LBI30:
 233:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
 234:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 235:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 236:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 1324              		.loc 2 236 34 view .LVU410
 1325              	.LBB31:
 237:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 238:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         __asm volatile
 1326              		.loc 2 238 9 view .LVU411
 1327              		.syntax unified
 1328              	@ 238 "FreeRTOS/portable/GCC/ARM_CM3/portmacro.h" 1
 1329 002a 85F31188 			msr basepri, r5	
 1330              	@ 0 "" 2
 1331              		.thumb
 1332              		.syntax unified
 1333              	.LBE31:
 1334              	.LBE30:
1208:./FreeRTOS/queue.c **** }
 1335              		.loc 1 1208 5 view .LVU412
1209:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 78


 1336              		.loc 1 1209 1 is_stmt 0 view .LVU413
 1337 002e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1338              	.LVL130:
 1339              	.L96:
 1340              	.LBB32:
1085:./FreeRTOS/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1341              		.loc 1 1085 13 is_stmt 1 view .LVU414
1085:./FreeRTOS/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1342              		.loc 1 1085 26 is_stmt 0 view .LVU415
 1343 0030 94F84560 		ldrb	r6, [r4, #69]	@ zero_extendqisi2
 1344 0034 76B2     		sxtb	r6, r6
 1345              	.LVL131:
1086:./FreeRTOS/queue.c **** 
 1346              		.loc 1 1086 13 is_stmt 1 view .LVU416
1086:./FreeRTOS/queue.c **** 
 1347              		.loc 1 1086 31 is_stmt 0 view .LVU417
 1348 0036 A36B     		ldr	r3, [r4, #56]
1088:./FreeRTOS/queue.c **** 
 1349              		.loc 1 1088 48 is_stmt 1 view .LVU418
1095:./FreeRTOS/queue.c **** 
 1350              		.loc 1 1095 13 view .LVU419
1095:./FreeRTOS/queue.c **** 
 1351              		.loc 1 1095 22 is_stmt 0 view .LVU420
 1352 0038 2046     		mov	r0, r4
 1353 003a FFF7FEFF 		bl	prvCopyDataToQueue
 1354              	.LVL132:
1099:./FreeRTOS/queue.c ****             {
 1355              		.loc 1 1099 13 is_stmt 1 view .LVU421
1099:./FreeRTOS/queue.c ****             {
 1356              		.loc 1 1099 15 is_stmt 0 view .LVU422
 1357 003e B6F1FF3F 		cmp	r6, #-1
 1358 0042 0CD1     		bne	.L98
1161:./FreeRTOS/queue.c ****                     {
 1359              		.loc 1 1161 21 is_stmt 1 view .LVU423
1161:./FreeRTOS/queue.c ****                     {
 1360              		.loc 1 1161 25 is_stmt 0 view .LVU424
 1361 0044 636A     		ldr	r3, [r4, #36]
1161:./FreeRTOS/queue.c ****                     {
 1362              		.loc 1 1161 23 view .LVU425
 1363 0046 0BB9     		cbnz	r3, .L105
1198:./FreeRTOS/queue.c ****         }
 1364              		.loc 1 1198 21 view .LVU426
 1365 0048 0120     		movs	r0, #1
 1366 004a EEE7     		b	.L97
 1367              	.L105:
1163:./FreeRTOS/queue.c ****                         {
 1368              		.loc 1 1163 25 is_stmt 1 view .LVU427
1163:./FreeRTOS/queue.c ****                         {
 1369              		.loc 1 1163 29 is_stmt 0 view .LVU428
 1370 004c 04F12400 		add	r0, r4, #36
 1371 0050 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1372              	.LVL133:
1163:./FreeRTOS/queue.c ****                         {
 1373              		.loc 1 1163 27 view .LVU429
 1374 0054 68B1     		cbz	r0, .L101
1167:./FreeRTOS/queue.c ****                             {
 1375              		.loc 1 1167 29 is_stmt 1 view .LVU430
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 79


1167:./FreeRTOS/queue.c ****                             {
 1376              		.loc 1 1167 31 is_stmt 0 view .LVU431
 1377 0056 77B1     		cbz	r7, .L102
1169:./FreeRTOS/queue.c ****                             }
 1378              		.loc 1 1169 33 is_stmt 1 view .LVU432
1169:./FreeRTOS/queue.c ****                             }
 1379              		.loc 1 1169 60 is_stmt 0 view .LVU433
 1380 0058 0120     		movs	r0, #1
 1381 005a 3860     		str	r0, [r7]
 1382 005c E5E7     		b	.L97
 1383              	.L98:
 1384              	.LBB33:
1195:./FreeRTOS/queue.c ****             }
 1385              		.loc 1 1195 17 is_stmt 1 view .LVU434
 1386 005e FFF7FEFF 		bl	uxTaskGetNumberOfTasks
 1387              	.LVL134:
1195:./FreeRTOS/queue.c ****             }
 1388              		.loc 1 1195 17 view .LVU435
 1389 0062 8642     		cmp	r6, r0
 1390 0064 09D2     		bcs	.L103
1195:./FreeRTOS/queue.c ****             }
 1391              		.loc 1 1195 17 discriminator 1 view .LVU436
1195:./FreeRTOS/queue.c ****             }
 1392              		.loc 1 1195 17 discriminator 1 view .LVU437
 1393 0066 0136     		adds	r6, r6, #1
 1394              	.LVL135:
1195:./FreeRTOS/queue.c ****             }
 1395              		.loc 1 1195 17 is_stmt 0 discriminator 1 view .LVU438
 1396 0068 76B2     		sxtb	r6, r6
 1397              	.LVL136:
1195:./FreeRTOS/queue.c ****             }
 1398              		.loc 1 1195 17 discriminator 1 view .LVU439
 1399 006a 84F84560 		strb	r6, [r4, #69]
 1400              	.LBE33:
1198:./FreeRTOS/queue.c ****         }
 1401              		.loc 1 1198 21 discriminator 1 view .LVU440
 1402 006e 0120     		movs	r0, #1
 1403              	.LVL137:
1198:./FreeRTOS/queue.c ****         }
 1404              		.loc 1 1198 21 discriminator 1 view .LVU441
 1405 0070 DBE7     		b	.L97
 1406              	.LVL138:
 1407              	.L101:
1198:./FreeRTOS/queue.c ****         }
 1408              		.loc 1 1198 21 view .LVU442
 1409 0072 0120     		movs	r0, #1
 1410 0074 D9E7     		b	.L97
 1411              	.L102:
 1412 0076 0120     		movs	r0, #1
 1413 0078 D7E7     		b	.L97
 1414              	.LVL139:
 1415              	.L103:
1198:./FreeRTOS/queue.c ****         }
 1416              		.loc 1 1198 21 view .LVU443
 1417 007a 0120     		movs	r0, #1
 1418              	.LVL140:
1198:./FreeRTOS/queue.c ****         }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 80


 1419              		.loc 1 1198 21 view .LVU444
 1420 007c D5E7     		b	.L97
 1421              	.LBE32:
 1422              		.cfi_endproc
 1423              	.LFE40:
 1425              		.section	.text.xQueueGiveFromISR,"ax",%progbits
 1426              		.align	1
 1427              		.global	xQueueGiveFromISR
 1428              		.syntax unified
 1429              		.thumb
 1430              		.thumb_func
 1432              	xQueueGiveFromISR:
 1433              	.LVL141:
 1434              	.LFB41:
1214:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 1435              		.loc 1 1214 1 is_stmt 1 view -0
 1436              		.cfi_startproc
 1437              		@ args = 0, pretend = 0, frame = 0
 1438              		@ frame_needed = 0, uses_anonymous_args = 0
1214:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 1439              		.loc 1 1214 1 is_stmt 0 view .LVU446
 1440 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1441              	.LCFI21:
 1442              		.cfi_def_cfa_offset 24
 1443              		.cfi_offset 3, -24
 1444              		.cfi_offset 4, -20
 1445              		.cfi_offset 5, -16
 1446              		.cfi_offset 6, -12
 1447              		.cfi_offset 7, -8
 1448              		.cfi_offset 14, -4
1215:./FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 1449              		.loc 1 1215 5 is_stmt 1 view .LVU447
1216:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 1450              		.loc 1 1216 5 view .LVU448
1217:./FreeRTOS/queue.c **** 
 1451              		.loc 1 1217 5 view .LVU449
 1452              	.LVL142:
1225:./FreeRTOS/queue.c **** 
 1453              		.loc 1 1225 28 view .LVU450
1229:./FreeRTOS/queue.c **** 
 1454              		.loc 1 1229 45 view .LVU451
1234:./FreeRTOS/queue.c **** 
 1455              		.loc 1 1234 123 view .LVU452
1250:./FreeRTOS/queue.c **** 
 1456              		.loc 1 1250 47 view .LVU453
1252:./FreeRTOS/queue.c ****     {
 1457              		.loc 1 1252 5 view .LVU454
 1458              	.LBB34:
 1459              	.LBI34:
 216:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 1460              		.loc 2 216 38 view .LVU455
 1461              	.LBB35:
 218:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 1462              		.loc 2 218 9 view .LVU456
 220:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         (
 1463              		.loc 2 220 9 view .LVU457
 1464              		.syntax unified
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 81


 1465              	@ 220 "FreeRTOS/portable/GCC/ARM_CM3/portmacro.h" 1
 1466 0002 EFF31185 			mrs r5, basepri											
 1467 0006 4FF0BF03 		mov r3, #191												
 1468 000a 83F31188 		msr basepri, r3											
 1469 000e BFF36F8F 		isb														
 1470 0012 BFF34F8F 		dsb														
 1471              	
 1472              	@ 0 "" 2
 1473              	.LVL143:
 232:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
 1474              		.loc 2 232 9 view .LVU458
 232:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
 1475              		.loc 2 232 9 is_stmt 0 view .LVU459
 1476              		.thumb
 1477              		.syntax unified
 1478              	.LBE35:
 1479              	.LBE34:
 1480              	.LBB36:
1254:./FreeRTOS/queue.c **** 
 1481              		.loc 1 1254 9 is_stmt 1 view .LVU460
1254:./FreeRTOS/queue.c **** 
 1482              		.loc 1 1254 27 is_stmt 0 view .LVU461
 1483 0016 836B     		ldr	r3, [r0, #56]
 1484              	.LVL144:
1259:./FreeRTOS/queue.c ****         {
 1485              		.loc 1 1259 9 is_stmt 1 view .LVU462
1259:./FreeRTOS/queue.c ****         {
 1486              		.loc 1 1259 40 is_stmt 0 view .LVU463
 1487 0018 C26B     		ldr	r2, [r0, #60]
1259:./FreeRTOS/queue.c ****         {
 1488              		.loc 1 1259 11 view .LVU464
 1489 001a 9A42     		cmp	r2, r3
 1490 001c 1FD9     		bls	.L109
 1491 001e 0446     		mov	r4, r0
 1492 0020 0E46     		mov	r6, r1
 1493              	.LBB37:
1261:./FreeRTOS/queue.c **** 
 1494              		.loc 1 1261 13 is_stmt 1 view .LVU465
1261:./FreeRTOS/queue.c **** 
 1495              		.loc 1 1261 26 is_stmt 0 view .LVU466
 1496 0022 90F84570 		ldrb	r7, [r0, #69]	@ zero_extendqisi2
 1497 0026 7FB2     		sxtb	r7, r7
 1498              	.LVL145:
1263:./FreeRTOS/queue.c **** 
 1499              		.loc 1 1263 48 is_stmt 1 view .LVU467
1271:./FreeRTOS/queue.c **** 
 1500              		.loc 1 1271 13 view .LVU468
1271:./FreeRTOS/queue.c **** 
 1501              		.loc 1 1271 60 is_stmt 0 view .LVU469
 1502 0028 0133     		adds	r3, r3, #1
 1503              	.LVL146:
1271:./FreeRTOS/queue.c **** 
 1504              		.loc 1 1271 40 view .LVU470
 1505 002a 8363     		str	r3, [r0, #56]
1275:./FreeRTOS/queue.c ****             {
 1506              		.loc 1 1275 13 is_stmt 1 view .LVU471
1275:./FreeRTOS/queue.c ****             {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 82


 1507              		.loc 1 1275 15 is_stmt 0 view .LVU472
 1508 002c B7F1FF3F 		cmp	r7, #-1
 1509 0030 0BD1     		bne	.L108
1330:./FreeRTOS/queue.c ****                     {
 1510              		.loc 1 1330 21 is_stmt 1 view .LVU473
1330:./FreeRTOS/queue.c ****                     {
 1511              		.loc 1 1330 25 is_stmt 0 view .LVU474
 1512 0032 436A     		ldr	r3, [r0, #36]
 1513              	.LVL147:
1330:./FreeRTOS/queue.c ****                     {
 1514              		.loc 1 1330 23 view .LVU475
 1515 0034 0BB9     		cbnz	r3, .L115
1364:./FreeRTOS/queue.c ****         }
 1516              		.loc 1 1364 21 view .LVU476
 1517 0036 0120     		movs	r0, #1
 1518              	.LVL148:
1364:./FreeRTOS/queue.c ****         }
 1519              		.loc 1 1364 21 view .LVU477
 1520 0038 12E0     		b	.L107
 1521              	.LVL149:
 1522              	.L115:
1332:./FreeRTOS/queue.c ****                         {
 1523              		.loc 1 1332 25 is_stmt 1 view .LVU478
1332:./FreeRTOS/queue.c ****                         {
 1524              		.loc 1 1332 29 is_stmt 0 view .LVU479
 1525 003a 2430     		adds	r0, r0, #36
 1526              	.LVL150:
1332:./FreeRTOS/queue.c ****                         {
 1527              		.loc 1 1332 29 view .LVU480
 1528 003c FFF7FEFF 		bl	xTaskRemoveFromEventList
 1529              	.LVL151:
1332:./FreeRTOS/queue.c ****                         {
 1530              		.loc 1 1332 27 view .LVU481
 1531 0040 88B1     		cbz	r0, .L111
1336:./FreeRTOS/queue.c ****                             {
 1532              		.loc 1 1336 29 is_stmt 1 view .LVU482
1336:./FreeRTOS/queue.c ****                             {
 1533              		.loc 1 1336 31 is_stmt 0 view .LVU483
 1534 0042 96B1     		cbz	r6, .L112
1338:./FreeRTOS/queue.c ****                             }
 1535              		.loc 1 1338 33 is_stmt 1 view .LVU484
1338:./FreeRTOS/queue.c ****                             }
 1536              		.loc 1 1338 60 is_stmt 0 view .LVU485
 1537 0044 0120     		movs	r0, #1
 1538 0046 3060     		str	r0, [r6]
 1539 0048 0AE0     		b	.L107
 1540              	.LVL152:
 1541              	.L108:
 1542              	.LBB38:
1361:./FreeRTOS/queue.c ****             }
 1543              		.loc 1 1361 17 is_stmt 1 view .LVU486
 1544 004a FFF7FEFF 		bl	uxTaskGetNumberOfTasks
 1545              	.LVL153:
1361:./FreeRTOS/queue.c ****             }
 1546              		.loc 1 1361 17 view .LVU487
 1547 004e 8742     		cmp	r7, r0
 1548 0050 0DD2     		bcs	.L113
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 83


1361:./FreeRTOS/queue.c ****             }
 1549              		.loc 1 1361 17 discriminator 1 view .LVU488
1361:./FreeRTOS/queue.c ****             }
 1550              		.loc 1 1361 17 discriminator 1 view .LVU489
 1551 0052 0137     		adds	r7, r7, #1
 1552              	.LVL154:
1361:./FreeRTOS/queue.c ****             }
 1553              		.loc 1 1361 17 is_stmt 0 discriminator 1 view .LVU490
 1554 0054 7FB2     		sxtb	r7, r7
 1555              	.LVL155:
1361:./FreeRTOS/queue.c ****             }
 1556              		.loc 1 1361 17 discriminator 1 view .LVU491
 1557 0056 84F84570 		strb	r7, [r4, #69]
 1558              	.LBE38:
1364:./FreeRTOS/queue.c ****         }
 1559              		.loc 1 1364 21 discriminator 1 view .LVU492
 1560 005a 0120     		movs	r0, #1
 1561              	.LVL156:
1364:./FreeRTOS/queue.c ****         }
 1562              		.loc 1 1364 21 discriminator 1 view .LVU493
 1563 005c 00E0     		b	.L107
 1564              	.LVL157:
 1565              	.L109:
1364:./FreeRTOS/queue.c ****         }
 1566              		.loc 1 1364 21 discriminator 1 view .LVU494
 1567              	.LBE37:
1369:./FreeRTOS/queue.c ****         }
 1568              		.loc 1 1369 21 view .LVU495
 1569 005e 0020     		movs	r0, #0
 1570              	.LVL158:
 1571              	.L107:
1369:./FreeRTOS/queue.c ****         }
 1572              		.loc 1 1369 21 view .LVU496
 1573              	.LBE36:
1372:./FreeRTOS/queue.c **** 
 1574              		.loc 1 1372 5 is_stmt 1 view .LVU497
 1575              	.LBB40:
 1576              	.LBI40:
 236:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 1577              		.loc 2 236 34 view .LVU498
 1578              	.LBB41:
 1579              		.loc 2 238 9 view .LVU499
 1580              		.syntax unified
 1581              	@ 238 "FreeRTOS/portable/GCC/ARM_CM3/portmacro.h" 1
 1582 0060 85F31188 			msr basepri, r5	
 1583              	@ 0 "" 2
 1584              		.thumb
 1585              		.syntax unified
 1586              	.LBE41:
 1587              	.LBE40:
1374:./FreeRTOS/queue.c **** }
 1588              		.loc 1 1374 5 view .LVU500
1375:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 1589              		.loc 1 1375 1 is_stmt 0 view .LVU501
 1590 0064 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1591              	.LVL159:
 1592              	.L111:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 84


 1593              	.LBB42:
 1594              	.LBB39:
1364:./FreeRTOS/queue.c ****         }
 1595              		.loc 1 1364 21 view .LVU502
 1596 0066 0120     		movs	r0, #1
 1597 0068 FAE7     		b	.L107
 1598              	.L112:
 1599 006a 0120     		movs	r0, #1
 1600 006c F8E7     		b	.L107
 1601              	.LVL160:
 1602              	.L113:
1364:./FreeRTOS/queue.c ****         }
 1603              		.loc 1 1364 21 view .LVU503
 1604 006e 0120     		movs	r0, #1
 1605              	.LVL161:
1364:./FreeRTOS/queue.c ****         }
 1606              		.loc 1 1364 21 view .LVU504
 1607 0070 F6E7     		b	.L107
 1608              	.LBE39:
 1609              	.LBE42:
 1610              		.cfi_endproc
 1611              	.LFE41:
 1613              		.section	.text.xQueueReceive,"ax",%progbits
 1614              		.align	1
 1615              		.global	xQueueReceive
 1616              		.syntax unified
 1617              		.thumb
 1618              		.thumb_func
 1620              	xQueueReceive:
 1621              	.LVL162:
 1622              	.LFB42:
1381:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1623              		.loc 1 1381 1 is_stmt 1 view -0
 1624              		.cfi_startproc
 1625              		@ args = 0, pretend = 0, frame = 16
 1626              		@ frame_needed = 0, uses_anonymous_args = 0
1381:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1627              		.loc 1 1381 1 is_stmt 0 view .LVU506
 1628 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1629              	.LCFI22:
 1630              		.cfi_def_cfa_offset 20
 1631              		.cfi_offset 4, -20
 1632              		.cfi_offset 5, -16
 1633              		.cfi_offset 6, -12
 1634              		.cfi_offset 7, -8
 1635              		.cfi_offset 14, -4
 1636 0002 85B0     		sub	sp, sp, #20
 1637              	.LCFI23:
 1638              		.cfi_def_cfa_offset 40
 1639 0004 0446     		mov	r4, r0
 1640 0006 0F46     		mov	r7, r1
 1641 0008 0192     		str	r2, [sp, #4]
1382:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 1642              		.loc 1 1382 5 is_stmt 1 view .LVU507
 1643              	.LVL163:
1383:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 1644              		.loc 1 1383 5 view .LVU508
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 85


1384:./FreeRTOS/queue.c **** 
 1645              		.loc 1 1384 5 view .LVU509
1382:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 1646              		.loc 1 1382 16 is_stmt 0 view .LVU510
 1647 000a 0026     		movs	r6, #0
 1648 000c 3EE0     		b	.L117
 1649              	.LVL164:
 1650              	.L131:
 1651              	.LBB43:
1414:./FreeRTOS/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
 1652              		.loc 1 1414 17 is_stmt 1 view .LVU511
 1653 000e 3946     		mov	r1, r7
 1654 0010 2046     		mov	r0, r4
 1655 0012 FFF7FEFF 		bl	prvCopyDataFromQueue
 1656              	.LVL165:
1415:./FreeRTOS/queue.c ****                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1657              		.loc 1 1415 46 view .LVU512
1416:./FreeRTOS/queue.c **** 
 1658              		.loc 1 1416 17 view .LVU513
1416:./FreeRTOS/queue.c **** 
 1659              		.loc 1 1416 64 is_stmt 0 view .LVU514
 1660 0016 013D     		subs	r5, r5, #1
 1661              	.LVL166:
1416:./FreeRTOS/queue.c **** 
 1662              		.loc 1 1416 44 view .LVU515
 1663 0018 A563     		str	r5, [r4, #56]
1421:./FreeRTOS/queue.c ****                 {
 1664              		.loc 1 1421 17 is_stmt 1 view .LVU516
1421:./FreeRTOS/queue.c ****                 {
 1665              		.loc 1 1421 21 is_stmt 0 view .LVU517
 1666 001a 2369     		ldr	r3, [r4, #16]
1421:./FreeRTOS/queue.c ****                 {
 1667              		.loc 1 1421 19 view .LVU518
 1668 001c 23B9     		cbnz	r3, .L129
 1669              	.L119:
1434:./FreeRTOS/queue.c ****                 }
 1670              		.loc 1 1434 45 is_stmt 1 view .LVU519
1437:./FreeRTOS/queue.c ****                 return pdPASS;
 1671              		.loc 1 1437 17 view .LVU520
 1672 001e FFF7FEFF 		bl	vPortExitCritical
 1673              	.LVL167:
1438:./FreeRTOS/queue.c ****             }
 1674              		.loc 1 1438 17 view .LVU521
1438:./FreeRTOS/queue.c ****             }
 1675              		.loc 1 1438 24 is_stmt 0 view .LVU522
 1676 0022 0120     		movs	r0, #1
 1677              	.LVL168:
 1678              	.L116:
1438:./FreeRTOS/queue.c ****             }
 1679              		.loc 1 1438 24 view .LVU523
 1680              	.LBE43:
1518:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 1681              		.loc 1 1518 1 view .LVU524
 1682 0024 05B0     		add	sp, sp, #20
 1683              	.LCFI24:
 1684              		.cfi_remember_state
 1685              		.cfi_def_cfa_offset 20
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 86


 1686              		@ sp needed
 1687 0026 F0BD     		pop	{r4, r5, r6, r7, pc}
 1688              	.LVL169:
 1689              	.L129:
 1690              	.LCFI25:
 1691              		.cfi_restore_state
 1692              	.LBB44:
1423:./FreeRTOS/queue.c ****                     {
 1693              		.loc 1 1423 21 is_stmt 1 view .LVU525
1423:./FreeRTOS/queue.c ****                     {
 1694              		.loc 1 1423 25 is_stmt 0 view .LVU526
 1695 0028 04F11000 		add	r0, r4, #16
 1696 002c FFF7FEFF 		bl	xTaskRemoveFromEventList
 1697              	.LVL170:
1423:./FreeRTOS/queue.c ****                     {
 1698              		.loc 1 1423 23 view .LVU527
 1699 0030 0028     		cmp	r0, #0
 1700 0032 F4D0     		beq	.L119
1425:./FreeRTOS/queue.c ****                     }
 1701              		.loc 1 1425 25 is_stmt 1 view .LVU528
 1702 0034 4FF0E023 		mov	r3, #-536813568
 1703 0038 4FF08052 		mov	r2, #268435456
 1704 003c C3F8042D 		str	r2, [r3, #3332]
1425:./FreeRTOS/queue.c ****                     }
 1705              		.loc 1 1425 25 view .LVU529
 1706              		.syntax unified
 1707              	@ 1425 "./FreeRTOS/queue.c" 1
 1708 0040 BFF34F8F 		dsb
 1709              	@ 0 "" 2
1425:./FreeRTOS/queue.c ****                     }
 1710              		.loc 1 1425 25 view .LVU530
 1711              	@ 1425 "./FreeRTOS/queue.c" 1
 1712 0044 BFF36F8F 		isb
 1713              	@ 0 "" 2
1425:./FreeRTOS/queue.c ****                     }
 1714              		.loc 1 1425 57 view .LVU531
 1715              		.thumb
 1716              		.syntax unified
 1717 0048 E9E7     		b	.L119
 1718              	.LVL171:
 1719              	.L132:
1446:./FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
 1720              		.loc 1 1446 21 view .LVU532
 1721 004a FFF7FEFF 		bl	vPortExitCritical
 1722              	.LVL172:
1447:./FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
 1723              		.loc 1 1447 57 view .LVU533
1448:./FreeRTOS/queue.c ****                 }
 1724              		.loc 1 1448 21 view .LVU534
1448:./FreeRTOS/queue.c ****                 }
 1725              		.loc 1 1448 28 is_stmt 0 view .LVU535
 1726 004e 0020     		movs	r0, #0
 1727 0050 E8E7     		b	.L116
 1728              	.L133:
1454:./FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 1729              		.loc 1 1454 21 is_stmt 1 view .LVU536
 1730 0052 02A8     		add	r0, sp, #8
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 87


 1731 0054 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 1732              	.LVL173:
1455:./FreeRTOS/queue.c ****                 }
 1733              		.loc 1 1455 21 view .LVU537
1455:./FreeRTOS/queue.c ****                 }
 1734              		.loc 1 1455 35 is_stmt 0 view .LVU538
 1735 0058 0126     		movs	r6, #1
 1736 005a 21E0     		b	.L122
 1737              	.LVL174:
 1738              	.L134:
1455:./FreeRTOS/queue.c ****                 }
 1739              		.loc 1 1455 35 view .LVU539
 1740              	.LBE44:
1470:./FreeRTOS/queue.c **** 
 1741              		.loc 1 1470 9 is_stmt 1 discriminator 1 view .LVU540
 1742 005c 0023     		movs	r3, #0
 1743 005e 84F84430 		strb	r3, [r4, #68]
 1744 0062 29E0     		b	.L123
 1745              	.L135:
1470:./FreeRTOS/queue.c **** 
 1746              		.loc 1 1470 9 discriminator 4 view .LVU541
 1747 0064 0023     		movs	r3, #0
 1748 0066 84F84530 		strb	r3, [r4, #69]
 1749 006a 2BE0     		b	.L124
 1750              	.L126:
1496:./FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
 1751              		.loc 1 1496 17 view .LVU542
 1752 006c 2046     		mov	r0, r4
 1753 006e FFF7FEFF 		bl	prvUnlockQueue
 1754              	.LVL175:
1497:./FreeRTOS/queue.c ****             }
 1755              		.loc 1 1497 17 view .LVU543
1497:./FreeRTOS/queue.c ****             }
 1756              		.loc 1 1497 26 is_stmt 0 view .LVU544
 1757 0072 FFF7FEFF 		bl	xTaskResumeAll
 1758              	.LVL176:
 1759 0076 09E0     		b	.L117
 1760              	.L125:
1504:./FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
 1761              		.loc 1 1504 13 is_stmt 1 view .LVU545
 1762 0078 2046     		mov	r0, r4
 1763 007a FFF7FEFF 		bl	prvUnlockQueue
 1764              	.LVL177:
1505:./FreeRTOS/queue.c **** 
 1765              		.loc 1 1505 13 view .LVU546
1505:./FreeRTOS/queue.c **** 
 1766              		.loc 1 1505 22 is_stmt 0 view .LVU547
 1767 007e FFF7FEFF 		bl	xTaskResumeAll
 1768              	.LVL178:
1507:./FreeRTOS/queue.c ****             {
 1769              		.loc 1 1507 13 is_stmt 1 view .LVU548
1507:./FreeRTOS/queue.c ****             {
 1770              		.loc 1 1507 17 is_stmt 0 view .LVU549
 1771 0082 2046     		mov	r0, r4
 1772 0084 FFF7FEFF 		bl	prvIsQueueEmpty
 1773              	.LVL179:
1507:./FreeRTOS/queue.c ****             {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 88


 1774              		.loc 1 1507 15 view .LVU550
 1775 0088 0028     		cmp	r0, #0
 1776 008a 3FD1     		bne	.L130
 1777              	.LVL180:
 1778              	.L117:
1387:./FreeRTOS/queue.c **** 
 1779              		.loc 1 1387 32 is_stmt 1 view .LVU551
1391:./FreeRTOS/queue.c **** 
 1780              		.loc 1 1391 103 view .LVU552
1396:./FreeRTOS/queue.c ****     }
 1781              		.loc 1 1396 110 view .LVU553
1403:./FreeRTOS/queue.c ****     {
 1782              		.loc 1 1403 5 view .LVU554
1405:./FreeRTOS/queue.c ****         {
 1783              		.loc 1 1405 9 view .LVU555
 1784 008c FFF7FEFF 		bl	vPortEnterCritical
 1785              	.LVL181:
 1786              	.LBB45:
1407:./FreeRTOS/queue.c **** 
 1787              		.loc 1 1407 13 view .LVU556
1407:./FreeRTOS/queue.c **** 
 1788              		.loc 1 1407 31 is_stmt 0 view .LVU557
 1789 0090 A56B     		ldr	r5, [r4, #56]
 1790              	.LVL182:
1411:./FreeRTOS/queue.c ****             {
 1791              		.loc 1 1411 13 is_stmt 1 view .LVU558
1411:./FreeRTOS/queue.c ****             {
 1792              		.loc 1 1411 15 is_stmt 0 view .LVU559
 1793 0092 002D     		cmp	r5, #0
 1794 0094 BBD1     		bne	.L131
1442:./FreeRTOS/queue.c ****                 {
 1795              		.loc 1 1442 17 is_stmt 1 view .LVU560
1442:./FreeRTOS/queue.c ****                 {
 1796              		.loc 1 1442 34 is_stmt 0 view .LVU561
 1797 0096 019B     		ldr	r3, [sp, #4]
1442:./FreeRTOS/queue.c ****                 {
 1798              		.loc 1 1442 19 view .LVU562
 1799 0098 002B     		cmp	r3, #0
 1800 009a D6D0     		beq	.L132
1450:./FreeRTOS/queue.c ****                 {
 1801              		.loc 1 1450 22 is_stmt 1 view .LVU563
1450:./FreeRTOS/queue.c ****                 {
 1802              		.loc 1 1450 24 is_stmt 0 view .LVU564
 1803 009c 002E     		cmp	r6, #0
 1804 009e D8D0     		beq	.L133
 1805              	.LVL183:
 1806              	.L122:
1460:./FreeRTOS/queue.c ****                 }
 1807              		.loc 1 1460 45 is_stmt 1 view .LVU565
 1808              	.LBE45:
1464:./FreeRTOS/queue.c **** 
 1809              		.loc 1 1464 9 view .LVU566
 1810 00a0 FFF7FEFF 		bl	vPortExitCritical
 1811              	.LVL184:
1469:./FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 1812              		.loc 1 1469 9 view .LVU567
 1813 00a4 FFF7FEFF 		bl	vTaskSuspendAll
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 89


 1814              	.LVL185:
1470:./FreeRTOS/queue.c **** 
 1815              		.loc 1 1470 9 view .LVU568
 1816 00a8 FFF7FEFF 		bl	vPortEnterCritical
 1817              	.LVL186:
1470:./FreeRTOS/queue.c **** 
 1818              		.loc 1 1470 9 view .LVU569
 1819 00ac 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 1820 00b0 5BB2     		sxtb	r3, r3
 1821 00b2 B3F1FF3F 		cmp	r3, #-1
 1822 00b6 D1D0     		beq	.L134
 1823              	.L123:
1470:./FreeRTOS/queue.c **** 
 1824              		.loc 1 1470 9 discriminator 3 view .LVU570
 1825 00b8 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 1826 00bc 5BB2     		sxtb	r3, r3
 1827 00be B3F1FF3F 		cmp	r3, #-1
 1828 00c2 CFD0     		beq	.L135
 1829              	.L124:
1470:./FreeRTOS/queue.c **** 
 1830              		.loc 1 1470 9 discriminator 6 view .LVU571
 1831 00c4 FFF7FEFF 		bl	vPortExitCritical
 1832              	.LVL187:
1473:./FreeRTOS/queue.c ****         {
 1833              		.loc 1 1473 9 discriminator 6 view .LVU572
1473:./FreeRTOS/queue.c ****         {
 1834              		.loc 1 1473 13 is_stmt 0 discriminator 6 view .LVU573
 1835 00c8 01A9     		add	r1, sp, #4
 1836 00ca 02A8     		add	r0, sp, #8
 1837 00cc FFF7FEFF 		bl	xTaskCheckForTimeOut
 1838              	.LVL188:
1473:./FreeRTOS/queue.c ****         {
 1839              		.loc 1 1473 11 discriminator 6 view .LVU574
 1840 00d0 0028     		cmp	r0, #0
 1841 00d2 D1D1     		bne	.L125
1477:./FreeRTOS/queue.c ****             {
 1842              		.loc 1 1477 13 is_stmt 1 view .LVU575
1477:./FreeRTOS/queue.c ****             {
 1843              		.loc 1 1477 17 is_stmt 0 view .LVU576
 1844 00d4 2046     		mov	r0, r4
 1845 00d6 FFF7FEFF 		bl	prvIsQueueEmpty
 1846              	.LVL189:
1477:./FreeRTOS/queue.c ****             {
 1847              		.loc 1 1477 15 view .LVU577
 1848 00da 0028     		cmp	r0, #0
 1849 00dc C6D0     		beq	.L126
1479:./FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1850              		.loc 1 1479 58 is_stmt 1 view .LVU578
1480:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
 1851              		.loc 1 1480 17 view .LVU579
 1852 00de 0199     		ldr	r1, [sp, #4]
 1853 00e0 04F12400 		add	r0, r4, #36
 1854 00e4 FFF7FEFF 		bl	vTaskPlaceOnEventList
 1855              	.LVL190:
1481:./FreeRTOS/queue.c **** 
 1856              		.loc 1 1481 17 view .LVU580
 1857 00e8 2046     		mov	r0, r4
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 90


 1858 00ea FFF7FEFF 		bl	prvUnlockQueue
 1859              	.LVL191:
1483:./FreeRTOS/queue.c ****                 {
 1860              		.loc 1 1483 17 view .LVU581
1483:./FreeRTOS/queue.c ****                 {
 1861              		.loc 1 1483 21 is_stmt 0 view .LVU582
 1862 00ee FFF7FEFF 		bl	xTaskResumeAll
 1863              	.LVL192:
1483:./FreeRTOS/queue.c ****                 {
 1864              		.loc 1 1483 19 view .LVU583
 1865 00f2 0028     		cmp	r0, #0
 1866 00f4 CAD1     		bne	.L117
1485:./FreeRTOS/queue.c ****                 }
 1867              		.loc 1 1485 21 is_stmt 1 view .LVU584
 1868 00f6 4FF0E023 		mov	r3, #-536813568
 1869 00fa 4FF08052 		mov	r2, #268435456
 1870 00fe C3F8042D 		str	r2, [r3, #3332]
1485:./FreeRTOS/queue.c ****                 }
 1871              		.loc 1 1485 21 view .LVU585
 1872              		.syntax unified
 1873              	@ 1485 "./FreeRTOS/queue.c" 1
 1874 0102 BFF34F8F 		dsb
 1875              	@ 0 "" 2
1485:./FreeRTOS/queue.c ****                 }
 1876              		.loc 1 1485 21 view .LVU586
 1877              	@ 1485 "./FreeRTOS/queue.c" 1
 1878 0106 BFF36F8F 		isb
 1879              	@ 0 "" 2
1485:./FreeRTOS/queue.c ****                 }
 1880              		.loc 1 1485 43 view .LVU587
 1881              		.thumb
 1882              		.syntax unified
 1883 010a BFE7     		b	.L117
 1884              	.L130:
1510:./FreeRTOS/queue.c ****             }
 1885              		.loc 1 1510 24 is_stmt 0 view .LVU588
 1886 010c 0020     		movs	r0, #0
 1887 010e 89E7     		b	.L116
 1888              		.cfi_endproc
 1889              	.LFE42:
 1891              		.section	.text.xQueueSemaphoreTake,"ax",%progbits
 1892              		.align	1
 1893              		.global	xQueueSemaphoreTake
 1894              		.syntax unified
 1895              		.thumb
 1896              		.thumb_func
 1898              	xQueueSemaphoreTake:
 1899              	.LVL193:
 1900              	.LFB43:
1523:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1901              		.loc 1 1523 1 is_stmt 1 view -0
 1902              		.cfi_startproc
 1903              		@ args = 0, pretend = 0, frame = 16
 1904              		@ frame_needed = 0, uses_anonymous_args = 0
1523:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1905              		.loc 1 1523 1 is_stmt 0 view .LVU590
 1906 0000 70B5     		push	{r4, r5, r6, lr}
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 91


 1907              	.LCFI26:
 1908              		.cfi_def_cfa_offset 16
 1909              		.cfi_offset 4, -16
 1910              		.cfi_offset 5, -12
 1911              		.cfi_offset 6, -8
 1912              		.cfi_offset 14, -4
 1913 0002 84B0     		sub	sp, sp, #16
 1914              	.LCFI27:
 1915              		.cfi_def_cfa_offset 32
 1916 0004 0446     		mov	r4, r0
 1917 0006 0191     		str	r1, [sp, #4]
1524:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 1918              		.loc 1 1524 5 is_stmt 1 view .LVU591
 1919              	.LVL194:
1525:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 1920              		.loc 1 1525 5 view .LVU592
1526:./FreeRTOS/queue.c **** 
 1921              		.loc 1 1526 5 view .LVU593
1529:./FreeRTOS/queue.c ****     #endif
 1922              		.loc 1 1529 9 view .LVU594
1529:./FreeRTOS/queue.c ****     #endif
 1923              		.loc 1 1529 20 is_stmt 0 view .LVU595
 1924 0008 0026     		movs	r6, #0
1524:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 1925              		.loc 1 1524 16 view .LVU596
 1926 000a 3546     		mov	r5, r6
 1927 000c 49E0     		b	.L137
 1928              	.LVL195:
 1929              	.L155:
 1930              	.LBB46:
1561:./FreeRTOS/queue.c **** 
 1931              		.loc 1 1561 46 is_stmt 1 view .LVU597
1565:./FreeRTOS/queue.c **** 
 1932              		.loc 1 1565 17 view .LVU598
1565:./FreeRTOS/queue.c **** 
 1933              		.loc 1 1565 63 is_stmt 0 view .LVU599
 1934 000e 013B     		subs	r3, r3, #1
 1935              	.LVL196:
1565:./FreeRTOS/queue.c **** 
 1936              		.loc 1 1565 44 view .LVU600
 1937 0010 A363     		str	r3, [r4, #56]
1569:./FreeRTOS/queue.c ****                     {
 1938              		.loc 1 1569 21 is_stmt 1 view .LVU601
1569:./FreeRTOS/queue.c ****                     {
 1939              		.loc 1 1569 32 is_stmt 0 view .LVU602
 1940 0012 2368     		ldr	r3, [r4]
 1941              	.LVL197:
1569:./FreeRTOS/queue.c ****                     {
 1942              		.loc 1 1569 23 view .LVU603
 1943 0014 33B1     		cbz	r3, .L152
 1944              	.LVL198:
 1945              	.L139:
1577:./FreeRTOS/queue.c ****                     }
 1946              		.loc 1 1577 49 is_stmt 1 view .LVU604
1584:./FreeRTOS/queue.c ****                 {
 1947              		.loc 1 1584 17 view .LVU605
1584:./FreeRTOS/queue.c ****                 {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 92


 1948              		.loc 1 1584 21 is_stmt 0 view .LVU606
 1949 0016 2369     		ldr	r3, [r4, #16]
1584:./FreeRTOS/queue.c ****                 {
 1950              		.loc 1 1584 19 view .LVU607
 1951 0018 43B9     		cbnz	r3, .L153
 1952              	.L140:
1597:./FreeRTOS/queue.c ****                 }
 1953              		.loc 1 1597 45 is_stmt 1 view .LVU608
1600:./FreeRTOS/queue.c ****                 return pdPASS;
 1954              		.loc 1 1600 17 view .LVU609
 1955 001a FFF7FEFF 		bl	vPortExitCritical
 1956              	.LVL199:
1601:./FreeRTOS/queue.c ****             }
 1957              		.loc 1 1601 17 view .LVU610
1601:./FreeRTOS/queue.c ****             }
 1958              		.loc 1 1601 24 is_stmt 0 view .LVU611
 1959 001e 0120     		movs	r0, #1
 1960              	.L136:
1601:./FreeRTOS/queue.c ****             }
 1961              		.loc 1 1601 24 view .LVU612
 1962              	.LBE46:
1728:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 1963              		.loc 1 1728 1 view .LVU613
 1964 0020 04B0     		add	sp, sp, #16
 1965              	.LCFI28:
 1966              		.cfi_remember_state
 1967              		.cfi_def_cfa_offset 16
 1968              		@ sp needed
 1969 0022 70BD     		pop	{r4, r5, r6, pc}
 1970              	.LVL200:
 1971              	.L152:
 1972              	.LCFI29:
 1973              		.cfi_restore_state
 1974              	.LBB47:
1573:./FreeRTOS/queue.c ****                     }
 1975              		.loc 1 1573 25 is_stmt 1 view .LVU614
1573:./FreeRTOS/queue.c ****                     }
 1976              		.loc 1 1573 62 is_stmt 0 view .LVU615
 1977 0024 FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 1978              	.LVL201:
1573:./FreeRTOS/queue.c ****                     }
 1979              		.loc 1 1573 60 view .LVU616
 1980 0028 A060     		str	r0, [r4, #8]
 1981 002a F4E7     		b	.L139
 1982              	.L153:
1586:./FreeRTOS/queue.c ****                     {
 1983              		.loc 1 1586 21 is_stmt 1 view .LVU617
1586:./FreeRTOS/queue.c ****                     {
 1984              		.loc 1 1586 25 is_stmt 0 view .LVU618
 1985 002c 04F11000 		add	r0, r4, #16
 1986 0030 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1987              	.LVL202:
1586:./FreeRTOS/queue.c ****                     {
 1988              		.loc 1 1586 23 view .LVU619
 1989 0034 0028     		cmp	r0, #0
 1990 0036 F0D0     		beq	.L140
1588:./FreeRTOS/queue.c ****                     }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 93


 1991              		.loc 1 1588 25 is_stmt 1 view .LVU620
 1992 0038 4FF0E023 		mov	r3, #-536813568
 1993 003c 4FF08052 		mov	r2, #268435456
 1994 0040 C3F8042D 		str	r2, [r3, #3332]
1588:./FreeRTOS/queue.c ****                     }
 1995              		.loc 1 1588 25 view .LVU621
 1996              		.syntax unified
 1997              	@ 1588 "./FreeRTOS/queue.c" 1
 1998 0044 BFF34F8F 		dsb
 1999              	@ 0 "" 2
1588:./FreeRTOS/queue.c ****                     }
 2000              		.loc 1 1588 25 view .LVU622
 2001              	@ 1588 "./FreeRTOS/queue.c" 1
 2002 0048 BFF36F8F 		isb
 2003              	@ 0 "" 2
1588:./FreeRTOS/queue.c ****                     }
 2004              		.loc 1 1588 57 view .LVU623
 2005              		.thumb
 2006              		.syntax unified
 2007 004c E5E7     		b	.L140
 2008              	.L156:
1609:./FreeRTOS/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
 2009              		.loc 1 1609 21 view .LVU624
 2010 004e FFF7FEFF 		bl	vPortExitCritical
 2011              	.LVL203:
1610:./FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
 2012              		.loc 1 1610 57 view .LVU625
1611:./FreeRTOS/queue.c ****                 }
 2013              		.loc 1 1611 21 view .LVU626
1611:./FreeRTOS/queue.c ****                 }
 2014              		.loc 1 1611 28 is_stmt 0 view .LVU627
 2015 0052 0020     		movs	r0, #0
 2016 0054 E4E7     		b	.L136
 2017              	.L157:
1617:./FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 2018              		.loc 1 1617 21 is_stmt 1 view .LVU628
 2019 0056 02A8     		add	r0, sp, #8
 2020 0058 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 2021              	.LVL204:
1618:./FreeRTOS/queue.c ****                 }
 2022              		.loc 1 1618 21 view .LVU629
1618:./FreeRTOS/queue.c ****                 }
 2023              		.loc 1 1618 35 is_stmt 0 view .LVU630
 2024 005c 0125     		movs	r5, #1
 2025 005e 2AE0     		b	.L143
 2026              	.LVL205:
 2027              	.L158:
1618:./FreeRTOS/queue.c ****                 }
 2028              		.loc 1 1618 35 view .LVU631
 2029              	.LBE47:
1633:./FreeRTOS/queue.c **** 
 2030              		.loc 1 1633 9 is_stmt 1 discriminator 1 view .LVU632
 2031 0060 0023     		movs	r3, #0
 2032 0062 84F84430 		strb	r3, [r4, #68]
 2033 0066 32E0     		b	.L144
 2034              	.L159:
1633:./FreeRTOS/queue.c **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 94


 2035              		.loc 1 1633 9 discriminator 4 view .LVU633
 2036 0068 0023     		movs	r3, #0
 2037 006a 84F84530 		strb	r3, [r4, #69]
 2038 006e 34E0     		b	.L145
 2039              	.L160:
1650:./FreeRTOS/queue.c ****                         {
 2040              		.loc 1 1650 25 view .LVU634
 2041 0070 FFF7FEFF 		bl	vPortEnterCritical
 2042              	.LVL206:
1652:./FreeRTOS/queue.c ****                         }
 2043              		.loc 1 1652 29 view .LVU635
1652:./FreeRTOS/queue.c ****                         }
 2044              		.loc 1 1652 52 is_stmt 0 view .LVU636
 2045 0074 A068     		ldr	r0, [r4, #8]
 2046 0076 FFF7FEFF 		bl	xTaskPriorityInherit
 2047              	.LVL207:
 2048 007a 0646     		mov	r6, r0
 2049              	.LVL208:
1654:./FreeRTOS/queue.c ****                     }
 2050              		.loc 1 1654 25 is_stmt 1 view .LVU637
 2051 007c FFF7FEFF 		bl	vPortExitCritical
 2052              	.LVL209:
1654:./FreeRTOS/queue.c ****                     }
 2053              		.loc 1 1654 25 is_stmt 0 view .LVU638
 2054 0080 3BE0     		b	.L148
 2055              	.L147:
1679:./FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
 2056              		.loc 1 1679 17 is_stmt 1 view .LVU639
 2057 0082 2046     		mov	r0, r4
 2058 0084 FFF7FEFF 		bl	prvUnlockQueue
 2059              	.LVL210:
1680:./FreeRTOS/queue.c ****             }
 2060              		.loc 1 1680 17 view .LVU640
1680:./FreeRTOS/queue.c ****             }
 2061              		.loc 1 1680 26 is_stmt 0 view .LVU641
 2062 0088 FFF7FEFF 		bl	xTaskResumeAll
 2063              	.LVL211:
 2064 008c 09E0     		b	.L137
 2065              	.L146:
1686:./FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
 2066              		.loc 1 1686 13 is_stmt 1 view .LVU642
 2067 008e 2046     		mov	r0, r4
 2068 0090 FFF7FEFF 		bl	prvUnlockQueue
 2069              	.LVL212:
1687:./FreeRTOS/queue.c **** 
 2070              		.loc 1 1687 13 view .LVU643
1687:./FreeRTOS/queue.c **** 
 2071              		.loc 1 1687 22 is_stmt 0 view .LVU644
 2072 0094 FFF7FEFF 		bl	xTaskResumeAll
 2073              	.LVL213:
1693:./FreeRTOS/queue.c ****             {
 2074              		.loc 1 1693 13 is_stmt 1 view .LVU645
1693:./FreeRTOS/queue.c ****             {
 2075              		.loc 1 1693 17 is_stmt 0 view .LVU646
 2076 0098 2046     		mov	r0, r4
 2077 009a FFF7FEFF 		bl	prvIsQueueEmpty
 2078              	.LVL214:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 95


1693:./FreeRTOS/queue.c ****             {
 2079              		.loc 1 1693 15 view .LVU647
 2080 009e 0028     		cmp	r0, #0
 2081 00a0 42D1     		bne	.L154
 2082              	.LVL215:
 2083              	.L137:
1533:./FreeRTOS/queue.c **** 
 2084              		.loc 1 1533 32 is_stmt 1 view .LVU648
1537:./FreeRTOS/queue.c **** 
 2085              		.loc 1 1537 45 view .LVU649
1542:./FreeRTOS/queue.c ****     }
 2086              		.loc 1 1542 110 view .LVU650
1549:./FreeRTOS/queue.c ****     {
 2087              		.loc 1 1549 5 view .LVU651
1551:./FreeRTOS/queue.c ****         {
 2088              		.loc 1 1551 9 view .LVU652
 2089 00a2 FFF7FEFF 		bl	vPortEnterCritical
 2090              	.LVL216:
 2091              	.LBB48:
1555:./FreeRTOS/queue.c **** 
 2092              		.loc 1 1555 13 view .LVU653
1555:./FreeRTOS/queue.c **** 
 2093              		.loc 1 1555 31 is_stmt 0 view .LVU654
 2094 00a6 A36B     		ldr	r3, [r4, #56]
 2095              	.LVL217:
1559:./FreeRTOS/queue.c ****             {
 2096              		.loc 1 1559 13 is_stmt 1 view .LVU655
1559:./FreeRTOS/queue.c ****             {
 2097              		.loc 1 1559 15 is_stmt 0 view .LVU656
 2098 00a8 002B     		cmp	r3, #0
 2099 00aa B0D1     		bne	.L155
1605:./FreeRTOS/queue.c ****                 {
 2100              		.loc 1 1605 17 is_stmt 1 view .LVU657
1605:./FreeRTOS/queue.c ****                 {
 2101              		.loc 1 1605 34 is_stmt 0 view .LVU658
 2102 00ac 019B     		ldr	r3, [sp, #4]
 2103              	.LVL218:
1605:./FreeRTOS/queue.c ****                 {
 2104              		.loc 1 1605 19 view .LVU659
 2105 00ae 002B     		cmp	r3, #0
 2106 00b0 CDD0     		beq	.L156
1613:./FreeRTOS/queue.c ****                 {
 2107              		.loc 1 1613 22 is_stmt 1 view .LVU660
1613:./FreeRTOS/queue.c ****                 {
 2108              		.loc 1 1613 24 is_stmt 0 view .LVU661
 2109 00b2 002D     		cmp	r5, #0
 2110 00b4 CFD0     		beq	.L157
 2111              	.LVL219:
 2112              	.L143:
1623:./FreeRTOS/queue.c ****                 }
 2113              		.loc 1 1623 45 is_stmt 1 view .LVU662
 2114              	.LBE48:
1627:./FreeRTOS/queue.c **** 
 2115              		.loc 1 1627 9 view .LVU663
 2116 00b6 FFF7FEFF 		bl	vPortExitCritical
 2117              	.LVL220:
1632:./FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 96


 2118              		.loc 1 1632 9 view .LVU664
 2119 00ba FFF7FEFF 		bl	vTaskSuspendAll
 2120              	.LVL221:
1633:./FreeRTOS/queue.c **** 
 2121              		.loc 1 1633 9 view .LVU665
 2122 00be FFF7FEFF 		bl	vPortEnterCritical
 2123              	.LVL222:
1633:./FreeRTOS/queue.c **** 
 2124              		.loc 1 1633 9 view .LVU666
 2125 00c2 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 2126 00c6 5BB2     		sxtb	r3, r3
 2127 00c8 B3F1FF3F 		cmp	r3, #-1
 2128 00cc C8D0     		beq	.L158
 2129              	.L144:
1633:./FreeRTOS/queue.c **** 
 2130              		.loc 1 1633 9 discriminator 3 view .LVU667
 2131 00ce 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 2132 00d2 5BB2     		sxtb	r3, r3
 2133 00d4 B3F1FF3F 		cmp	r3, #-1
 2134 00d8 C6D0     		beq	.L159
 2135              	.L145:
1633:./FreeRTOS/queue.c **** 
 2136              		.loc 1 1633 9 discriminator 6 view .LVU668
 2137 00da FFF7FEFF 		bl	vPortExitCritical
 2138              	.LVL223:
1636:./FreeRTOS/queue.c ****         {
 2139              		.loc 1 1636 9 discriminator 6 view .LVU669
1636:./FreeRTOS/queue.c ****         {
 2140              		.loc 1 1636 13 is_stmt 0 discriminator 6 view .LVU670
 2141 00de 01A9     		add	r1, sp, #4
 2142 00e0 02A8     		add	r0, sp, #8
 2143 00e2 FFF7FEFF 		bl	xTaskCheckForTimeOut
 2144              	.LVL224:
1636:./FreeRTOS/queue.c ****         {
 2145              		.loc 1 1636 11 discriminator 6 view .LVU671
 2146 00e6 0028     		cmp	r0, #0
 2147 00e8 D1D1     		bne	.L146
1642:./FreeRTOS/queue.c ****             {
 2148              		.loc 1 1642 13 is_stmt 1 view .LVU672
1642:./FreeRTOS/queue.c ****             {
 2149              		.loc 1 1642 17 is_stmt 0 view .LVU673
 2150 00ea 2046     		mov	r0, r4
 2151 00ec FFF7FEFF 		bl	prvIsQueueEmpty
 2152              	.LVL225:
1642:./FreeRTOS/queue.c ****             {
 2153              		.loc 1 1642 15 view .LVU674
 2154 00f0 0028     		cmp	r0, #0
 2155 00f2 C6D0     		beq	.L147
1644:./FreeRTOS/queue.c **** 
 2156              		.loc 1 1644 58 is_stmt 1 view .LVU675
1648:./FreeRTOS/queue.c ****                     {
 2157              		.loc 1 1648 21 view .LVU676
1648:./FreeRTOS/queue.c ****                     {
 2158              		.loc 1 1648 32 is_stmt 0 view .LVU677
 2159 00f4 2368     		ldr	r3, [r4]
1648:./FreeRTOS/queue.c ****                     {
 2160              		.loc 1 1648 23 view .LVU678
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 97


 2161 00f6 002B     		cmp	r3, #0
 2162 00f8 BAD0     		beq	.L160
 2163              	.L148:
1658:./FreeRTOS/queue.c ****                     }
 2164              		.loc 1 1658 49 is_stmt 1 view .LVU679
1663:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
 2165              		.loc 1 1663 17 view .LVU680
 2166 00fa 0199     		ldr	r1, [sp, #4]
 2167 00fc 04F12400 		add	r0, r4, #36
 2168 0100 FFF7FEFF 		bl	vTaskPlaceOnEventList
 2169              	.LVL226:
1664:./FreeRTOS/queue.c **** 
 2170              		.loc 1 1664 17 view .LVU681
 2171 0104 2046     		mov	r0, r4
 2172 0106 FFF7FEFF 		bl	prvUnlockQueue
 2173              	.LVL227:
1666:./FreeRTOS/queue.c ****                 {
 2174              		.loc 1 1666 17 view .LVU682
1666:./FreeRTOS/queue.c ****                 {
 2175              		.loc 1 1666 21 is_stmt 0 view .LVU683
 2176 010a FFF7FEFF 		bl	xTaskResumeAll
 2177              	.LVL228:
1666:./FreeRTOS/queue.c ****                 {
 2178              		.loc 1 1666 19 view .LVU684
 2179 010e 0028     		cmp	r0, #0
 2180 0110 C7D1     		bne	.L137
1668:./FreeRTOS/queue.c ****                 }
 2181              		.loc 1 1668 21 is_stmt 1 view .LVU685
 2182 0112 4FF0E023 		mov	r3, #-536813568
 2183 0116 4FF08052 		mov	r2, #268435456
 2184 011a C3F8042D 		str	r2, [r3, #3332]
1668:./FreeRTOS/queue.c ****                 }
 2185              		.loc 1 1668 21 view .LVU686
 2186              		.syntax unified
 2187              	@ 1668 "./FreeRTOS/queue.c" 1
 2188 011e BFF34F8F 		dsb
 2189              	@ 0 "" 2
1668:./FreeRTOS/queue.c ****                 }
 2190              		.loc 1 1668 21 view .LVU687
 2191              	@ 1668 "./FreeRTOS/queue.c" 1
 2192 0122 BFF36F8F 		isb
 2193              	@ 0 "" 2
1668:./FreeRTOS/queue.c ****                 }
 2194              		.loc 1 1668 43 view .LVU688
 2195              		.thumb
 2196              		.syntax unified
 2197 0126 BCE7     		b	.L137
 2198              	.L154:
1700:./FreeRTOS/queue.c ****                     {
 2199              		.loc 1 1700 21 view .LVU689
1700:./FreeRTOS/queue.c ****                     {
 2200              		.loc 1 1700 23 is_stmt 0 view .LVU690
 2201 0128 0EB9     		cbnz	r6, .L161
 2202              	.L150:
1719:./FreeRTOS/queue.c ****                 return errQUEUE_EMPTY;
 2203              		.loc 1 1719 53 is_stmt 1 view .LVU691
1720:./FreeRTOS/queue.c ****             }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 98


 2204              		.loc 1 1720 17 view .LVU692
1720:./FreeRTOS/queue.c ****             }
 2205              		.loc 1 1720 24 is_stmt 0 view .LVU693
 2206 012a 0020     		movs	r0, #0
 2207 012c 78E7     		b	.L136
 2208              	.L161:
1702:./FreeRTOS/queue.c ****                         {
 2209              		.loc 1 1702 25 is_stmt 1 view .LVU694
 2210 012e FFF7FEFF 		bl	vPortEnterCritical
 2211              	.LVL229:
 2212              	.LBB49:
1704:./FreeRTOS/queue.c **** 
 2213              		.loc 1 1704 29 view .LVU695
1711:./FreeRTOS/queue.c ****                             vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder
 2214              		.loc 1 1711 29 view .LVU696
1711:./FreeRTOS/queue.c ****                             vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder
 2215              		.loc 1 1711 56 is_stmt 0 view .LVU697
 2216 0132 2046     		mov	r0, r4
 2217 0134 FFF7FEFF 		bl	prvGetDisinheritPriorityAfterTimeout
 2218              	.LVL230:
 2219 0138 0146     		mov	r1, r0
 2220              	.LVL231:
1712:./FreeRTOS/queue.c ****                         }
 2221              		.loc 1 1712 29 is_stmt 1 view .LVU698
 2222 013a A068     		ldr	r0, [r4, #8]
 2223              	.LVL232:
1712:./FreeRTOS/queue.c ****                         }
 2224              		.loc 1 1712 29 is_stmt 0 view .LVU699
 2225 013c FFF7FEFF 		bl	vTaskPriorityDisinheritAfterTimeout
 2226              	.LVL233:
1712:./FreeRTOS/queue.c ****                         }
 2227              		.loc 1 1712 29 view .LVU700
 2228              	.LBE49:
1714:./FreeRTOS/queue.c ****                     }
 2229              		.loc 1 1714 25 is_stmt 1 view .LVU701
 2230 0140 FFF7FEFF 		bl	vPortExitCritical
 2231              	.LVL234:
 2232 0144 F1E7     		b	.L150
 2233              		.cfi_endproc
 2234              	.LFE43:
 2236              		.section	.text.xQueuePeek,"ax",%progbits
 2237              		.align	1
 2238              		.global	xQueuePeek
 2239              		.syntax unified
 2240              		.thumb
 2241              		.thumb_func
 2243              	xQueuePeek:
 2244              	.LVL235:
 2245              	.LFB44:
1734:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2246              		.loc 1 1734 1 view -0
 2247              		.cfi_startproc
 2248              		@ args = 0, pretend = 0, frame = 16
 2249              		@ frame_needed = 0, uses_anonymous_args = 0
1734:./FreeRTOS/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2250              		.loc 1 1734 1 is_stmt 0 view .LVU703
 2251 0000 70B5     		push	{r4, r5, r6, lr}
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 99


 2252              	.LCFI30:
 2253              		.cfi_def_cfa_offset 16
 2254              		.cfi_offset 4, -16
 2255              		.cfi_offset 5, -12
 2256              		.cfi_offset 6, -8
 2257              		.cfi_offset 14, -4
 2258 0002 84B0     		sub	sp, sp, #16
 2259              	.LCFI31:
 2260              		.cfi_def_cfa_offset 32
 2261 0004 0446     		mov	r4, r0
 2262 0006 0E46     		mov	r6, r1
 2263 0008 0192     		str	r2, [sp, #4]
1735:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 2264              		.loc 1 1735 5 is_stmt 1 view .LVU704
 2265              	.LVL236:
1736:./FreeRTOS/queue.c ****     int8_t * pcOriginalReadPosition;
 2266              		.loc 1 1736 5 view .LVU705
1737:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2267              		.loc 1 1737 5 view .LVU706
1738:./FreeRTOS/queue.c **** 
 2268              		.loc 1 1738 5 view .LVU707
1735:./FreeRTOS/queue.c ****     TimeOut_t xTimeOut;
 2269              		.loc 1 1735 16 is_stmt 0 view .LVU708
 2270 000a 0025     		movs	r5, #0
 2271 000c 3EE0     		b	.L163
 2272              	.LVL237:
 2273              	.L177:
 2274              	.LBB50:
1770:./FreeRTOS/queue.c **** 
 2275              		.loc 1 1770 17 is_stmt 1 view .LVU709
1770:./FreeRTOS/queue.c **** 
 2276              		.loc 1 1770 40 is_stmt 0 view .LVU710
 2277 000e E568     		ldr	r5, [r4, #12]
 2278              	.LVL238:
1772:./FreeRTOS/queue.c ****                 traceQUEUE_PEEK( pxQueue );
 2279              		.loc 1 1772 17 is_stmt 1 view .LVU711
 2280 0010 3146     		mov	r1, r6
 2281 0012 2046     		mov	r0, r4
 2282 0014 FFF7FEFF 		bl	prvCopyDataFromQueue
 2283              	.LVL239:
1773:./FreeRTOS/queue.c **** 
 2284              		.loc 1 1773 43 view .LVU712
1776:./FreeRTOS/queue.c **** 
 2285              		.loc 1 1776 17 view .LVU713
1776:./FreeRTOS/queue.c **** 
 2286              		.loc 1 1776 46 is_stmt 0 view .LVU714
 2287 0018 E560     		str	r5, [r4, #12]
1780:./FreeRTOS/queue.c ****                 {
 2288              		.loc 1 1780 17 is_stmt 1 view .LVU715
1780:./FreeRTOS/queue.c ****                 {
 2289              		.loc 1 1780 21 is_stmt 0 view .LVU716
 2290 001a 636A     		ldr	r3, [r4, #36]
1780:./FreeRTOS/queue.c ****                 {
 2291              		.loc 1 1780 19 view .LVU717
 2292 001c 23B9     		cbnz	r3, .L175
 2293              	.L165:
1794:./FreeRTOS/queue.c ****                 }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 100


 2294              		.loc 1 1794 45 is_stmt 1 view .LVU718
1797:./FreeRTOS/queue.c ****                 return pdPASS;
 2295              		.loc 1 1797 17 view .LVU719
 2296 001e FFF7FEFF 		bl	vPortExitCritical
 2297              	.LVL240:
1798:./FreeRTOS/queue.c ****             }
 2298              		.loc 1 1798 17 view .LVU720
1798:./FreeRTOS/queue.c ****             }
 2299              		.loc 1 1798 24 is_stmt 0 view .LVU721
 2300 0022 0120     		movs	r0, #1
 2301              	.LVL241:
 2302              	.L162:
1798:./FreeRTOS/queue.c ****             }
 2303              		.loc 1 1798 24 view .LVU722
 2304              	.LBE50:
1879:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2305              		.loc 1 1879 1 view .LVU723
 2306 0024 04B0     		add	sp, sp, #16
 2307              	.LCFI32:
 2308              		.cfi_remember_state
 2309              		.cfi_def_cfa_offset 16
 2310              		@ sp needed
 2311 0026 70BD     		pop	{r4, r5, r6, pc}
 2312              	.LVL242:
 2313              	.L175:
 2314              	.LCFI33:
 2315              		.cfi_restore_state
 2316              	.LBB51:
1782:./FreeRTOS/queue.c ****                     {
 2317              		.loc 1 1782 21 is_stmt 1 view .LVU724
1782:./FreeRTOS/queue.c ****                     {
 2318              		.loc 1 1782 25 is_stmt 0 view .LVU725
 2319 0028 04F12400 		add	r0, r4, #36
 2320 002c FFF7FEFF 		bl	xTaskRemoveFromEventList
 2321              	.LVL243:
1782:./FreeRTOS/queue.c ****                     {
 2322              		.loc 1 1782 23 view .LVU726
 2323 0030 0028     		cmp	r0, #0
 2324 0032 F4D0     		beq	.L165
1785:./FreeRTOS/queue.c ****                     }
 2325              		.loc 1 1785 25 is_stmt 1 view .LVU727
 2326 0034 4FF0E023 		mov	r3, #-536813568
 2327 0038 4FF08052 		mov	r2, #268435456
 2328 003c C3F8042D 		str	r2, [r3, #3332]
1785:./FreeRTOS/queue.c ****                     }
 2329              		.loc 1 1785 25 view .LVU728
 2330              		.syntax unified
 2331              	@ 1785 "./FreeRTOS/queue.c" 1
 2332 0040 BFF34F8F 		dsb
 2333              	@ 0 "" 2
1785:./FreeRTOS/queue.c ****                     }
 2334              		.loc 1 1785 25 view .LVU729
 2335              	@ 1785 "./FreeRTOS/queue.c" 1
 2336 0044 BFF36F8F 		isb
 2337              	@ 0 "" 2
1785:./FreeRTOS/queue.c ****                     }
 2338              		.loc 1 1785 57 view .LVU730
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 101


 2339              		.thumb
 2340              		.syntax unified
 2341 0048 E9E7     		b	.L165
 2342              	.LVL244:
 2343              	.L178:
1806:./FreeRTOS/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
 2344              		.loc 1 1806 21 view .LVU731
 2345 004a FFF7FEFF 		bl	vPortExitCritical
 2346              	.LVL245:
1807:./FreeRTOS/queue.c ****                     return errQUEUE_EMPTY;
 2347              		.loc 1 1807 54 view .LVU732
1808:./FreeRTOS/queue.c ****                 }
 2348              		.loc 1 1808 21 view .LVU733
1808:./FreeRTOS/queue.c ****                 }
 2349              		.loc 1 1808 28 is_stmt 0 view .LVU734
 2350 004e 0020     		movs	r0, #0
 2351 0050 E8E7     		b	.L162
 2352              	.L179:
1815:./FreeRTOS/queue.c ****                     xEntryTimeSet = pdTRUE;
 2353              		.loc 1 1815 21 is_stmt 1 view .LVU735
 2354 0052 02A8     		add	r0, sp, #8
 2355 0054 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 2356              	.LVL246:
1816:./FreeRTOS/queue.c ****                 }
 2357              		.loc 1 1816 21 view .LVU736
1816:./FreeRTOS/queue.c ****                 }
 2358              		.loc 1 1816 35 is_stmt 0 view .LVU737
 2359 0058 0125     		movs	r5, #1
 2360 005a 21E0     		b	.L168
 2361              	.LVL247:
 2362              	.L180:
1816:./FreeRTOS/queue.c ****                 }
 2363              		.loc 1 1816 35 view .LVU738
 2364              	.LBE51:
1831:./FreeRTOS/queue.c **** 
 2365              		.loc 1 1831 9 is_stmt 1 discriminator 1 view .LVU739
 2366 005c 0023     		movs	r3, #0
 2367 005e 84F84430 		strb	r3, [r4, #68]
 2368 0062 29E0     		b	.L169
 2369              	.L181:
1831:./FreeRTOS/queue.c **** 
 2370              		.loc 1 1831 9 discriminator 4 view .LVU740
 2371 0064 0023     		movs	r3, #0
 2372 0066 84F84530 		strb	r3, [r4, #69]
 2373 006a 2BE0     		b	.L170
 2374              	.L172:
1857:./FreeRTOS/queue.c ****                 ( void ) xTaskResumeAll();
 2375              		.loc 1 1857 17 view .LVU741
 2376 006c 2046     		mov	r0, r4
 2377 006e FFF7FEFF 		bl	prvUnlockQueue
 2378              	.LVL248:
1858:./FreeRTOS/queue.c ****             }
 2379              		.loc 1 1858 17 view .LVU742
1858:./FreeRTOS/queue.c ****             }
 2380              		.loc 1 1858 26 is_stmt 0 view .LVU743
 2381 0072 FFF7FEFF 		bl	xTaskResumeAll
 2382              	.LVL249:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 102


 2383 0076 09E0     		b	.L163
 2384              	.L171:
1865:./FreeRTOS/queue.c ****             ( void ) xTaskResumeAll();
 2385              		.loc 1 1865 13 is_stmt 1 view .LVU744
 2386 0078 2046     		mov	r0, r4
 2387 007a FFF7FEFF 		bl	prvUnlockQueue
 2388              	.LVL250:
1866:./FreeRTOS/queue.c **** 
 2389              		.loc 1 1866 13 view .LVU745
1866:./FreeRTOS/queue.c **** 
 2390              		.loc 1 1866 22 is_stmt 0 view .LVU746
 2391 007e FFF7FEFF 		bl	xTaskResumeAll
 2392              	.LVL251:
1868:./FreeRTOS/queue.c ****             {
 2393              		.loc 1 1868 13 is_stmt 1 view .LVU747
1868:./FreeRTOS/queue.c ****             {
 2394              		.loc 1 1868 17 is_stmt 0 view .LVU748
 2395 0082 2046     		mov	r0, r4
 2396 0084 FFF7FEFF 		bl	prvIsQueueEmpty
 2397              	.LVL252:
1868:./FreeRTOS/queue.c ****             {
 2398              		.loc 1 1868 15 view .LVU749
 2399 0088 0028     		cmp	r0, #0
 2400 008a 3FD1     		bne	.L176
 2401              	.LVL253:
 2402              	.L163:
1741:./FreeRTOS/queue.c **** 
 2403              		.loc 1 1741 32 is_stmt 1 view .LVU750
1745:./FreeRTOS/queue.c **** 
 2404              		.loc 1 1745 103 view .LVU751
1750:./FreeRTOS/queue.c ****     }
 2405              		.loc 1 1750 110 view .LVU752
1757:./FreeRTOS/queue.c ****     {
 2406              		.loc 1 1757 5 view .LVU753
1759:./FreeRTOS/queue.c ****         {
 2407              		.loc 1 1759 9 view .LVU754
 2408 008c FFF7FEFF 		bl	vPortEnterCritical
 2409              	.LVL254:
 2410              	.LBB52:
1761:./FreeRTOS/queue.c **** 
 2411              		.loc 1 1761 13 view .LVU755
1761:./FreeRTOS/queue.c **** 
 2412              		.loc 1 1761 31 is_stmt 0 view .LVU756
 2413 0090 A36B     		ldr	r3, [r4, #56]
 2414              	.LVL255:
1765:./FreeRTOS/queue.c ****             {
 2415              		.loc 1 1765 13 is_stmt 1 view .LVU757
1765:./FreeRTOS/queue.c ****             {
 2416              		.loc 1 1765 15 is_stmt 0 view .LVU758
 2417 0092 002B     		cmp	r3, #0
 2418 0094 BBD1     		bne	.L177
1802:./FreeRTOS/queue.c ****                 {
 2419              		.loc 1 1802 17 is_stmt 1 view .LVU759
1802:./FreeRTOS/queue.c ****                 {
 2420              		.loc 1 1802 34 is_stmt 0 view .LVU760
 2421 0096 019B     		ldr	r3, [sp, #4]
 2422              	.LVL256:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 103


1802:./FreeRTOS/queue.c ****                 {
 2423              		.loc 1 1802 19 view .LVU761
 2424 0098 002B     		cmp	r3, #0
 2425 009a D6D0     		beq	.L178
1810:./FreeRTOS/queue.c ****                 {
 2426              		.loc 1 1810 22 is_stmt 1 view .LVU762
1810:./FreeRTOS/queue.c ****                 {
 2427              		.loc 1 1810 24 is_stmt 0 view .LVU763
 2428 009c 002D     		cmp	r5, #0
 2429 009e D8D0     		beq	.L179
 2430              	.LVL257:
 2431              	.L168:
1821:./FreeRTOS/queue.c ****                 }
 2432              		.loc 1 1821 45 is_stmt 1 view .LVU764
 2433              	.LBE52:
1825:./FreeRTOS/queue.c **** 
 2434              		.loc 1 1825 9 view .LVU765
 2435 00a0 FFF7FEFF 		bl	vPortExitCritical
 2436              	.LVL258:
1830:./FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 2437              		.loc 1 1830 9 view .LVU766
 2438 00a4 FFF7FEFF 		bl	vTaskSuspendAll
 2439              	.LVL259:
1831:./FreeRTOS/queue.c **** 
 2440              		.loc 1 1831 9 view .LVU767
 2441 00a8 FFF7FEFF 		bl	vPortEnterCritical
 2442              	.LVL260:
1831:./FreeRTOS/queue.c **** 
 2443              		.loc 1 1831 9 view .LVU768
 2444 00ac 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 2445 00b0 5BB2     		sxtb	r3, r3
 2446 00b2 B3F1FF3F 		cmp	r3, #-1
 2447 00b6 D1D0     		beq	.L180
 2448              	.L169:
1831:./FreeRTOS/queue.c **** 
 2449              		.loc 1 1831 9 discriminator 3 view .LVU769
 2450 00b8 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 2451 00bc 5BB2     		sxtb	r3, r3
 2452 00be B3F1FF3F 		cmp	r3, #-1
 2453 00c2 CFD0     		beq	.L181
 2454              	.L170:
1831:./FreeRTOS/queue.c **** 
 2455              		.loc 1 1831 9 discriminator 6 view .LVU770
 2456 00c4 FFF7FEFF 		bl	vPortExitCritical
 2457              	.LVL261:
1834:./FreeRTOS/queue.c ****         {
 2458              		.loc 1 1834 9 discriminator 6 view .LVU771
1834:./FreeRTOS/queue.c ****         {
 2459              		.loc 1 1834 13 is_stmt 0 discriminator 6 view .LVU772
 2460 00c8 01A9     		add	r1, sp, #4
 2461 00ca 02A8     		add	r0, sp, #8
 2462 00cc FFF7FEFF 		bl	xTaskCheckForTimeOut
 2463              	.LVL262:
1834:./FreeRTOS/queue.c ****         {
 2464              		.loc 1 1834 11 discriminator 6 view .LVU773
 2465 00d0 0028     		cmp	r0, #0
 2466 00d2 D1D1     		bne	.L171
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 104


1838:./FreeRTOS/queue.c ****             {
 2467              		.loc 1 1838 13 is_stmt 1 view .LVU774
1838:./FreeRTOS/queue.c ****             {
 2468              		.loc 1 1838 17 is_stmt 0 view .LVU775
 2469 00d4 2046     		mov	r0, r4
 2470 00d6 FFF7FEFF 		bl	prvIsQueueEmpty
 2471              	.LVL263:
1838:./FreeRTOS/queue.c ****             {
 2472              		.loc 1 1838 15 view .LVU776
 2473 00da 0028     		cmp	r0, #0
 2474 00dc C6D0     		beq	.L172
1840:./FreeRTOS/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2475              		.loc 1 1840 55 is_stmt 1 view .LVU777
1841:./FreeRTOS/queue.c ****                 prvUnlockQueue( pxQueue );
 2476              		.loc 1 1841 17 view .LVU778
 2477 00de 0199     		ldr	r1, [sp, #4]
 2478 00e0 04F12400 		add	r0, r4, #36
 2479 00e4 FFF7FEFF 		bl	vTaskPlaceOnEventList
 2480              	.LVL264:
1842:./FreeRTOS/queue.c **** 
 2481              		.loc 1 1842 17 view .LVU779
 2482 00e8 2046     		mov	r0, r4
 2483 00ea FFF7FEFF 		bl	prvUnlockQueue
 2484              	.LVL265:
1844:./FreeRTOS/queue.c ****                 {
 2485              		.loc 1 1844 17 view .LVU780
1844:./FreeRTOS/queue.c ****                 {
 2486              		.loc 1 1844 21 is_stmt 0 view .LVU781
 2487 00ee FFF7FEFF 		bl	xTaskResumeAll
 2488              	.LVL266:
1844:./FreeRTOS/queue.c ****                 {
 2489              		.loc 1 1844 19 view .LVU782
 2490 00f2 0028     		cmp	r0, #0
 2491 00f4 CAD1     		bne	.L163
1846:./FreeRTOS/queue.c ****                 }
 2492              		.loc 1 1846 21 is_stmt 1 view .LVU783
 2493 00f6 4FF0E023 		mov	r3, #-536813568
 2494 00fa 4FF08052 		mov	r2, #268435456
 2495 00fe C3F8042D 		str	r2, [r3, #3332]
1846:./FreeRTOS/queue.c ****                 }
 2496              		.loc 1 1846 21 view .LVU784
 2497              		.syntax unified
 2498              	@ 1846 "./FreeRTOS/queue.c" 1
 2499 0102 BFF34F8F 		dsb
 2500              	@ 0 "" 2
1846:./FreeRTOS/queue.c ****                 }
 2501              		.loc 1 1846 21 view .LVU785
 2502              	@ 1846 "./FreeRTOS/queue.c" 1
 2503 0106 BFF36F8F 		isb
 2504              	@ 0 "" 2
1846:./FreeRTOS/queue.c ****                 }
 2505              		.loc 1 1846 43 view .LVU786
 2506              		.thumb
 2507              		.syntax unified
 2508 010a BFE7     		b	.L163
 2509              	.L176:
1871:./FreeRTOS/queue.c ****             }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 105


 2510              		.loc 1 1871 24 is_stmt 0 view .LVU787
 2511 010c 0020     		movs	r0, #0
 2512 010e 89E7     		b	.L162
 2513              		.cfi_endproc
 2514              	.LFE44:
 2516              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 2517              		.align	1
 2518              		.global	xQueueReceiveFromISR
 2519              		.syntax unified
 2520              		.thumb
 2521              		.thumb_func
 2523              	xQueueReceiveFromISR:
 2524              	.LVL267:
 2525              	.LFB45:
1885:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 2526              		.loc 1 1885 1 is_stmt 1 view -0
 2527              		.cfi_startproc
 2528              		@ args = 0, pretend = 0, frame = 0
 2529              		@ frame_needed = 0, uses_anonymous_args = 0
1885:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 2530              		.loc 1 1885 1 is_stmt 0 view .LVU789
 2531 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 2532              	.LCFI34:
 2533              		.cfi_def_cfa_offset 24
 2534              		.cfi_offset 4, -24
 2535              		.cfi_offset 5, -20
 2536              		.cfi_offset 6, -16
 2537              		.cfi_offset 7, -12
 2538              		.cfi_offset 8, -8
 2539              		.cfi_offset 14, -4
1886:./FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 2540              		.loc 1 1886 5 is_stmt 1 view .LVU790
1887:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2541              		.loc 1 1887 5 view .LVU791
1888:./FreeRTOS/queue.c **** 
 2542              		.loc 1 1888 5 view .LVU792
 2543              	.LVL268:
1890:./FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2544              		.loc 1 1890 28 view .LVU793
1891:./FreeRTOS/queue.c **** 
 2545              		.loc 1 1891 95 view .LVU794
1907:./FreeRTOS/queue.c **** 
 2546              		.loc 1 1907 47 view .LVU795
1909:./FreeRTOS/queue.c ****     {
 2547              		.loc 1 1909 5 view .LVU796
 2548              	.LBB53:
 2549              	.LBI53:
 216:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 2550              		.loc 2 216 38 view .LVU797
 2551              	.LBB54:
 218:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
 2552              		.loc 2 218 9 view .LVU798
 220:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         (
 2553              		.loc 2 220 9 view .LVU799
 2554              		.syntax unified
 2555              	@ 220 "FreeRTOS/portable/GCC/ARM_CM3/portmacro.h" 1
 2556 0004 EFF31185 			mrs r5, basepri											
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 106


 2557 0008 4FF0BF03 		mov r3, #191												
 2558 000c 83F31188 		msr basepri, r3											
 2559 0010 BFF36F8F 		isb														
 2560 0014 BFF34F8F 		dsb														
 2561              	
 2562              	@ 0 "" 2
 2563              	.LVL269:
 232:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
 2564              		.loc 2 232 9 view .LVU800
 232:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
 2565              		.loc 2 232 9 is_stmt 0 view .LVU801
 2566              		.thumb
 2567              		.syntax unified
 2568              	.LBE54:
 2569              	.LBE53:
 2570              	.LBB55:
1911:./FreeRTOS/queue.c **** 
 2571              		.loc 1 1911 9 is_stmt 1 view .LVU802
1911:./FreeRTOS/queue.c **** 
 2572              		.loc 1 1911 27 is_stmt 0 view .LVU803
 2573 0018 866B     		ldr	r6, [r0, #56]
 2574              	.LVL270:
1914:./FreeRTOS/queue.c ****         {
 2575              		.loc 1 1914 9 is_stmt 1 view .LVU804
1914:./FreeRTOS/queue.c ****         {
 2576              		.loc 1 1914 11 is_stmt 0 view .LVU805
 2577 001a 26B9     		cbnz	r6, .L191
1965:./FreeRTOS/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 2578              		.loc 1 1965 21 view .LVU806
 2579 001c 0020     		movs	r0, #0
 2580              	.LVL271:
 2581              	.L183:
1966:./FreeRTOS/queue.c ****         }
 2582              		.loc 1 1966 58 is_stmt 1 view .LVU807
 2583              	.LBE55:
1969:./FreeRTOS/queue.c **** 
 2584              		.loc 1 1969 5 view .LVU808
 2585              	.LBB58:
 2586              	.LBI58:
 236:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 2587              		.loc 2 236 34 view .LVU809
 2588              	.LBB59:
 2589              		.loc 2 238 9 view .LVU810
 2590              		.syntax unified
 2591              	@ 238 "FreeRTOS/portable/GCC/ARM_CM3/portmacro.h" 1
 2592 001e 85F31188 			msr basepri, r5	
 2593              	@ 0 "" 2
 2594              		.thumb
 2595              		.syntax unified
 2596              	.LBE59:
 2597              	.LBE58:
1971:./FreeRTOS/queue.c **** }
 2598              		.loc 1 1971 5 view .LVU811
1972:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2599              		.loc 1 1972 1 is_stmt 0 view .LVU812
 2600 0022 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2601              	.LVL272:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 107


 2602              	.L191:
1972:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2603              		.loc 1 1972 1 view .LVU813
 2604 0026 0446     		mov	r4, r0
 2605 0028 1746     		mov	r7, r2
 2606              	.LBB60:
 2607              	.LBB56:
1916:./FreeRTOS/queue.c **** 
 2608              		.loc 1 1916 13 is_stmt 1 view .LVU814
1916:./FreeRTOS/queue.c **** 
 2609              		.loc 1 1916 26 is_stmt 0 view .LVU815
 2610 002a 90F84480 		ldrb	r8, [r0, #68]	@ zero_extendqisi2
 2611 002e 4FFA88F8 		sxtb	r8, r8
 2612              	.LVL273:
1918:./FreeRTOS/queue.c **** 
 2613              		.loc 1 1918 51 is_stmt 1 view .LVU816
1920:./FreeRTOS/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2614              		.loc 1 1920 13 view .LVU817
 2615 0032 FFF7FEFF 		bl	prvCopyDataFromQueue
 2616              	.LVL274:
1921:./FreeRTOS/queue.c **** 
 2617              		.loc 1 1921 13 view .LVU818
1921:./FreeRTOS/queue.c **** 
 2618              		.loc 1 1921 60 is_stmt 0 view .LVU819
 2619 0036 013E     		subs	r6, r6, #1
 2620              	.LVL275:
1921:./FreeRTOS/queue.c **** 
 2621              		.loc 1 1921 40 view .LVU820
 2622 0038 A663     		str	r6, [r4, #56]
1927:./FreeRTOS/queue.c ****             {
 2623              		.loc 1 1927 13 is_stmt 1 view .LVU821
1927:./FreeRTOS/queue.c ****             {
 2624              		.loc 1 1927 15 is_stmt 0 view .LVU822
 2625 003a B8F1FF3F 		cmp	r8, #-1
 2626 003e 0CD1     		bne	.L184
1929:./FreeRTOS/queue.c ****                 {
 2627              		.loc 1 1929 17 is_stmt 1 view .LVU823
1929:./FreeRTOS/queue.c ****                 {
 2628              		.loc 1 1929 21 is_stmt 0 view .LVU824
 2629 0040 2369     		ldr	r3, [r4, #16]
1929:./FreeRTOS/queue.c ****                 {
 2630              		.loc 1 1929 19 view .LVU825
 2631 0042 0BB9     		cbnz	r3, .L192
1961:./FreeRTOS/queue.c ****         }
 2632              		.loc 1 1961 21 view .LVU826
 2633 0044 0120     		movs	r0, #1
 2634 0046 EAE7     		b	.L183
 2635              	.L192:
1931:./FreeRTOS/queue.c ****                     {
 2636              		.loc 1 1931 21 is_stmt 1 view .LVU827
1931:./FreeRTOS/queue.c ****                     {
 2637              		.loc 1 1931 25 is_stmt 0 view .LVU828
 2638 0048 04F11000 		add	r0, r4, #16
 2639 004c FFF7FEFF 		bl	xTaskRemoveFromEventList
 2640              	.LVL276:
1931:./FreeRTOS/queue.c ****                     {
 2641              		.loc 1 1931 23 view .LVU829
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 108


 2642 0050 78B1     		cbz	r0, .L187
1935:./FreeRTOS/queue.c ****                         {
 2643              		.loc 1 1935 25 is_stmt 1 view .LVU830
1935:./FreeRTOS/queue.c ****                         {
 2644              		.loc 1 1935 27 is_stmt 0 view .LVU831
 2645 0052 87B1     		cbz	r7, .L188
1937:./FreeRTOS/queue.c ****                         }
 2646              		.loc 1 1937 29 is_stmt 1 view .LVU832
1937:./FreeRTOS/queue.c ****                         }
 2647              		.loc 1 1937 56 is_stmt 0 view .LVU833
 2648 0054 0120     		movs	r0, #1
 2649 0056 3860     		str	r0, [r7]
 2650 0058 E1E7     		b	.L183
 2651              	.L184:
 2652              	.LBB57:
1958:./FreeRTOS/queue.c ****             }
 2653              		.loc 1 1958 17 is_stmt 1 view .LVU834
 2654 005a FFF7FEFF 		bl	uxTaskGetNumberOfTasks
 2655              	.LVL277:
1958:./FreeRTOS/queue.c ****             }
 2656              		.loc 1 1958 17 view .LVU835
 2657 005e 8045     		cmp	r8, r0
 2658 0060 0BD2     		bcs	.L189
1958:./FreeRTOS/queue.c ****             }
 2659              		.loc 1 1958 17 discriminator 1 view .LVU836
1958:./FreeRTOS/queue.c ****             }
 2660              		.loc 1 1958 17 discriminator 1 view .LVU837
 2661 0062 08F10108 		add	r8, r8, #1
 2662              	.LVL278:
1958:./FreeRTOS/queue.c ****             }
 2663              		.loc 1 1958 17 is_stmt 0 discriminator 1 view .LVU838
 2664 0066 4FFA88F8 		sxtb	r8, r8
 2665              	.LVL279:
1958:./FreeRTOS/queue.c ****             }
 2666              		.loc 1 1958 17 discriminator 1 view .LVU839
 2667 006a 84F84480 		strb	r8, [r4, #68]
 2668              	.LBE57:
1961:./FreeRTOS/queue.c ****         }
 2669              		.loc 1 1961 21 discriminator 1 view .LVU840
 2670 006e 0120     		movs	r0, #1
 2671              	.LVL280:
1961:./FreeRTOS/queue.c ****         }
 2672              		.loc 1 1961 21 discriminator 1 view .LVU841
 2673 0070 D5E7     		b	.L183
 2674              	.LVL281:
 2675              	.L187:
1961:./FreeRTOS/queue.c ****         }
 2676              		.loc 1 1961 21 view .LVU842
 2677 0072 0120     		movs	r0, #1
 2678 0074 D3E7     		b	.L183
 2679              	.L188:
 2680 0076 0120     		movs	r0, #1
 2681 0078 D1E7     		b	.L183
 2682              	.LVL282:
 2683              	.L189:
1961:./FreeRTOS/queue.c ****         }
 2684              		.loc 1 1961 21 view .LVU843
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 109


 2685 007a 0120     		movs	r0, #1
 2686              	.LVL283:
1961:./FreeRTOS/queue.c ****         }
 2687              		.loc 1 1961 21 view .LVU844
 2688 007c CFE7     		b	.L183
 2689              	.LBE56:
 2690              	.LBE60:
 2691              		.cfi_endproc
 2692              	.LFE45:
 2694              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 2695              		.align	1
 2696              		.global	xQueuePeekFromISR
 2697              		.syntax unified
 2698              		.thumb
 2699              		.thumb_func
 2701              	xQueuePeekFromISR:
 2702              	.LVL284:
 2703              	.LFB46:
1977:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 2704              		.loc 1 1977 1 is_stmt 1 view -0
 2705              		.cfi_startproc
 2706              		@ args = 0, pretend = 0, frame = 0
 2707              		@ frame_needed = 0, uses_anonymous_args = 0
1977:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 2708              		.loc 1 1977 1 is_stmt 0 view .LVU846
 2709 0000 70B5     		push	{r4, r5, r6, lr}
 2710              	.LCFI35:
 2711              		.cfi_def_cfa_offset 16
 2712              		.cfi_offset 4, -16
 2713              		.cfi_offset 5, -12
 2714              		.cfi_offset 6, -8
 2715              		.cfi_offset 14, -4
1978:./FreeRTOS/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 2716              		.loc 1 1978 5 is_stmt 1 view .LVU847
1979:./FreeRTOS/queue.c ****     int8_t * pcOriginalReadPosition;
 2717              		.loc 1 1979 5 view .LVU848
1980:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2718              		.loc 1 1980 5 view .LVU849
1981:./FreeRTOS/queue.c **** 
 2719              		.loc 1 1981 5 view .LVU850
 2720              	.LVL285:
1983:./FreeRTOS/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2721              		.loc 1 1983 28 view .LVU851
1984:./FreeRTOS/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 2722              		.loc 1 1984 95 view .LVU852
1985:./FreeRTOS/queue.c **** 
 2723              		.loc 1 1985 45 view .LVU853
2001:./FreeRTOS/queue.c **** 
 2724              		.loc 1 2001 47 view .LVU854
2003:./FreeRTOS/queue.c ****     {
 2725              		.loc 1 2003 5 view .LVU855
 2726              	.LBB61:
 2727              	.LBI61:
 216:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 2728              		.loc 2 216 38 view .LVU856
 2729              	.LBB62:
 218:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h **** 
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 110


 2730              		.loc 2 218 9 view .LVU857
 220:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****         (
 2731              		.loc 2 220 9 view .LVU858
 2732              		.syntax unified
 2733              	@ 220 "FreeRTOS/portable/GCC/ARM_CM3/portmacro.h" 1
 2734 0002 EFF31185 			mrs r5, basepri											
 2735 0006 4FF0BF03 		mov r3, #191												
 2736 000a 83F31188 		msr basepri, r3											
 2737 000e BFF36F8F 		isb														
 2738 0012 BFF34F8F 		dsb														
 2739              	
 2740              	@ 0 "" 2
 2741              	.LVL286:
 232:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
 2742              		.loc 2 232 9 view .LVU859
 232:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     }
 2743              		.loc 2 232 9 is_stmt 0 view .LVU860
 2744              		.thumb
 2745              		.syntax unified
 2746              	.LBE62:
 2747              	.LBE61:
2006:./FreeRTOS/queue.c ****         {
 2748              		.loc 1 2006 9 is_stmt 1 view .LVU861
2006:./FreeRTOS/queue.c ****         {
 2749              		.loc 1 2006 20 is_stmt 0 view .LVU862
 2750 0016 836B     		ldr	r3, [r0, #56]
2006:./FreeRTOS/queue.c ****         {
 2751              		.loc 1 2006 11 view .LVU863
 2752 0018 1BB9     		cbnz	r3, .L197
2020:./FreeRTOS/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 2753              		.loc 1 2020 21 view .LVU864
 2754 001a 0020     		movs	r0, #0
 2755              	.LVL287:
 2756              	.L194:
2021:./FreeRTOS/queue.c ****         }
 2757              		.loc 1 2021 55 is_stmt 1 view .LVU865
2024:./FreeRTOS/queue.c **** 
 2758              		.loc 1 2024 5 view .LVU866
 2759              	.LBB63:
 2760              	.LBI63:
 236:FreeRTOS/portable/GCC/ARM_CM3/portmacro.h ****     {
 2761              		.loc 2 236 34 view .LVU867
 2762              	.LBB64:
 2763              		.loc 2 238 9 view .LVU868
 2764              		.syntax unified
 2765              	@ 238 "FreeRTOS/portable/GCC/ARM_CM3/portmacro.h" 1
 2766 001c 85F31188 			msr basepri, r5	
 2767              	@ 0 "" 2
 2768              		.thumb
 2769              		.syntax unified
 2770              	.LBE64:
 2771              	.LBE63:
2026:./FreeRTOS/queue.c **** }
 2772              		.loc 1 2026 5 view .LVU869
2027:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2773              		.loc 1 2027 1 is_stmt 0 view .LVU870
 2774 0020 70BD     		pop	{r4, r5, r6, pc}
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 111


 2775              	.LVL288:
 2776              	.L197:
2027:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2777              		.loc 1 2027 1 view .LVU871
 2778 0022 0446     		mov	r4, r0
2008:./FreeRTOS/queue.c **** 
 2779              		.loc 1 2008 48 is_stmt 1 view .LVU872
2012:./FreeRTOS/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 2780              		.loc 1 2012 13 view .LVU873
2012:./FreeRTOS/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 2781              		.loc 1 2012 36 is_stmt 0 view .LVU874
 2782 0024 C668     		ldr	r6, [r0, #12]
 2783              	.LVL289:
2013:./FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2784              		.loc 1 2013 13 is_stmt 1 view .LVU875
 2785 0026 FFF7FEFF 		bl	prvCopyDataFromQueue
 2786              	.LVL290:
2014:./FreeRTOS/queue.c **** 
 2787              		.loc 1 2014 13 view .LVU876
2014:./FreeRTOS/queue.c **** 
 2788              		.loc 1 2014 42 is_stmt 0 view .LVU877
 2789 002a E660     		str	r6, [r4, #12]
2016:./FreeRTOS/queue.c ****         }
 2790              		.loc 1 2016 13 is_stmt 1 view .LVU878
 2791              	.LVL291:
2016:./FreeRTOS/queue.c ****         }
 2792              		.loc 1 2016 21 is_stmt 0 view .LVU879
 2793 002c 0120     		movs	r0, #1
 2794 002e F5E7     		b	.L194
 2795              		.cfi_endproc
 2796              	.LFE46:
 2798              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 2799              		.align	1
 2800              		.global	uxQueueMessagesWaiting
 2801              		.syntax unified
 2802              		.thumb
 2803              		.thumb_func
 2805              	uxQueueMessagesWaiting:
 2806              	.LVL292:
 2807              	.LFB47:
2031:./FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 2808              		.loc 1 2031 1 is_stmt 1 view -0
 2809              		.cfi_startproc
 2810              		@ args = 0, pretend = 0, frame = 0
 2811              		@ frame_needed = 0, uses_anonymous_args = 0
2031:./FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 2812              		.loc 1 2031 1 is_stmt 0 view .LVU881
 2813 0000 10B5     		push	{r4, lr}
 2814              	.LCFI36:
 2815              		.cfi_def_cfa_offset 8
 2816              		.cfi_offset 4, -8
 2817              		.cfi_offset 14, -4
 2818 0002 0446     		mov	r4, r0
2032:./FreeRTOS/queue.c **** 
 2819              		.loc 1 2032 5 is_stmt 1 view .LVU882
2034:./FreeRTOS/queue.c **** 
 2820              		.loc 1 2034 27 view .LVU883
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 112


2036:./FreeRTOS/queue.c ****     {
 2821              		.loc 1 2036 5 view .LVU884
 2822 0004 FFF7FEFF 		bl	vPortEnterCritical
 2823              	.LVL293:
2038:./FreeRTOS/queue.c ****     }
 2824              		.loc 1 2038 9 view .LVU885
2038:./FreeRTOS/queue.c ****     }
 2825              		.loc 1 2038 18 is_stmt 0 view .LVU886
 2826 0008 A46B     		ldr	r4, [r4, #56]
 2827              	.LVL294:
2040:./FreeRTOS/queue.c **** 
 2828              		.loc 1 2040 5 is_stmt 1 view .LVU887
 2829 000a FFF7FEFF 		bl	vPortExitCritical
 2830              	.LVL295:
2042:./FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2831              		.loc 1 2042 5 view .LVU888
2043:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2832              		.loc 1 2043 1 is_stmt 0 view .LVU889
 2833 000e 2046     		mov	r0, r4
 2834 0010 10BD     		pop	{r4, pc}
2043:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2835              		.loc 1 2043 1 view .LVU890
 2836              		.cfi_endproc
 2837              	.LFE47:
 2839              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 2840              		.align	1
 2841              		.global	uxQueueSpacesAvailable
 2842              		.syntax unified
 2843              		.thumb
 2844              		.thumb_func
 2846              	uxQueueSpacesAvailable:
 2847              	.LVL296:
 2848              	.LFB48:
2047:./FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 2849              		.loc 1 2047 1 is_stmt 1 view -0
 2850              		.cfi_startproc
 2851              		@ args = 0, pretend = 0, frame = 0
 2852              		@ frame_needed = 0, uses_anonymous_args = 0
2047:./FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 2853              		.loc 1 2047 1 is_stmt 0 view .LVU892
 2854 0000 10B5     		push	{r4, lr}
 2855              	.LCFI37:
 2856              		.cfi_def_cfa_offset 8
 2857              		.cfi_offset 4, -8
 2858              		.cfi_offset 14, -4
 2859 0002 0446     		mov	r4, r0
2048:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2860              		.loc 1 2048 5 is_stmt 1 view .LVU893
2049:./FreeRTOS/queue.c **** 
 2861              		.loc 1 2049 5 view .LVU894
 2862              	.LVL297:
2051:./FreeRTOS/queue.c **** 
 2863              		.loc 1 2051 28 view .LVU895
2053:./FreeRTOS/queue.c ****     {
 2864              		.loc 1 2053 5 view .LVU896
 2865 0004 FFF7FEFF 		bl	vPortEnterCritical
 2866              	.LVL298:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 113


2055:./FreeRTOS/queue.c ****     }
 2867              		.loc 1 2055 9 view .LVU897
2055:./FreeRTOS/queue.c ****     }
 2868              		.loc 1 2055 27 is_stmt 0 view .LVU898
 2869 0008 E36B     		ldr	r3, [r4, #60]
2055:./FreeRTOS/queue.c ****     }
 2870              		.loc 1 2055 47 view .LVU899
 2871 000a A46B     		ldr	r4, [r4, #56]
 2872              	.LVL299:
2055:./FreeRTOS/queue.c ****     }
 2873              		.loc 1 2055 18 view .LVU900
 2874 000c 1C1B     		subs	r4, r3, r4
 2875              	.LVL300:
2057:./FreeRTOS/queue.c **** 
 2876              		.loc 1 2057 5 is_stmt 1 view .LVU901
 2877 000e FFF7FEFF 		bl	vPortExitCritical
 2878              	.LVL301:
2059:./FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2879              		.loc 1 2059 5 view .LVU902
2060:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2880              		.loc 1 2060 1 is_stmt 0 view .LVU903
 2881 0012 2046     		mov	r0, r4
 2882 0014 10BD     		pop	{r4, pc}
2060:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2883              		.loc 1 2060 1 view .LVU904
 2884              		.cfi_endproc
 2885              	.LFE48:
 2887              		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 2888              		.align	1
 2889              		.global	uxQueueMessagesWaitingFromISR
 2890              		.syntax unified
 2891              		.thumb
 2892              		.thumb_func
 2894              	uxQueueMessagesWaitingFromISR:
 2895              	.LVL302:
 2896              	.LFB49:
2064:./FreeRTOS/queue.c ****     UBaseType_t uxReturn;
 2897              		.loc 1 2064 1 is_stmt 1 view -0
 2898              		.cfi_startproc
 2899              		@ args = 0, pretend = 0, frame = 0
 2900              		@ frame_needed = 0, uses_anonymous_args = 0
 2901              		@ link register save eliminated.
2065:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2902              		.loc 1 2065 5 view .LVU906
2066:./FreeRTOS/queue.c **** 
 2903              		.loc 1 2066 5 view .LVU907
2068:./FreeRTOS/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 2904              		.loc 1 2068 28 view .LVU908
2069:./FreeRTOS/queue.c **** 
 2905              		.loc 1 2069 5 view .LVU909
2069:./FreeRTOS/queue.c **** 
 2906              		.loc 1 2069 14 is_stmt 0 view .LVU910
 2907 0000 806B     		ldr	r0, [r0, #56]
 2908              	.LVL303:
2071:./FreeRTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2909              		.loc 1 2071 5 is_stmt 1 view .LVU911
2072:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 114


 2910              		.loc 1 2072 1 is_stmt 0 view .LVU912
 2911 0002 7047     		bx	lr
 2912              		.cfi_endproc
 2913              	.LFE49:
 2915              		.section	.text.vQueueDelete,"ax",%progbits
 2916              		.align	1
 2917              		.global	vQueueDelete
 2918              		.syntax unified
 2919              		.thumb
 2920              		.thumb_func
 2922              	vQueueDelete:
 2923              	.LVL304:
 2924              	.LFB50:
2076:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2925              		.loc 1 2076 1 is_stmt 1 view -0
 2926              		.cfi_startproc
 2927              		@ args = 0, pretend = 0, frame = 0
 2928              		@ frame_needed = 0, uses_anonymous_args = 0
2076:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 2929              		.loc 1 2076 1 is_stmt 0 view .LVU914
 2930 0000 08B5     		push	{r3, lr}
 2931              	.LCFI38:
 2932              		.cfi_def_cfa_offset 8
 2933              		.cfi_offset 3, -8
 2934              		.cfi_offset 14, -4
2077:./FreeRTOS/queue.c **** 
 2935              		.loc 1 2077 5 is_stmt 1 view .LVU915
 2936              	.LVL305:
2079:./FreeRTOS/queue.c ****     traceQUEUE_DELETE( pxQueue );
 2937              		.loc 1 2079 28 view .LVU916
2080:./FreeRTOS/queue.c **** 
 2938              		.loc 1 2080 33 view .LVU917
2092:./FreeRTOS/queue.c ****     }
 2939              		.loc 1 2092 9 view .LVU918
 2940 0002 FFF7FEFF 		bl	vPortFree
 2941              	.LVL306:
2114:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2942              		.loc 1 2114 1 is_stmt 0 view .LVU919
 2943 0006 08BD     		pop	{r3, pc}
 2944              		.cfi_endproc
 2945              	.LFE50:
 2947              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2948              		.align	1
 2949              		.global	xQueueIsQueueEmptyFromISR
 2950              		.syntax unified
 2951              		.thumb
 2952              		.thumb_func
 2954              	xQueueIsQueueEmptyFromISR:
 2955              	.LVL307:
 2956              	.LFB56:
2421:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 2957              		.loc 1 2421 1 is_stmt 1 view -0
 2958              		.cfi_startproc
 2959              		@ args = 0, pretend = 0, frame = 0
 2960              		@ frame_needed = 0, uses_anonymous_args = 0
 2961              		@ link register save eliminated.
2422:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 115


 2962              		.loc 1 2422 5 view .LVU921
2423:./FreeRTOS/queue.c **** 
 2963              		.loc 1 2423 5 view .LVU922
2425:./FreeRTOS/queue.c **** 
 2964              		.loc 1 2425 28 view .LVU923
2427:./FreeRTOS/queue.c ****     {
 2965              		.loc 1 2427 5 view .LVU924
2427:./FreeRTOS/queue.c ****     {
 2966              		.loc 1 2427 16 is_stmt 0 view .LVU925
 2967 0000 836B     		ldr	r3, [r0, #56]
2427:./FreeRTOS/queue.c ****     {
 2968              		.loc 1 2427 7 view .LVU926
 2969 0002 0BB9     		cbnz	r3, .L207
2429:./FreeRTOS/queue.c ****     }
 2970              		.loc 1 2429 17 view .LVU927
 2971 0004 0120     		movs	r0, #1
 2972              	.LVL308:
2429:./FreeRTOS/queue.c ****     }
 2973              		.loc 1 2429 17 view .LVU928
 2974 0006 7047     		bx	lr
 2975              	.LVL309:
 2976              	.L207:
2433:./FreeRTOS/queue.c ****     }
 2977              		.loc 1 2433 17 view .LVU929
 2978 0008 0020     		movs	r0, #0
 2979              	.LVL310:
2436:./FreeRTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2980              		.loc 1 2436 5 is_stmt 1 view .LVU930
2437:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 2981              		.loc 1 2437 1 is_stmt 0 view .LVU931
 2982 000a 7047     		bx	lr
 2983              		.cfi_endproc
 2984              	.LFE56:
 2986              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2987              		.align	1
 2988              		.global	xQueueIsQueueFullFromISR
 2989              		.syntax unified
 2990              		.thumb
 2991              		.thumb_func
 2993              	xQueueIsQueueFullFromISR:
 2994              	.LVL311:
 2995              	.LFB58:
2459:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2460:./FreeRTOS/queue.c **** 
2461:./FreeRTOS/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2462:./FreeRTOS/queue.c **** {
 2996              		.loc 1 2462 1 is_stmt 1 view -0
 2997              		.cfi_startproc
 2998              		@ args = 0, pretend = 0, frame = 0
 2999              		@ frame_needed = 0, uses_anonymous_args = 0
 3000              		@ link register save eliminated.
2463:./FreeRTOS/queue.c ****     BaseType_t xReturn;
 3001              		.loc 1 2463 5 view .LVU933
2464:./FreeRTOS/queue.c ****     Queue_t * const pxQueue = xQueue;
 3002              		.loc 1 2464 5 view .LVU934
2465:./FreeRTOS/queue.c **** 
2466:./FreeRTOS/queue.c ****     configASSERT( pxQueue );
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 116


 3003              		.loc 1 2466 28 view .LVU935
2467:./FreeRTOS/queue.c **** 
2468:./FreeRTOS/queue.c ****     if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 3004              		.loc 1 2468 5 view .LVU936
 3005              		.loc 1 2468 16 is_stmt 0 view .LVU937
 3006 0000 826B     		ldr	r2, [r0, #56]
 3007              		.loc 1 2468 46 view .LVU938
 3008 0002 C36B     		ldr	r3, [r0, #60]
 3009              		.loc 1 2468 7 view .LVU939
 3010 0004 9A42     		cmp	r2, r3
 3011 0006 01D0     		beq	.L211
2469:./FreeRTOS/queue.c ****     {
2470:./FreeRTOS/queue.c ****         xReturn = pdTRUE;
2471:./FreeRTOS/queue.c ****     }
2472:./FreeRTOS/queue.c ****     else
2473:./FreeRTOS/queue.c ****     {
2474:./FreeRTOS/queue.c ****         xReturn = pdFALSE;
 3012              		.loc 1 2474 17 view .LVU940
 3013 0008 0020     		movs	r0, #0
 3014              	.LVL312:
2475:./FreeRTOS/queue.c ****     }
2476:./FreeRTOS/queue.c **** 
2477:./FreeRTOS/queue.c ****     return xReturn;
 3015              		.loc 1 2477 5 is_stmt 1 view .LVU941
2478:./FreeRTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3016              		.loc 1 2478 1 is_stmt 0 view .LVU942
 3017 000a 7047     		bx	lr
 3018              	.LVL313:
 3019              	.L211:
2470:./FreeRTOS/queue.c ****     }
 3020              		.loc 1 2470 17 view .LVU943
 3021 000c 0120     		movs	r0, #1
 3022              	.LVL314:
2470:./FreeRTOS/queue.c ****     }
 3023              		.loc 1 2470 17 view .LVU944
 3024 000e 7047     		bx	lr
 3025              		.cfi_endproc
 3026              	.LFE58:
 3028              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 3029              		.align	1
 3030              		.global	vQueueWaitForMessageRestricted
 3031              		.syntax unified
 3032              		.thumb
 3033              		.thumb_func
 3035              	vQueueWaitForMessageRestricted:
 3036              	.LVL315:
 3037              	.LFB59:
2479:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2480:./FreeRTOS/queue.c **** 
2481:./FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2482:./FreeRTOS/queue.c **** 
2483:./FreeRTOS/queue.c ****     BaseType_t xQueueCRSend( QueueHandle_t xQueue,
2484:./FreeRTOS/queue.c ****                              const void * pvItemToQueue,
2485:./FreeRTOS/queue.c ****                              TickType_t xTicksToWait )
2486:./FreeRTOS/queue.c ****     {
2487:./FreeRTOS/queue.c ****         BaseType_t xReturn;
2488:./FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 117


2489:./FreeRTOS/queue.c **** 
2490:./FreeRTOS/queue.c ****         /* If the queue is already full we may have to block.  A critical section
2491:./FreeRTOS/queue.c ****          * is required to prevent an interrupt removing something from the queue
2492:./FreeRTOS/queue.c ****          * between the check to see if the queue is full and blocking on the queue. */
2493:./FreeRTOS/queue.c ****         portDISABLE_INTERRUPTS();
2494:./FreeRTOS/queue.c ****         {
2495:./FreeRTOS/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
2496:./FreeRTOS/queue.c ****             {
2497:./FreeRTOS/queue.c ****                 /* The queue is full - do we want to block or just leave without
2498:./FreeRTOS/queue.c ****                  * posting? */
2499:./FreeRTOS/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2500:./FreeRTOS/queue.c ****                 {
2501:./FreeRTOS/queue.c ****                     /* As this is called from a coroutine we cannot block directly, but
2502:./FreeRTOS/queue.c ****                      * return indicating that we need to block. */
2503:./FreeRTOS/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2504:./FreeRTOS/queue.c ****                     portENABLE_INTERRUPTS();
2505:./FreeRTOS/queue.c ****                     return errQUEUE_BLOCKED;
2506:./FreeRTOS/queue.c ****                 }
2507:./FreeRTOS/queue.c ****                 else
2508:./FreeRTOS/queue.c ****                 {
2509:./FreeRTOS/queue.c ****                     portENABLE_INTERRUPTS();
2510:./FreeRTOS/queue.c ****                     return errQUEUE_FULL;
2511:./FreeRTOS/queue.c ****                 }
2512:./FreeRTOS/queue.c ****             }
2513:./FreeRTOS/queue.c ****         }
2514:./FreeRTOS/queue.c ****         portENABLE_INTERRUPTS();
2515:./FreeRTOS/queue.c **** 
2516:./FreeRTOS/queue.c ****         portDISABLE_INTERRUPTS();
2517:./FreeRTOS/queue.c ****         {
2518:./FreeRTOS/queue.c ****             if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2519:./FreeRTOS/queue.c ****             {
2520:./FreeRTOS/queue.c ****                 /* There is room in the queue, copy the data into the queue. */
2521:./FreeRTOS/queue.c ****                 prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2522:./FreeRTOS/queue.c ****                 xReturn = pdPASS;
2523:./FreeRTOS/queue.c **** 
2524:./FreeRTOS/queue.c ****                 /* Were any co-routines waiting for data to become available? */
2525:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2526:./FreeRTOS/queue.c ****                 {
2527:./FreeRTOS/queue.c ****                     /* In this instance the co-routine could be placed directly
2528:./FreeRTOS/queue.c ****                      * into the ready list as we are within a critical section.
2529:./FreeRTOS/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2530:./FreeRTOS/queue.c ****                      * the event were caused from within an interrupt. */
2531:./FreeRTOS/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2532:./FreeRTOS/queue.c ****                     {
2533:./FreeRTOS/queue.c ****                         /* The co-routine waiting has a higher priority so record
2534:./FreeRTOS/queue.c ****                          * that a yield might be appropriate. */
2535:./FreeRTOS/queue.c ****                         xReturn = errQUEUE_YIELD;
2536:./FreeRTOS/queue.c ****                     }
2537:./FreeRTOS/queue.c ****                     else
2538:./FreeRTOS/queue.c ****                     {
2539:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2540:./FreeRTOS/queue.c ****                     }
2541:./FreeRTOS/queue.c ****                 }
2542:./FreeRTOS/queue.c ****                 else
2543:./FreeRTOS/queue.c ****                 {
2544:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2545:./FreeRTOS/queue.c ****                 }
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 118


2546:./FreeRTOS/queue.c ****             }
2547:./FreeRTOS/queue.c ****             else
2548:./FreeRTOS/queue.c ****             {
2549:./FreeRTOS/queue.c ****                 xReturn = errQUEUE_FULL;
2550:./FreeRTOS/queue.c ****             }
2551:./FreeRTOS/queue.c ****         }
2552:./FreeRTOS/queue.c ****         portENABLE_INTERRUPTS();
2553:./FreeRTOS/queue.c **** 
2554:./FreeRTOS/queue.c ****         return xReturn;
2555:./FreeRTOS/queue.c ****     }
2556:./FreeRTOS/queue.c **** 
2557:./FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2558:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2559:./FreeRTOS/queue.c **** 
2560:./FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2561:./FreeRTOS/queue.c **** 
2562:./FreeRTOS/queue.c ****     BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
2563:./FreeRTOS/queue.c ****                                 void * pvBuffer,
2564:./FreeRTOS/queue.c ****                                 TickType_t xTicksToWait )
2565:./FreeRTOS/queue.c ****     {
2566:./FreeRTOS/queue.c ****         BaseType_t xReturn;
2567:./FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
2568:./FreeRTOS/queue.c **** 
2569:./FreeRTOS/queue.c ****         /* If the queue is already empty we may have to block.  A critical section
2570:./FreeRTOS/queue.c ****          * is required to prevent an interrupt adding something to the queue
2571:./FreeRTOS/queue.c ****          * between the check to see if the queue is empty and blocking on the queue. */
2572:./FreeRTOS/queue.c ****         portDISABLE_INTERRUPTS();
2573:./FreeRTOS/queue.c ****         {
2574:./FreeRTOS/queue.c ****             if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2575:./FreeRTOS/queue.c ****             {
2576:./FreeRTOS/queue.c ****                 /* There are no messages in the queue, do we want to block or just
2577:./FreeRTOS/queue.c ****                  * leave with nothing? */
2578:./FreeRTOS/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2579:./FreeRTOS/queue.c ****                 {
2580:./FreeRTOS/queue.c ****                     /* As this is a co-routine we cannot block directly, but return
2581:./FreeRTOS/queue.c ****                      * indicating that we need to block. */
2582:./FreeRTOS/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) 
2583:./FreeRTOS/queue.c ****                     portENABLE_INTERRUPTS();
2584:./FreeRTOS/queue.c ****                     return errQUEUE_BLOCKED;
2585:./FreeRTOS/queue.c ****                 }
2586:./FreeRTOS/queue.c ****                 else
2587:./FreeRTOS/queue.c ****                 {
2588:./FreeRTOS/queue.c ****                     portENABLE_INTERRUPTS();
2589:./FreeRTOS/queue.c ****                     return errQUEUE_FULL;
2590:./FreeRTOS/queue.c ****                 }
2591:./FreeRTOS/queue.c ****             }
2592:./FreeRTOS/queue.c ****             else
2593:./FreeRTOS/queue.c ****             {
2594:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2595:./FreeRTOS/queue.c ****             }
2596:./FreeRTOS/queue.c ****         }
2597:./FreeRTOS/queue.c ****         portENABLE_INTERRUPTS();
2598:./FreeRTOS/queue.c **** 
2599:./FreeRTOS/queue.c ****         portDISABLE_INTERRUPTS();
2600:./FreeRTOS/queue.c ****         {
2601:./FreeRTOS/queue.c ****             if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2602:./FreeRTOS/queue.c ****             {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 119


2603:./FreeRTOS/queue.c ****                 /* Data is available from the queue. */
2604:./FreeRTOS/queue.c ****                 pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2605:./FreeRTOS/queue.c **** 
2606:./FreeRTOS/queue.c ****                 if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2607:./FreeRTOS/queue.c ****                 {
2608:./FreeRTOS/queue.c ****                     pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2609:./FreeRTOS/queue.c ****                 }
2610:./FreeRTOS/queue.c ****                 else
2611:./FreeRTOS/queue.c ****                 {
2612:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2613:./FreeRTOS/queue.c ****                 }
2614:./FreeRTOS/queue.c **** 
2615:./FreeRTOS/queue.c ****                 --( pxQueue->uxMessagesWaiting );
2616:./FreeRTOS/queue.c ****                 ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( un
2617:./FreeRTOS/queue.c **** 
2618:./FreeRTOS/queue.c ****                 xReturn = pdPASS;
2619:./FreeRTOS/queue.c **** 
2620:./FreeRTOS/queue.c ****                 /* Were any co-routines waiting for space to become available? */
2621:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2622:./FreeRTOS/queue.c ****                 {
2623:./FreeRTOS/queue.c ****                     /* In this instance the co-routine could be placed directly
2624:./FreeRTOS/queue.c ****                      * into the ready list as we are within a critical section.
2625:./FreeRTOS/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2626:./FreeRTOS/queue.c ****                      * the event were caused from within an interrupt. */
2627:./FreeRTOS/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2628:./FreeRTOS/queue.c ****                     {
2629:./FreeRTOS/queue.c ****                         xReturn = errQUEUE_YIELD;
2630:./FreeRTOS/queue.c ****                     }
2631:./FreeRTOS/queue.c ****                     else
2632:./FreeRTOS/queue.c ****                     {
2633:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2634:./FreeRTOS/queue.c ****                     }
2635:./FreeRTOS/queue.c ****                 }
2636:./FreeRTOS/queue.c ****                 else
2637:./FreeRTOS/queue.c ****                 {
2638:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2639:./FreeRTOS/queue.c ****                 }
2640:./FreeRTOS/queue.c ****             }
2641:./FreeRTOS/queue.c ****             else
2642:./FreeRTOS/queue.c ****             {
2643:./FreeRTOS/queue.c ****                 xReturn = pdFAIL;
2644:./FreeRTOS/queue.c ****             }
2645:./FreeRTOS/queue.c ****         }
2646:./FreeRTOS/queue.c ****         portENABLE_INTERRUPTS();
2647:./FreeRTOS/queue.c **** 
2648:./FreeRTOS/queue.c ****         return xReturn;
2649:./FreeRTOS/queue.c ****     }
2650:./FreeRTOS/queue.c **** 
2651:./FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2652:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2653:./FreeRTOS/queue.c **** 
2654:./FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2655:./FreeRTOS/queue.c **** 
2656:./FreeRTOS/queue.c ****     BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
2657:./FreeRTOS/queue.c ****                                     const void * pvItemToQueue,
2658:./FreeRTOS/queue.c ****                                     BaseType_t xCoRoutinePreviouslyWoken )
2659:./FreeRTOS/queue.c ****     {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 120


2660:./FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
2661:./FreeRTOS/queue.c **** 
2662:./FreeRTOS/queue.c ****         /* Cannot block within an ISR so if there is no space on the queue then
2663:./FreeRTOS/queue.c ****          * exit without doing anything. */
2664:./FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2665:./FreeRTOS/queue.c ****         {
2666:./FreeRTOS/queue.c ****             prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2667:./FreeRTOS/queue.c **** 
2668:./FreeRTOS/queue.c ****             /* We only want to wake one co-routine per ISR, so check that a
2669:./FreeRTOS/queue.c ****              * co-routine has not already been woken. */
2670:./FreeRTOS/queue.c ****             if( xCoRoutinePreviouslyWoken == pdFALSE )
2671:./FreeRTOS/queue.c ****             {
2672:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2673:./FreeRTOS/queue.c ****                 {
2674:./FreeRTOS/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2675:./FreeRTOS/queue.c ****                     {
2676:./FreeRTOS/queue.c ****                         return pdTRUE;
2677:./FreeRTOS/queue.c ****                     }
2678:./FreeRTOS/queue.c ****                     else
2679:./FreeRTOS/queue.c ****                     {
2680:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2681:./FreeRTOS/queue.c ****                     }
2682:./FreeRTOS/queue.c ****                 }
2683:./FreeRTOS/queue.c ****                 else
2684:./FreeRTOS/queue.c ****                 {
2685:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2686:./FreeRTOS/queue.c ****                 }
2687:./FreeRTOS/queue.c ****             }
2688:./FreeRTOS/queue.c ****             else
2689:./FreeRTOS/queue.c ****             {
2690:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2691:./FreeRTOS/queue.c ****             }
2692:./FreeRTOS/queue.c ****         }
2693:./FreeRTOS/queue.c ****         else
2694:./FreeRTOS/queue.c ****         {
2695:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
2696:./FreeRTOS/queue.c ****         }
2697:./FreeRTOS/queue.c **** 
2698:./FreeRTOS/queue.c ****         return xCoRoutinePreviouslyWoken;
2699:./FreeRTOS/queue.c ****     }
2700:./FreeRTOS/queue.c **** 
2701:./FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2702:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2703:./FreeRTOS/queue.c **** 
2704:./FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2705:./FreeRTOS/queue.c **** 
2706:./FreeRTOS/queue.c ****     BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
2707:./FreeRTOS/queue.c ****                                        void * pvBuffer,
2708:./FreeRTOS/queue.c ****                                        BaseType_t * pxCoRoutineWoken )
2709:./FreeRTOS/queue.c ****     {
2710:./FreeRTOS/queue.c ****         BaseType_t xReturn;
2711:./FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
2712:./FreeRTOS/queue.c **** 
2713:./FreeRTOS/queue.c ****         /* We cannot block from an ISR, so check there is data available. If
2714:./FreeRTOS/queue.c ****          * not then just leave without doing anything. */
2715:./FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2716:./FreeRTOS/queue.c ****         {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 121


2717:./FreeRTOS/queue.c ****             /* Copy the data from the queue. */
2718:./FreeRTOS/queue.c ****             pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2719:./FreeRTOS/queue.c **** 
2720:./FreeRTOS/queue.c ****             if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2721:./FreeRTOS/queue.c ****             {
2722:./FreeRTOS/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2723:./FreeRTOS/queue.c ****             }
2724:./FreeRTOS/queue.c ****             else
2725:./FreeRTOS/queue.c ****             {
2726:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2727:./FreeRTOS/queue.c ****             }
2728:./FreeRTOS/queue.c **** 
2729:./FreeRTOS/queue.c ****             --( pxQueue->uxMessagesWaiting );
2730:./FreeRTOS/queue.c ****             ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsign
2731:./FreeRTOS/queue.c **** 
2732:./FreeRTOS/queue.c ****             if( ( *pxCoRoutineWoken ) == pdFALSE )
2733:./FreeRTOS/queue.c ****             {
2734:./FreeRTOS/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2735:./FreeRTOS/queue.c ****                 {
2736:./FreeRTOS/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2737:./FreeRTOS/queue.c ****                     {
2738:./FreeRTOS/queue.c ****                         *pxCoRoutineWoken = pdTRUE;
2739:./FreeRTOS/queue.c ****                     }
2740:./FreeRTOS/queue.c ****                     else
2741:./FreeRTOS/queue.c ****                     {
2742:./FreeRTOS/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2743:./FreeRTOS/queue.c ****                     }
2744:./FreeRTOS/queue.c ****                 }
2745:./FreeRTOS/queue.c ****                 else
2746:./FreeRTOS/queue.c ****                 {
2747:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2748:./FreeRTOS/queue.c ****                 }
2749:./FreeRTOS/queue.c ****             }
2750:./FreeRTOS/queue.c ****             else
2751:./FreeRTOS/queue.c ****             {
2752:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2753:./FreeRTOS/queue.c ****             }
2754:./FreeRTOS/queue.c **** 
2755:./FreeRTOS/queue.c ****             xReturn = pdPASS;
2756:./FreeRTOS/queue.c ****         }
2757:./FreeRTOS/queue.c ****         else
2758:./FreeRTOS/queue.c ****         {
2759:./FreeRTOS/queue.c ****             xReturn = pdFAIL;
2760:./FreeRTOS/queue.c ****         }
2761:./FreeRTOS/queue.c **** 
2762:./FreeRTOS/queue.c ****         return xReturn;
2763:./FreeRTOS/queue.c ****     }
2764:./FreeRTOS/queue.c **** 
2765:./FreeRTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2766:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2767:./FreeRTOS/queue.c **** 
2768:./FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2769:./FreeRTOS/queue.c **** 
2770:./FreeRTOS/queue.c ****     void vQueueAddToRegistry( QueueHandle_t xQueue,
2771:./FreeRTOS/queue.c ****                               const char * pcQueueName ) /*lint !e971 Unqualified char types are al
2772:./FreeRTOS/queue.c ****     {
2773:./FreeRTOS/queue.c ****         UBaseType_t ux;
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 122


2774:./FreeRTOS/queue.c ****         QueueRegistryItem_t * pxEntryToWrite = NULL;
2775:./FreeRTOS/queue.c **** 
2776:./FreeRTOS/queue.c ****         configASSERT( xQueue );
2777:./FreeRTOS/queue.c **** 
2778:./FreeRTOS/queue.c ****         if( pcQueueName != NULL )
2779:./FreeRTOS/queue.c ****         {
2780:./FreeRTOS/queue.c ****             /* See if there is an empty space in the registry.  A NULL name denotes
2781:./FreeRTOS/queue.c ****              * a free slot. */
2782:./FreeRTOS/queue.c ****             for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2783:./FreeRTOS/queue.c ****             {
2784:./FreeRTOS/queue.c ****                 /* Replace an existing entry if the queue is already in the registry. */
2785:./FreeRTOS/queue.c ****                 if( xQueue == xQueueRegistry[ ux ].xHandle )
2786:./FreeRTOS/queue.c ****                 {
2787:./FreeRTOS/queue.c ****                     pxEntryToWrite = &( xQueueRegistry[ ux ] );
2788:./FreeRTOS/queue.c ****                     break;
2789:./FreeRTOS/queue.c ****                 }
2790:./FreeRTOS/queue.c ****                 /* Otherwise, store in the next empty location */
2791:./FreeRTOS/queue.c ****                 else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL )
2792:./FreeRTOS/queue.c ****                 {
2793:./FreeRTOS/queue.c ****                     pxEntryToWrite = &( xQueueRegistry[ ux ] );
2794:./FreeRTOS/queue.c ****                 }
2795:./FreeRTOS/queue.c ****                 else
2796:./FreeRTOS/queue.c ****                 {
2797:./FreeRTOS/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2798:./FreeRTOS/queue.c ****                 }
2799:./FreeRTOS/queue.c ****             }
2800:./FreeRTOS/queue.c ****         }
2801:./FreeRTOS/queue.c **** 
2802:./FreeRTOS/queue.c ****         if( pxEntryToWrite != NULL )
2803:./FreeRTOS/queue.c ****         {
2804:./FreeRTOS/queue.c ****             /* Store the information on this queue. */
2805:./FreeRTOS/queue.c ****             pxEntryToWrite->pcQueueName = pcQueueName;
2806:./FreeRTOS/queue.c ****             pxEntryToWrite->xHandle = xQueue;
2807:./FreeRTOS/queue.c **** 
2808:./FreeRTOS/queue.c ****             traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2809:./FreeRTOS/queue.c ****         }
2810:./FreeRTOS/queue.c ****     }
2811:./FreeRTOS/queue.c **** 
2812:./FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2813:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2814:./FreeRTOS/queue.c **** 
2815:./FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2816:./FreeRTOS/queue.c **** 
2817:./FreeRTOS/queue.c ****     const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are all
2818:./FreeRTOS/queue.c ****     {
2819:./FreeRTOS/queue.c ****         UBaseType_t ux;
2820:./FreeRTOS/queue.c ****         const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings a
2821:./FreeRTOS/queue.c **** 
2822:./FreeRTOS/queue.c ****         configASSERT( xQueue );
2823:./FreeRTOS/queue.c **** 
2824:./FreeRTOS/queue.c ****         /* Note there is nothing here to protect against another task adding or
2825:./FreeRTOS/queue.c ****          * removing entries from the registry while it is being searched. */
2826:./FreeRTOS/queue.c **** 
2827:./FreeRTOS/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2828:./FreeRTOS/queue.c ****         {
2829:./FreeRTOS/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
2830:./FreeRTOS/queue.c ****             {
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 123


2831:./FreeRTOS/queue.c ****                 pcReturn = xQueueRegistry[ ux ].pcQueueName;
2832:./FreeRTOS/queue.c ****                 break;
2833:./FreeRTOS/queue.c ****             }
2834:./FreeRTOS/queue.c ****             else
2835:./FreeRTOS/queue.c ****             {
2836:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2837:./FreeRTOS/queue.c ****             }
2838:./FreeRTOS/queue.c ****         }
2839:./FreeRTOS/queue.c **** 
2840:./FreeRTOS/queue.c ****         return pcReturn;
2841:./FreeRTOS/queue.c ****     } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
2842:./FreeRTOS/queue.c **** 
2843:./FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2844:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2845:./FreeRTOS/queue.c **** 
2846:./FreeRTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2847:./FreeRTOS/queue.c **** 
2848:./FreeRTOS/queue.c ****     void vQueueUnregisterQueue( QueueHandle_t xQueue )
2849:./FreeRTOS/queue.c ****     {
2850:./FreeRTOS/queue.c ****         UBaseType_t ux;
2851:./FreeRTOS/queue.c **** 
2852:./FreeRTOS/queue.c ****         configASSERT( xQueue );
2853:./FreeRTOS/queue.c **** 
2854:./FreeRTOS/queue.c ****         /* See if the handle of the queue being unregistered in actually in the
2855:./FreeRTOS/queue.c ****          * registry. */
2856:./FreeRTOS/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2857:./FreeRTOS/queue.c ****         {
2858:./FreeRTOS/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
2859:./FreeRTOS/queue.c ****             {
2860:./FreeRTOS/queue.c ****                 /* Set the name to NULL to show that this slot if free again. */
2861:./FreeRTOS/queue.c ****                 xQueueRegistry[ ux ].pcQueueName = NULL;
2862:./FreeRTOS/queue.c **** 
2863:./FreeRTOS/queue.c ****                 /* Set the handle to NULL to ensure the same queue handle cannot
2864:./FreeRTOS/queue.c ****                  * appear in the registry twice if it is added, removed, then
2865:./FreeRTOS/queue.c ****                  * added again. */
2866:./FreeRTOS/queue.c ****                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
2867:./FreeRTOS/queue.c ****                 break;
2868:./FreeRTOS/queue.c ****             }
2869:./FreeRTOS/queue.c ****             else
2870:./FreeRTOS/queue.c ****             {
2871:./FreeRTOS/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2872:./FreeRTOS/queue.c ****             }
2873:./FreeRTOS/queue.c ****         }
2874:./FreeRTOS/queue.c ****     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2875:./FreeRTOS/queue.c **** 
2876:./FreeRTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2877:./FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
2878:./FreeRTOS/queue.c **** 
2879:./FreeRTOS/queue.c **** #if ( configUSE_TIMERS == 1 )
2880:./FreeRTOS/queue.c **** 
2881:./FreeRTOS/queue.c ****     void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
2882:./FreeRTOS/queue.c ****                                          TickType_t xTicksToWait,
2883:./FreeRTOS/queue.c ****                                          const BaseType_t xWaitIndefinitely )
2884:./FreeRTOS/queue.c ****     {
 3038              		.loc 1 2884 5 is_stmt 1 view -0
 3039              		.cfi_startproc
 3040              		@ args = 0, pretend = 0, frame = 0
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 124


 3041              		@ frame_needed = 0, uses_anonymous_args = 0
 3042              		.loc 1 2884 5 is_stmt 0 view .LVU946
 3043 0000 70B5     		push	{r4, r5, r6, lr}
 3044              	.LCFI39:
 3045              		.cfi_def_cfa_offset 16
 3046              		.cfi_offset 4, -16
 3047              		.cfi_offset 5, -12
 3048              		.cfi_offset 6, -8
 3049              		.cfi_offset 14, -4
 3050 0002 0446     		mov	r4, r0
 3051 0004 0D46     		mov	r5, r1
 3052 0006 1646     		mov	r6, r2
2885:./FreeRTOS/queue.c ****         Queue_t * const pxQueue = xQueue;
 3053              		.loc 1 2885 9 is_stmt 1 view .LVU947
 3054              	.LVL316:
2886:./FreeRTOS/queue.c **** 
2887:./FreeRTOS/queue.c ****         /* This function should not be called by application code hence the
2888:./FreeRTOS/queue.c ****          * 'Restricted' in its name.  It is not part of the public API.  It is
2889:./FreeRTOS/queue.c ****          * designed for use by kernel code, and has special calling requirements.
2890:./FreeRTOS/queue.c ****          * It can result in vListInsert() being called on a list that can only
2891:./FreeRTOS/queue.c ****          * possibly ever have one item in it, so the list will be fast, but even
2892:./FreeRTOS/queue.c ****          * so it should be called with the scheduler locked and not from a critical
2893:./FreeRTOS/queue.c ****          * section. */
2894:./FreeRTOS/queue.c **** 
2895:./FreeRTOS/queue.c ****         /* Only do anything if there are no messages in the queue.  This function
2896:./FreeRTOS/queue.c ****          *  will not actually cause the task to block, just place it on a blocked
2897:./FreeRTOS/queue.c ****          *  list.  It will not block until the scheduler is unlocked - at which
2898:./FreeRTOS/queue.c ****          *  time a yield will be performed.  If an item is added to the queue while
2899:./FreeRTOS/queue.c ****          *  the queue is locked, and the calling task blocks on the queue, then the
2900:./FreeRTOS/queue.c ****          *  calling task will be immediately unblocked when the queue is unlocked. */
2901:./FreeRTOS/queue.c ****         prvLockQueue( pxQueue );
 3055              		.loc 1 2901 9 view .LVU948
 3056 0008 FFF7FEFF 		bl	vPortEnterCritical
 3057              	.LVL317:
 3058              		.loc 1 2901 9 view .LVU949
 3059 000c 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 3060 0010 5BB2     		sxtb	r3, r3
 3061 0012 B3F1FF3F 		cmp	r3, #-1
 3062 0016 0DD0     		beq	.L217
 3063              	.L213:
 3064              		.loc 1 2901 9 discriminator 3 view .LVU950
 3065 0018 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 3066 001c 5BB2     		sxtb	r3, r3
 3067 001e B3F1FF3F 		cmp	r3, #-1
 3068 0022 0BD0     		beq	.L218
 3069              	.L214:
 3070              		.loc 1 2901 9 discriminator 6 view .LVU951
 3071 0024 FFF7FEFF 		bl	vPortExitCritical
 3072              	.LVL318:
2902:./FreeRTOS/queue.c **** 
2903:./FreeRTOS/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 3073              		.loc 1 2903 9 discriminator 6 view .LVU952
 3074              		.loc 1 2903 20 is_stmt 0 discriminator 6 view .LVU953
 3075 0028 A36B     		ldr	r3, [r4, #56]
 3076              		.loc 1 2903 11 discriminator 6 view .LVU954
 3077 002a 5BB1     		cbz	r3, .L219
 3078              	.L215:
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 125


2904:./FreeRTOS/queue.c ****         {
2905:./FreeRTOS/queue.c ****             /* There is nothing in the queue, block for the specified period. */
2906:./FreeRTOS/queue.c ****             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xW
2907:./FreeRTOS/queue.c ****         }
2908:./FreeRTOS/queue.c ****         else
2909:./FreeRTOS/queue.c ****         {
2910:./FreeRTOS/queue.c ****             mtCOVERAGE_TEST_MARKER();
 3079              		.loc 1 2910 37 is_stmt 1 view .LVU955
2911:./FreeRTOS/queue.c ****         }
2912:./FreeRTOS/queue.c **** 
2913:./FreeRTOS/queue.c ****         prvUnlockQueue( pxQueue );
 3080              		.loc 1 2913 9 view .LVU956
 3081 002c 2046     		mov	r0, r4
 3082 002e FFF7FEFF 		bl	prvUnlockQueue
 3083              	.LVL319:
2914:./FreeRTOS/queue.c ****     }
 3084              		.loc 1 2914 5 is_stmt 0 view .LVU957
 3085 0032 70BD     		pop	{r4, r5, r6, pc}
 3086              	.LVL320:
 3087              	.L217:
2901:./FreeRTOS/queue.c **** 
 3088              		.loc 1 2901 9 is_stmt 1 discriminator 1 view .LVU958
 3089 0034 0023     		movs	r3, #0
 3090 0036 84F84430 		strb	r3, [r4, #68]
 3091 003a EDE7     		b	.L213
 3092              	.L218:
2901:./FreeRTOS/queue.c **** 
 3093              		.loc 1 2901 9 discriminator 4 view .LVU959
 3094 003c 0023     		movs	r3, #0
 3095 003e 84F84530 		strb	r3, [r4, #69]
 3096 0042 EFE7     		b	.L214
 3097              	.L219:
2906:./FreeRTOS/queue.c ****         }
 3098              		.loc 1 2906 13 view .LVU960
 3099 0044 3246     		mov	r2, r6
 3100 0046 2946     		mov	r1, r5
 3101 0048 04F12400 		add	r0, r4, #36
 3102 004c FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 3103              	.LVL321:
 3104 0050 ECE7     		b	.L215
 3105              		.cfi_endproc
 3106              	.LFE59:
 3108              		.text
 3109              	.Letext0:
 3110              		.file 3 "c:\\vscode_tool_chain\\gcc\\12.2 mpacbti-rel1\\lib\\gcc\\arm-none-eabi\\12.2.1\\include\\
 3111              		.file 4 "c:\\vscode_tool_chain\\gcc\\12.2 mpacbti-rel1\\arm-none-eabi\\include\\machine\\_default_
 3112              		.file 5 "c:\\vscode_tool_chain\\gcc\\12.2 mpacbti-rel1\\arm-none-eabi\\include\\sys\\_stdint.h"
 3113              		.file 6 "FreeRTOS/include/list.h"
 3114              		.file 7 "FreeRTOS/include/task.h"
 3115              		.file 8 "FreeRTOS/include/queue.h"
 3116              		.file 9 "FreeRTOS/include/portable.h"
 3117              		.file 10 "c:\\vscode_tool_chain\\gcc\\12.2 mpacbti-rel1\\arm-none-eabi\\include\\string.h"
 3118              		.file 11 "<built-in>"
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 126


DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:19     .text.prvGetDisinheritPriorityAfterTimeout:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:24     .text.prvGetDisinheritPriorityAfterTimeout:00000000 prvGetDisinheritPriorityAfterTimeout
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:58     .text.prvIsQueueFull:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:63     .text.prvIsQueueFull:00000000 prvIsQueueFull
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:111    .text.prvIsQueueEmpty:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:116    .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:161    .text.prvCopyDataToQueue:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:166    .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:325    .text.prvCopyDataFromQueue:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:330    .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:382    .text.prvUnlockQueue:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:387    .text.prvUnlockQueue:00000000 prvUnlockQueue
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:512    .text.xQueueGenericReset:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:518    .text.xQueueGenericReset:00000000 xQueueGenericReset
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:690    .text.prvInitialiseNewQueue:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:695    .text.prvInitialiseNewQueue:00000000 prvInitialiseNewQueue
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:748    .text.xQueueGenericCreate:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:754    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:867    .text.xQueueGenericSend:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:873    .text.xQueueGenericSend:00000000 xQueueGenericSend
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1149   .text.prvInitialiseMutex:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1154   .text.prvInitialiseMutex:00000000 prvInitialiseMutex
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1202   .text.xQueueCreateMutex:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1208   .text.xQueueCreateMutex:00000000 xQueueCreateMutex
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1247   .text.xQueueGenericSendFromISR:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1253   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1426   .text.xQueueGiveFromISR:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1432   .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1614   .text.xQueueReceive:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1620   .text.xQueueReceive:00000000 xQueueReceive
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1892   .text.xQueueSemaphoreTake:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:1898   .text.xQueueSemaphoreTake:00000000 xQueueSemaphoreTake
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2237   .text.xQueuePeek:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2243   .text.xQueuePeek:00000000 xQueuePeek
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2517   .text.xQueueReceiveFromISR:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2523   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2695   .text.xQueuePeekFromISR:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2701   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2799   .text.uxQueueMessagesWaiting:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2805   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2840   .text.uxQueueSpacesAvailable:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2846   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2888   .text.uxQueueMessagesWaitingFromISR:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2894   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2916   .text.vQueueDelete:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2922   .text.vQueueDelete:00000000 vQueueDelete
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2948   .text.xQueueIsQueueEmptyFromISR:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2954   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2987   .text.xQueueIsQueueFullFromISR:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:2993   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:3029   .text.vQueueWaitForMessageRestricted:00000000 $t
C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s:3035   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted

UNDEFINED SYMBOLS
vPortEnterCritical
ARM GAS  C:\Users\24105\AppData\Local\Temp\cciYKwyZ.s 			page 127


vPortExitCritical
xTaskPriorityDisinherit
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vListInitialise
pvPortMalloc
vTaskInternalSetTimeOutState
xTaskResumeAll
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
uxTaskGetNumberOfTasks
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
vPortFree
vTaskPlaceOnEventListRestricted
